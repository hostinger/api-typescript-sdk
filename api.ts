/* tslint:disable */
/* eslint-disable */
/**
 * Hostinger API
 *
 * API Version: 0.0.97
 *
 * NOTE: This file is auto-generated, DO NOT EDIT THIS FILE MANUALLY!
 * If you want to contribute or request a new feature, please create an issue or pull request on https://github.com/hostinger/api
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BillingV1CatalogCatalogItemPriceResource
 */
export interface BillingV1CatalogCatalogItemPriceResource {
    /**
     * Price item ID
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'id': string;
    /**
     * Price item name
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'name': string;
    /**
     * Currency code
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'currency': string;
    /**
     * Price in cents
     * @type {number}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'price': number;
    /**
     * First period price in cents
     * @type {number}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'first_period_price': number;
    /**
     * Period
     * @type {number}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'period': number;
    /**
     * Period unit
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'period_unit': BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum;
}

export const BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year',
    None: 'none'
} as const;

export type BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum = typeof BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum[keyof typeof BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum];

/**
 * 
 * @export
 * @interface BillingV1CatalogCatalogItemResource
 */
export interface BillingV1CatalogCatalogItemResource {
    /**
     * Catalog item ID
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'category': string;
    /**
     * Flexible key-value storage containing category-specific metadata for the catalog item. The structure and available fields vary depending on the item category.
     * @type {object}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'metadata': object | null;
    /**
     * Array of [`Billing.V1.Catalog.CatalogItemPriceResource`](#model/billingv1catalogcatalogitempriceresource)
     * @type {Array<BillingV1CatalogCatalogItemPriceResource>}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'prices': Array<BillingV1CatalogCatalogItemPriceResource>;
}
/**
 * 
 * @export
 * @interface BillingV1OrderOrderBillingAddressResource
 */
export interface BillingV1OrderOrderBillingAddressResource {
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'company': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'address_1': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'address_2': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'city': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'state': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'zip': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'country': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface BillingV1OrderOrderResource
 */
export interface BillingV1OrderOrderResource {
    /**
     * Order ID
     * @type {number}
     * @memberof BillingV1OrderOrderResource
     */
    'id': number;
    /**
     * Subscription ID
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'subscription_id': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'status': BillingV1OrderOrderResourceStatusEnum;
    /**
     * Currency code
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'currency': string;
    /**
     * Subtotal price (exc. VAT) in cents
     * @type {number}
     * @memberof BillingV1OrderOrderResource
     */
    'subtotal': number;
    /**
     * Total price (inc. VAT) in cents
     * @type {number}
     * @memberof BillingV1OrderOrderResource
     */
    'total': number;
    /**
     * 
     * @type {BillingV1OrderOrderBillingAddressResource}
     * @memberof BillingV1OrderOrderResource
     */
    'billing_address': BillingV1OrderOrderBillingAddressResource;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'updated_at': string;
}

export const BillingV1OrderOrderResourceStatusEnum = {
    Completed: 'completed',
    Pending: 'pending',
    Processing: 'processing',
    Failed: 'failed',
    Refunded: 'refunded',
    Cancelled: 'cancelled',
    AwaitingPayment: 'awaiting_payment',
    PaymentInitiated: 'payment_initiated',
    FraudRefund: 'fraud_refund'
} as const;

export type BillingV1OrderOrderResourceStatusEnum = typeof BillingV1OrderOrderResourceStatusEnum[keyof typeof BillingV1OrderOrderResourceStatusEnum];

/**
 * 
 * @export
 * @interface BillingV1OrderStoreRequest
 */
export interface BillingV1OrderStoreRequest {
    /**
     * Payment method ID
     * @type {number}
     * @memberof BillingV1OrderStoreRequest
     */
    'payment_method_id': number;
    /**
     * 
     * @type {Array<BillingV1OrderStoreRequestItemsInner>}
     * @memberof BillingV1OrderStoreRequest
     */
    'items': Array<BillingV1OrderStoreRequestItemsInner>;
    /**
     * Discount coupon codes
     * @type {Array<any>}
     * @memberof BillingV1OrderStoreRequest
     */
    'coupons': Array<any>;
}
/**
 * 
 * @export
 * @interface BillingV1OrderStoreRequestItemsInner
 */
export interface BillingV1OrderStoreRequestItemsInner {
    /**
     * Price Item ID
     * @type {string}
     * @memberof BillingV1OrderStoreRequestItemsInner
     */
    'item_id': string;
    /**
     * 
     * @type {number}
     * @memberof BillingV1OrderStoreRequestItemsInner
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface BillingV1OrderVirtualMachineOrderResource
 */
export interface BillingV1OrderVirtualMachineOrderResource {
    /**
     * 
     * @type {BillingV1OrderOrderResource}
     * @memberof BillingV1OrderVirtualMachineOrderResource
     */
    'order': BillingV1OrderOrderResource;
    /**
     * 
     * @type {VPSV1VirtualMachineVirtualMachineResource}
     * @memberof BillingV1OrderVirtualMachineOrderResource
     */
    'virtual_machine': VPSV1VirtualMachineVirtualMachineResource;
}
/**
 * 
 * @export
 * @interface BillingV1PaymentMethodPaymentMethodResource
 */
export interface BillingV1PaymentMethodPaymentMethodResource {
    /**
     * Payment method ID
     * @type {number}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'payment_method': string;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'is_default': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'is_expired': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'is_suspended': boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface BillingV1SubscriptionCancelRequest
 */
export interface BillingV1SubscriptionCancelRequest {
    /**
     * Cancellation reason code
     * @type {string}
     * @memberof BillingV1SubscriptionCancelRequest
     */
    'reason_code': BillingV1SubscriptionCancelRequestReasonCodeEnum | null;
    /**
     * Cancellation option
     * @type {string}
     * @memberof BillingV1SubscriptionCancelRequest
     */
    'cancel_option': BillingV1SubscriptionCancelRequestCancelOptionEnum | null;
}

export const BillingV1SubscriptionCancelRequestReasonCodeEnum = {
    Other: 'other'
} as const;

export type BillingV1SubscriptionCancelRequestReasonCodeEnum = typeof BillingV1SubscriptionCancelRequestReasonCodeEnum[keyof typeof BillingV1SubscriptionCancelRequestReasonCodeEnum];
export const BillingV1SubscriptionCancelRequestCancelOptionEnum = {
    Immediately: 'immediately'
} as const;

export type BillingV1SubscriptionCancelRequestCancelOptionEnum = typeof BillingV1SubscriptionCancelRequestCancelOptionEnum[keyof typeof BillingV1SubscriptionCancelRequestCancelOptionEnum];

/**
 * 
 * @export
 * @interface BillingV1SubscriptionSubscriptionResource
 */
export interface BillingV1SubscriptionSubscriptionResource {
    /**
     * Subscription ID
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'status': BillingV1SubscriptionSubscriptionResourceStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'billing_period': number;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'billing_period_unit': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'currency_code': string;
    /**
     * Total price in cents
     * @type {number}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'total_price': number;
    /**
     * Renewal price in cents
     * @type {number}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'renewal_price': number;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'is_auto_renewed': boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'expires_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'next_billing_at': string | null;
}

export const BillingV1SubscriptionSubscriptionResourceStatusEnum = {
    Active: 'active',
    Paused: 'paused',
    Cancelled: 'cancelled',
    NotRenewing: 'not_renewing',
    Transferred: 'transferred',
    InTrial: 'in_trial',
    Future: 'future'
} as const;

export type BillingV1SubscriptionSubscriptionResourceStatusEnum = typeof BillingV1SubscriptionSubscriptionResourceStatusEnum[keyof typeof BillingV1SubscriptionSubscriptionResourceStatusEnum];

/**
 * 
 * @export
 * @interface CommonSchemaPaginationMetaSchema
 */
export interface CommonSchemaPaginationMetaSchema {
    /**
     * 
     * @type {number}
     * @memberof CommonSchemaPaginationMetaSchema
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof CommonSchemaPaginationMetaSchema
     */
    'per_page': number;
    /**
     * 
     * @type {number}
     * @memberof CommonSchemaPaginationMetaSchema
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface CommonSuccessEmptyResource
 */
export interface CommonSuccessEmptyResource {
    /**
     * 
     * @type {string}
     * @memberof CommonSuccessEmptyResource
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DNSV1SnapshotSnapshotResource
 */
export interface DNSV1SnapshotSnapshotResource {
    /**
     * Snapshot ID
     * @type {number}
     * @memberof DNSV1SnapshotSnapshotResource
     */
    'id': number;
    /**
     * Reason of the update
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotResource
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotResource
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface DNSV1SnapshotSnapshotWithContentResource
 */
export interface DNSV1SnapshotSnapshotWithContentResource {
    /**
     * Snapshot ID
     * @type {number}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'id': number;
    /**
     * Reason of the update
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'reason': string;
    /**
     * Array of [`DNS.V1.Zone.RecordResource`](#model/dnsv1zonerecordresource)
     * @type {Array<DNSV1ZoneRecordResource>}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'snapshot': Array<DNSV1ZoneRecordResource>;
    /**
     * 
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneDestroyRequest
 */
export interface DNSV1ZoneDestroyRequest {
    /**
     * Filter records for deletion
     * @type {Array<DNSV1ZoneDestroyRequestFiltersInner>}
     * @memberof DNSV1ZoneDestroyRequest
     */
    'filters': Array<DNSV1ZoneDestroyRequestFiltersInner>;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneDestroyRequestFiltersInner
 */
export interface DNSV1ZoneDestroyRequestFiltersInner {
    /**
     * Name of the record
     * @type {string}
     * @memberof DNSV1ZoneDestroyRequestFiltersInner
     */
    'name': string;
    /**
     * Type of the record
     * @type {string}
     * @memberof DNSV1ZoneDestroyRequestFiltersInner
     */
    'type': DNSV1ZoneDestroyRequestFiltersInnerTypeEnum;
}

export const DNSV1ZoneDestroyRequestFiltersInnerTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Alias: 'ALIAS',
    Mx: 'MX',
    Txt: 'TXT',
    Ns: 'NS',
    Soa: 'SOA',
    Srv: 'SRV',
    Caa: 'CAA'
} as const;

export type DNSV1ZoneDestroyRequestFiltersInnerTypeEnum = typeof DNSV1ZoneDestroyRequestFiltersInnerTypeEnum[keyof typeof DNSV1ZoneDestroyRequestFiltersInnerTypeEnum];

/**
 * 
 * @export
 * @interface DNSV1ZoneNameRecordResource
 */
export interface DNSV1ZoneNameRecordResource {
    /**
     * Content of the name record
     * @type {string}
     * @memberof DNSV1ZoneNameRecordResource
     */
    'content': string;
    /**
     * Flag to mark name record as disabled
     * @type {boolean}
     * @memberof DNSV1ZoneNameRecordResource
     */
    'is_disabled': boolean;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneRecordResource
 */
export interface DNSV1ZoneRecordResource {
    /**
     * Name of the record (use `@` for wildcard name)
     * @type {string}
     * @memberof DNSV1ZoneRecordResource
     */
    'name': string;
    /**
     * Array of [`DNS.V1.Zone.NameRecordResource`](#model/dnsv1zonenamerecordresource)
     * @type {Array<DNSV1ZoneNameRecordResource>}
     * @memberof DNSV1ZoneRecordResource
     */
    'records': Array<DNSV1ZoneNameRecordResource>;
    /**
     * TTL (Time-To-Live) of the record
     * @type {number}
     * @memberof DNSV1ZoneRecordResource
     */
    'ttl': number;
    /**
     * Type of the record
     * @type {string}
     * @memberof DNSV1ZoneRecordResource
     */
    'type': DNSV1ZoneRecordResourceTypeEnum;
}

export const DNSV1ZoneRecordResourceTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Alias: 'ALIAS',
    Mx: 'MX',
    Txt: 'TXT',
    Ns: 'NS',
    Soa: 'SOA',
    Srv: 'SRV',
    Caa: 'CAA'
} as const;

export type DNSV1ZoneRecordResourceTypeEnum = typeof DNSV1ZoneRecordResourceTypeEnum[keyof typeof DNSV1ZoneRecordResourceTypeEnum];

/**
 * 
 * @export
 * @interface DNSV1ZoneResetRequest
 */
export interface DNSV1ZoneResetRequest {
    /**
     * Determines if operation should be run synchronously
     * @type {boolean}
     * @memberof DNSV1ZoneResetRequest
     */
    'sync': boolean;
    /**
     * Determines if email records should be reset
     * @type {boolean}
     * @memberof DNSV1ZoneResetRequest
     */
    'reset_email_records': boolean;
    /**
     * Specifies which record types to not reset
     * @type {Array<string>}
     * @memberof DNSV1ZoneResetRequest
     */
    'whitelisted_record_types': Array<string>;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneUpdateRequest
 */
export interface DNSV1ZoneUpdateRequest {
    /**
     * If `true`, resource records (RRs) matching name and type will be deleted and new RRs will be created, otherwise resource records\' ttl\'s are updated and new records are appended. If no matching RRs are found, they are created.
     * @type {boolean}
     * @memberof DNSV1ZoneUpdateRequest
     */
    'overwrite': boolean;
    /**
     * 
     * @type {Array<DNSV1ZoneUpdateRequestZoneInner>}
     * @memberof DNSV1ZoneUpdateRequest
     */
    'zone': Array<DNSV1ZoneUpdateRequestZoneInner>;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneUpdateRequestZoneInner
 */
export interface DNSV1ZoneUpdateRequestZoneInner {
    /**
     * Name of the record (use `@` for wildcard name)
     * @type {string}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'name': string;
    /**
     * Records assigned to the name
     * @type {Array<DNSV1ZoneUpdateRequestZoneInnerRecordsInner>}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'records': Array<DNSV1ZoneUpdateRequestZoneInnerRecordsInner>;
    /**
     * TTL (Time-To-Live) of the record
     * @type {number}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'ttl': number;
    /**
     * Type of the record
     * @type {string}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'type': DNSV1ZoneUpdateRequestZoneInnerTypeEnum;
}

export const DNSV1ZoneUpdateRequestZoneInnerTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Alias: 'ALIAS',
    Mx: 'MX',
    Txt: 'TXT',
    Ns: 'NS',
    Soa: 'SOA',
    Srv: 'SRV',
    Caa: 'CAA'
} as const;

export type DNSV1ZoneUpdateRequestZoneInnerTypeEnum = typeof DNSV1ZoneUpdateRequestZoneInnerTypeEnum[keyof typeof DNSV1ZoneUpdateRequestZoneInnerTypeEnum];

/**
 * 
 * @export
 * @interface DNSV1ZoneUpdateRequestZoneInnerRecordsInner
 */
export interface DNSV1ZoneUpdateRequestZoneInnerRecordsInner {
    /**
     * Content of the name record
     * @type {string}
     * @memberof DNSV1ZoneUpdateRequestZoneInnerRecordsInner
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface DomainsV1AvailabilityAvailabilityRequest
 */
export interface DomainsV1AvailabilityAvailabilityRequest {
    /**
     * Domain name (without TLD)
     * @type {string}
     * @memberof DomainsV1AvailabilityAvailabilityRequest
     */
    'domain': string;
    /**
     * TLDs list
     * @type {Array<string>}
     * @memberof DomainsV1AvailabilityAvailabilityRequest
     */
    'tlds': Array<string>;
    /**
     * Should response include alternatives
     * @type {boolean}
     * @memberof DomainsV1AvailabilityAvailabilityRequest
     */
    'with_alternatives': boolean;
}
/**
 * 
 * @export
 * @interface DomainsV1AvailabilityAvailabilityResource
 */
export interface DomainsV1AvailabilityAvailabilityResource {
    /**
     * Domain name, `null` when not claimed free domain
     * @type {string}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'domain': string | null;
    /**
     * `true` if domain is available for registration
     * @type {boolean}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'is_available': boolean;
    /**
     * `true` if domain is provided as an alternative
     * @type {boolean}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'is_alternative': boolean;
    /**
     * Special rules and/or restrictions applied for registering TLD
     * @type {string}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'restriction': string | null;
}
/**
 * 
 * @export
 * @interface DomainsV1DomainDomainExtendedResource
 */
export interface DomainsV1DomainDomainExtendedResource {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'domain': string;
    /**
     * Status of the domain
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'status': DomainsV1DomainDomainExtendedResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'message': string | null;
    /**
     * Is privacy protection allowed for the domain
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_privacy_protection_allowed': boolean;
    /**
     * Is privacy protection enabled for the domain
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_privacy_protected': boolean;
    /**
     * Is domain allowed to be locked
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_lockable': boolean;
    /**
     * Is domain locked
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_locked': boolean;
    /**
     * 
     * @type {DomainsV1DomainDomainExtendedResourceNameServers}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'name_servers': DomainsV1DomainDomainExtendedResourceNameServers;
    /**
     * Child name servers
     * @type {Array<Array<string>>}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'child_name_servers': Array<Array<string>>;
    /**
     * 
     * @type {DomainsV1DomainDomainExtendedResourceDomainContacts}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'domain_contacts': DomainsV1DomainDomainExtendedResourceDomainContacts;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    '60_days_lock_expires_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'registered_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'expires_at': string | null;
}

export const DomainsV1DomainDomainExtendedResourceStatusEnum = {
    Active: 'active',
    PendingSetup: 'pending_setup',
    Expired: 'expired',
    Requested: 'requested',
    PendingVerification: 'pending_verification',
    Deleted: 'deleted',
    Suspended: 'suspended',
    Failed: 'failed'
} as const;

export type DomainsV1DomainDomainExtendedResourceStatusEnum = typeof DomainsV1DomainDomainExtendedResourceStatusEnum[keyof typeof DomainsV1DomainDomainExtendedResourceStatusEnum];

/**
 * WHOIS profiles
 * @export
 * @interface DomainsV1DomainDomainExtendedResourceDomainContacts
 */
export interface DomainsV1DomainDomainExtendedResourceDomainContacts {
    /**
     * Admin WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'admin_id': number;
    /**
     * Owner WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'owner_id': number;
    /**
     * Billing WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'billing_id': number;
    /**
     * Technician WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'tech_id': number;
}
/**
 * Name servers
 * @export
 * @interface DomainsV1DomainDomainExtendedResourceNameServers
 */
export interface DomainsV1DomainDomainExtendedResourceNameServers {
    /**
     * Name server 1
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResourceNameServers
     */
    'ns1': string;
    /**
     * Name server 2
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResourceNameServers
     */
    'ns2': string;
}
/**
 * 
 * @export
 * @interface DomainsV1DomainDomainResource
 */
export interface DomainsV1DomainDomainResource {
    /**
     * Domain ID
     * @type {number}
     * @memberof DomainsV1DomainDomainResource
     */
    'id': number;
    /**
     * Domain name, `null` when not claimed free domain
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'domain': string | null;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'type': DomainsV1DomainDomainResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'status': DomainsV1DomainDomainResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'expires_at': string | null;
}

export const DomainsV1DomainDomainResourceTypeEnum = {
    Domain: 'domain',
    FreeDomain: 'free_domain',
    DomainTransfer: 'domain_transfer',
    FreeDomainTransfer: 'free_domain_transfer'
} as const;

export type DomainsV1DomainDomainResourceTypeEnum = typeof DomainsV1DomainDomainResourceTypeEnum[keyof typeof DomainsV1DomainDomainResourceTypeEnum];
export const DomainsV1DomainDomainResourceStatusEnum = {
    Active: 'active',
    PendingSetup: 'pending_setup',
    Expired: 'expired',
    Requested: 'requested',
    PendingVerification: 'pending_verification',
    Deleted: 'deleted',
    Suspended: 'suspended',
    Failed: 'failed'
} as const;

export type DomainsV1DomainDomainResourceStatusEnum = typeof DomainsV1DomainDomainResourceStatusEnum[keyof typeof DomainsV1DomainDomainResourceStatusEnum];

/**
 * 
 * @export
 * @interface DomainsV1ForwardingForwardingResource
 */
export interface DomainsV1ForwardingForwardingResource {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'domain': string | null;
    /**
     * Redirect type
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'redirect_type': DomainsV1ForwardingForwardingResourceRedirectTypeEnum;
    /**
     * URL domain is forwarded to
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'redirect_url': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'updated_at': string | null;
}

export const DomainsV1ForwardingForwardingResourceRedirectTypeEnum = {
    _301: '301',
    _302: '302'
} as const;

export type DomainsV1ForwardingForwardingResourceRedirectTypeEnum = typeof DomainsV1ForwardingForwardingResourceRedirectTypeEnum[keyof typeof DomainsV1ForwardingForwardingResourceRedirectTypeEnum];

/**
 * 
 * @export
 * @interface DomainsV1ForwardingStoreRequest
 */
export interface DomainsV1ForwardingStoreRequest {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1ForwardingStoreRequest
     */
    'domain': string;
    /**
     * Redirect type
     * @type {string}
     * @memberof DomainsV1ForwardingStoreRequest
     */
    'redirect_type': DomainsV1ForwardingStoreRequestRedirectTypeEnum;
    /**
     * URL to forward domain to
     * @type {string}
     * @memberof DomainsV1ForwardingStoreRequest
     */
    'redirect_url': string;
}

export const DomainsV1ForwardingStoreRequestRedirectTypeEnum = {
    _301: '301',
    _302: '302'
} as const;

export type DomainsV1ForwardingStoreRequestRedirectTypeEnum = typeof DomainsV1ForwardingStoreRequestRedirectTypeEnum[keyof typeof DomainsV1ForwardingStoreRequestRedirectTypeEnum];

/**
 * 
 * @export
 * @interface DomainsV1PortfolioPurchaseRequest
 */
export interface DomainsV1PortfolioPurchaseRequest {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'domain': string;
    /**
     * Catalog price item ID
     * @type {string}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'item_id': string;
    /**
     * Payment method ID, default will be used if not provided
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'payment_method_id': number;
    /**
     * 
     * @type {DomainsV1PortfolioPurchaseRequestDomainContacts}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'domain_contacts': DomainsV1PortfolioPurchaseRequestDomainContacts;
    /**
     * Additional registration data, possible values depends on TLD
     * @type {object}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'additional_details': object;
    /**
     * Discount coupon codes
     * @type {Array<any>}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'coupons': Array<any>;
}
/**
 * Domain contact information
 * @export
 * @interface DomainsV1PortfolioPurchaseRequestDomainContacts
 */
export interface DomainsV1PortfolioPurchaseRequestDomainContacts {
    /**
     * Owner contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'owner_id': number;
    /**
     * Administrative contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'admin_id': number;
    /**
     * Billing contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'billing_id': number;
    /**
     * Technical contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'tech_id': number;
}
/**
 * 
 * @export
 * @interface DomainsV1PortfolioUpdateNameserversRequest
 */
export interface DomainsV1PortfolioUpdateNameserversRequest {
    /**
     * First name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns1': string;
    /**
     * Second name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns2': string;
    /**
     * Third name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns3': string;
    /**
     * Fourth name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns4': string;
}
/**
 * 
 * @export
 * @interface DomainsV1WHOISProfileResource
 */
export interface DomainsV1WHOISProfileResource {
    /**
     * WHOIS Profile ID
     * @type {number}
     * @memberof DomainsV1WHOISProfileResource
     */
    'id': number;
    /**
     * TLD to which contact profile can be applied to
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'tld': string;
    /**
     * ISO 3166 2-letter country code
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'country': string;
    /**
     * WHOIS profile entity type
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'entity_type': DomainsV1WHOISProfileResourceEntityTypeEnum;
    /**
     * WHOIS profile details
     * @type {object}
     * @memberof DomainsV1WHOISProfileResource
     */
    'whois_details': object;
    /**
     * TLD details
     * @type {object}
     * @memberof DomainsV1WHOISProfileResource
     */
    'tld_details': object;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'updated_at': string;
}

export const DomainsV1WHOISProfileResourceEntityTypeEnum = {
    Individual: 'individual',
    Organization: 'organization'
} as const;

export type DomainsV1WHOISProfileResourceEntityTypeEnum = typeof DomainsV1WHOISProfileResourceEntityTypeEnum[keyof typeof DomainsV1WHOISProfileResourceEntityTypeEnum];

/**
 * 
 * @export
 * @interface DomainsV1WHOISStoreRequest
 */
export interface DomainsV1WHOISStoreRequest {
    /**
     * TLD of the domain (without leading dot)
     * @type {string}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'tld': string;
    /**
     * ISO 3166 2-letter country code
     * @type {string}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'country': string;
    /**
     * Legal entity type
     * @type {string}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'entity_type': DomainsV1WHOISStoreRequestEntityTypeEnum;
    /**
     * TLD details
     * @type {object}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'tld_details': object;
    /**
     * WHOIS details
     * @type {object}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'whois_details': object;
}

export const DomainsV1WHOISStoreRequestEntityTypeEnum = {
    Individual: 'individual',
    Organization: 'organization'
} as const;

export type DomainsV1WHOISStoreRequestEntityTypeEnum = typeof DomainsV1WHOISStoreRequestEntityTypeEnum[keyof typeof DomainsV1WHOISStoreRequestEntityTypeEnum];

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Message of the error
     * @type {string}
     * @memberof InlineObject
     */
    'message': string;
    /**
     * Request correlation ID
     * @type {string}
     * @memberof InlineObject
     */
    'correlation_id': string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Message of the error
     * @type {string}
     * @memberof InlineObject1
     */
    'message': string;
    /**
     * Request correlation ID
     * @type {string}
     * @memberof InlineObject1
     */
    'correlation_id': string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * Validation error message
     * @type {string}
     * @memberof InlineObject2
     */
    'message': string;
    /**
     * 
     * @type {InlineObject2Errors}
     * @memberof InlineObject2
     */
    'errors': InlineObject2Errors;
    /**
     * Request correlation ID
     * @type {string}
     * @memberof InlineObject2
     */
    'correlation_id': string;
}
/**
 * Object of detailed errors for each field
 * @export
 * @interface InlineObject2Errors
 */
export interface InlineObject2Errors {
    /**
     * 
     * @type {Array<any>}
     * @memberof InlineObject2Errors
     */
    'field_1': Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof InlineObject2Errors
     */
    'field_2': Array<any>;
}
/**
 * 
 * @export
 * @interface VPSGetActionsV1200Response
 */
export interface VPSGetActionsV1200Response {
    /**
     * Array of [`VPS.V1.Action.ActionResource`](#model/vpsv1actionactionresource)
     * @type {Array<VPSV1ActionActionResource>}
     * @memberof VPSGetActionsV1200Response
     */
    'data': Array<VPSV1ActionActionResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetActionsV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetBackupsV1200Response
 */
export interface VPSGetBackupsV1200Response {
    /**
     * Array of [`VPS.V1.Backup.BackupResource`](#model/vpsv1backupbackupresource)
     * @type {Array<VPSV1BackupBackupResource>}
     * @memberof VPSGetBackupsV1200Response
     */
    'data': Array<VPSV1BackupBackupResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetBackupsV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetFirewallListV1200Response
 */
export interface VPSGetFirewallListV1200Response {
    /**
     * Array of [`VPS.V1.Firewall.FirewallResource`](#model/vpsv1firewallfirewallresource)
     * @type {Array<VPSV1FirewallFirewallResource>}
     * @memberof VPSGetFirewallListV1200Response
     */
    'data': Array<VPSV1FirewallFirewallResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetFirewallListV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetPostInstallScriptsV1200Response
 */
export interface VPSGetPostInstallScriptsV1200Response {
    /**
     * Array of [`VPS.V1.PostInstallScript.PostInstallScriptResource`](#model/vpsv1postinstallscriptpostinstallscriptresource)
     * @type {Array<VPSV1PostInstallScriptPostInstallScriptResource>}
     * @memberof VPSGetPostInstallScriptsV1200Response
     */
    'data': Array<VPSV1PostInstallScriptPostInstallScriptResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetPostInstallScriptsV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetPublicKeysV1200Response
 */
export interface VPSGetPublicKeysV1200Response {
    /**
     * Array of [`VPS.V1.PublicKey.PublicKeyResource`](#model/vpsv1publickeypublickeyresource)
     * @type {Array<VPSV1PublicKeyPublicKeyResource>}
     * @memberof VPSGetPublicKeysV1200Response
     */
    'data': Array<VPSV1PublicKeyPublicKeyResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetPublicKeysV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSV1ActionActionResource
 */
export interface VPSV1ActionActionResource {
    /**
     * Action ID
     * @type {number}
     * @memberof VPSV1ActionActionResource
     */
    'id': number;
    /**
     * Action name
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'name': string;
    /**
     * Action state
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'state': VPSV1ActionActionResourceStateEnum;
    /**
     * 
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'updated_at': string;
}

export const VPSV1ActionActionResourceStateEnum = {
    Success: 'success',
    Error: 'error',
    Delayed: 'delayed',
    Sent: 'sent',
    Created: 'created'
} as const;

export type VPSV1ActionActionResourceStateEnum = typeof VPSV1ActionActionResourceStateEnum[keyof typeof VPSV1ActionActionResourceStateEnum];

/**
 * 
 * @export
 * @interface VPSV1BackupBackupResource
 */
export interface VPSV1BackupBackupResource {
    /**
     * Backup ID
     * @type {number}
     * @memberof VPSV1BackupBackupResource
     */
    'id': number;
    /**
     * Location of the backup
     * @type {string}
     * @memberof VPSV1BackupBackupResource
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1BackupBackupResource
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1DataCenterDataCenterResource
 */
export interface VPSV1DataCenterDataCenterResource {
    /**
     * Data center ID
     * @type {number}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'id': number;
    /**
     * Data center name
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'name': string | null;
    /**
     * Data center location country (two letter code)
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'location': string | null;
    /**
     * Data center location city
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'city': string | null;
    /**
     * Data center location continent
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'continent': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1DockerManagerContainerPortResource
 */
export interface VPSV1DockerManagerContainerPortResource {
    /**
     * Port mapping type - published (accessible from host), exposed (only internal), or range variants
     * @type {string}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'type': VPSV1DockerManagerContainerPortResourceTypeEnum;
    /**
     * Network protocol used for communication
     * @type {string}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'protocol': VPSV1DockerManagerContainerPortResourceProtocolEnum;
    /**
     * IP address on host where port is bound (null for exposed-only ports)
     * @type {string}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'host_ip': string | null;
    /**
     * Port number on host machine (null for exposed-only or range ports)
     * @type {number}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'host_port': number | null;
    /**
     * Port number inside container (null for range ports)
     * @type {number}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'container_port': number | null;
    /**
     * Starting port number in host port range (null for single ports)
     * @type {number}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'host_port_start': number | null;
    /**
     * Ending port number in host port range (null for single ports)
     * @type {number}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'host_port_end': number | null;
    /**
     * Starting port number in container port range (null for single ports)
     * @type {number}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'container_port_start': number | null;
    /**
     * Ending port number in container port range (null for single ports)
     * @type {number}
     * @memberof VPSV1DockerManagerContainerPortResource
     */
    'container_port_end': number | null;
}

export const VPSV1DockerManagerContainerPortResourceTypeEnum = {
    Published: 'published',
    PublishedRange: 'published_range',
    Exposed: 'exposed',
    ExposedRange: 'exposed_range'
} as const;

export type VPSV1DockerManagerContainerPortResourceTypeEnum = typeof VPSV1DockerManagerContainerPortResourceTypeEnum[keyof typeof VPSV1DockerManagerContainerPortResourceTypeEnum];
export const VPSV1DockerManagerContainerPortResourceProtocolEnum = {
    Tcp: 'tcp',
    Udp: 'udp'
} as const;

export type VPSV1DockerManagerContainerPortResourceProtocolEnum = typeof VPSV1DockerManagerContainerPortResourceProtocolEnum[keyof typeof VPSV1DockerManagerContainerPortResourceProtocolEnum];

/**
 * 
 * @export
 * @interface VPSV1DockerManagerContainerResource
 */
export interface VPSV1DockerManagerContainerResource {
    /**
     * Unique container identifier (short form of Docker container ID)
     * @type {string}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'id': string;
    /**
     * Container name as defined in docker-compose or assigned by Docker
     * @type {string}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'name': string;
    /**
     * Docker image name and tag used to create this container
     * @type {string}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'image': string;
    /**
     * Command being executed inside the container (may be truncated with ...)
     * @type {string}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'command': string;
    /**
     * Human-readable container status including uptime, exit codes, or error information
     * @type {string}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'status': string;
    /**
     * Programmatic container lifecycle state for automated processing
     * @type {string}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'state': VPSV1DockerManagerContainerResourceStateEnum;
    /**
     * Array of [`VPS.V1.DockerManager.ContainerPortResource`](#model/vpsv1dockermanagercontainerportresource)
     * @type {Array<VPSV1DockerManagerContainerPortResource>}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'ports': Array<VPSV1DockerManagerContainerPortResource>;
    /**
     * 
     * @type {VPSV1DockerManagerContainerStatsResource}
     * @memberof VPSV1DockerManagerContainerResource
     */
    'stats': VPSV1DockerManagerContainerStatsResource | null;
}

export const VPSV1DockerManagerContainerResourceStateEnum = {
    Created: 'created',
    Running: 'running',
    Restarting: 'restarting',
    Exited: 'exited',
    Paused: 'paused',
    Dead: 'dead',
    Stopping: 'stopping'
} as const;

export type VPSV1DockerManagerContainerResourceStateEnum = typeof VPSV1DockerManagerContainerResourceStateEnum[keyof typeof VPSV1DockerManagerContainerResourceStateEnum];

/**
 * 
 * @export
 * @interface VPSV1DockerManagerContainerStatsResource
 */
export interface VPSV1DockerManagerContainerStatsResource {
    /**
     * CPU usage in percentage
     * @type {number}
     * @memberof VPSV1DockerManagerContainerStatsResource
     */
    'cpu_percentage': number;
    /**
     * Memory usage in percentage
     * @type {number}
     * @memberof VPSV1DockerManagerContainerStatsResource
     */
    'memory_percentage': number;
    /**
     * Used memory in bytes
     * @type {number}
     * @memberof VPSV1DockerManagerContainerStatsResource
     */
    'memory_used': number;
    /**
     * Total available memory in bytes
     * @type {number}
     * @memberof VPSV1DockerManagerContainerStatsResource
     */
    'memory_total': number;
    /**
     * Inbound network traffic in bytes
     * @type {number}
     * @memberof VPSV1DockerManagerContainerStatsResource
     */
    'net_in': number;
    /**
     * Outbound network traffic in bytes
     * @type {number}
     * @memberof VPSV1DockerManagerContainerStatsResource
     */
    'net_out': number;
}
/**
 * 
 * @export
 * @interface VPSV1DockerManagerContentResource
 */
export interface VPSV1DockerManagerContentResource {
    /**
     * Contents of docker-compose file
     * @type {string}
     * @memberof VPSV1DockerManagerContentResource
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface VPSV1DockerManagerLogEntryResource
 */
export interface VPSV1DockerManagerLogEntryResource {
    /**
     * ISO 8601 formatted timestamp when the log entry was generated by the container
     * @type {string}
     * @memberof VPSV1DockerManagerLogEntryResource
     */
    'timestamp': string;
    /**
     * Raw log message content as output by the application inside the container
     * @type {string}
     * @memberof VPSV1DockerManagerLogEntryResource
     */
    'line': string;
}
/**
 * 
 * @export
 * @interface VPSV1DockerManagerLogsResource
 */
export interface VPSV1DockerManagerLogsResource {
    /**
     * Name of the Docker Compose service that generated these log entries
     * @type {string}
     * @memberof VPSV1DockerManagerLogsResource
     */
    'service': string;
    /**
     * Array of [`VPS.V1.DockerManager.LogEntryResource`](#model/vpsv1dockermanagerlogentryresource)
     * @type {Array<VPSV1DockerManagerLogEntryResource>}
     * @memberof VPSV1DockerManagerLogsResource
     */
    'entries': Array<VPSV1DockerManagerLogEntryResource>;
}
/**
 * 
 * @export
 * @interface VPSV1DockerManagerProjectResource
 */
export interface VPSV1DockerManagerProjectResource {
    /**
     * Docker Compose project name (derived from directory name or compose file)
     * @type {string}
     * @memberof VPSV1DockerManagerProjectResource
     */
    'name': string;
    /**
     * Raw output from docker compose ps command showing service count and states
     * @type {string}
     * @memberof VPSV1DockerManagerProjectResource
     */
    'status': string;
    /**
     * Derived project state parsed from the raw docker compose status
     * @type {string}
     * @memberof VPSV1DockerManagerProjectResource
     */
    'state': VPSV1DockerManagerProjectResourceStateEnum;
    /**
     * Full filesystem path to the docker-compose.yml file
     * @type {string}
     * @memberof VPSV1DockerManagerProjectResource
     */
    'path': string;
}

export const VPSV1DockerManagerProjectResourceStateEnum = {
    Running: 'running',
    Stopped: 'stopped',
    Created: 'created',
    Mixed: 'mixed',
    Unknown: 'unknown'
} as const;

export type VPSV1DockerManagerProjectResourceStateEnum = typeof VPSV1DockerManagerProjectResourceStateEnum[keyof typeof VPSV1DockerManagerProjectResourceStateEnum];

/**
 * 
 * @export
 * @interface VPSV1FirewallFirewallResource
 */
export interface VPSV1FirewallFirewallResource {
    /**
     * Firewall ID
     * @type {number}
     * @memberof VPSV1FirewallFirewallResource
     */
    'id': number;
    /**
     * Firewall name
     * @type {string}
     * @memberof VPSV1FirewallFirewallResource
     */
    'name': string;
    /**
     * Is current firewall synced with VPS
     * @type {boolean}
     * @memberof VPSV1FirewallFirewallResource
     */
    'is_synced': boolean;
    /**
     * Array of [`VPS.V1.Firewall.FirewallRuleResource`](#model/vpsv1firewallfirewallruleresource)
     * @type {Array<VPSV1FirewallFirewallRuleResource>}
     * @memberof VPSV1FirewallFirewallResource
     */
    'rules': Array<VPSV1FirewallFirewallRuleResource>;
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallFirewallResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallFirewallResource
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1FirewallFirewallRuleResource
 */
export interface VPSV1FirewallFirewallRuleResource {
    /**
     * Firewall rule ID
     * @type {number}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'id': number;
    /**
     * Firewall rule action
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'action': VPSV1FirewallFirewallRuleResourceActionEnum;
    /**
     * Firewall rule protocol
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'protocol': VPSV1FirewallFirewallRuleResourceProtocolEnum;
    /**
     * Firewall rule destination port: single or port range
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'port': string;
    /**
     * Firewall rule source. Can be `any` or `custom`
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'source': string;
    /**
     * Firewall rule source detail. Can be `any` or IP address, CIDR or range
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'source_detail': string;
}

export const VPSV1FirewallFirewallRuleResourceActionEnum = {
    Accept: 'accept',
    Drop: 'drop'
} as const;

export type VPSV1FirewallFirewallRuleResourceActionEnum = typeof VPSV1FirewallFirewallRuleResourceActionEnum[keyof typeof VPSV1FirewallFirewallRuleResourceActionEnum];
export const VPSV1FirewallFirewallRuleResourceProtocolEnum = {
    Tcp: 'TCP',
    Udp: 'UDP',
    Icmp: 'ICMP',
    Gre: 'GRE',
    Any: 'any',
    Esp: 'ESP',
    Ah: 'AH',
    Icmpv6: 'ICMPv6',
    Ssh: 'SSH',
    Http: 'HTTP',
    Https: 'HTTPS',
    MySql: 'MySQL',
    PostgreSql: 'PostgreSQL'
} as const;

export type VPSV1FirewallFirewallRuleResourceProtocolEnum = typeof VPSV1FirewallFirewallRuleResourceProtocolEnum[keyof typeof VPSV1FirewallFirewallRuleResourceProtocolEnum];

/**
 * 
 * @export
 * @interface VPSV1FirewallRulesStoreRequest
 */
export interface VPSV1FirewallRulesStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'protocol': VPSV1FirewallRulesStoreRequestProtocolEnum;
    /**
     * Port or port range, ex: 1024:2048
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'port': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'source': VPSV1FirewallRulesStoreRequestSourceEnum;
    /**
     * IP range, CIDR, single IP or `any`
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'source_detail': string;
}

export const VPSV1FirewallRulesStoreRequestProtocolEnum = {
    Tcp: 'TCP',
    Udp: 'UDP',
    Icmp: 'ICMP',
    Gre: 'GRE',
    Any: 'any',
    Esp: 'ESP',
    Ah: 'AH',
    Icmpv6: 'ICMPv6',
    Ssh: 'SSH',
    Http: 'HTTP',
    Https: 'HTTPS',
    MySql: 'MySQL',
    PostgreSql: 'PostgreSQL'
} as const;

export type VPSV1FirewallRulesStoreRequestProtocolEnum = typeof VPSV1FirewallRulesStoreRequestProtocolEnum[keyof typeof VPSV1FirewallRulesStoreRequestProtocolEnum];
export const VPSV1FirewallRulesStoreRequestSourceEnum = {
    Any: 'any',
    Custom: 'custom'
} as const;

export type VPSV1FirewallRulesStoreRequestSourceEnum = typeof VPSV1FirewallRulesStoreRequestSourceEnum[keyof typeof VPSV1FirewallRulesStoreRequestSourceEnum];

/**
 * 
 * @export
 * @interface VPSV1FirewallStoreRequest
 */
export interface VPSV1FirewallStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallStoreRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface VPSV1IPAddressIPAddressResource
 */
export interface VPSV1IPAddressIPAddressResource {
    /**
     * IP address ID
     * @type {number}
     * @memberof VPSV1IPAddressIPAddressResource
     */
    'id': number;
    /**
     * IP address: IPv4 or IPv6
     * @type {string}
     * @memberof VPSV1IPAddressIPAddressResource
     */
    'address': string;
    /**
     * IP address PTR record
     * @type {string}
     * @memberof VPSV1IPAddressIPAddressResource
     */
    'ptr': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1MalwareMetricsResource
 */
export interface VPSV1MalwareMetricsResource {
    /**
     * Records found during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'records': number;
    /**
     * Malicious files found during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'malicious': number;
    /**
     * Compromised files found during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'compromised': number;
    /**
     * Total number of files scanned during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'scanned_files': number;
    /**
     * 
     * @type {string}
     * @memberof VPSV1MalwareMetricsResource
     */
    'scan_started_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1MalwareMetricsResource
     */
    'scan_ended_at': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1MetricsMetricsCollection
 */
export interface VPSV1MetricsMetricsCollection {
    /**
     * 
     * @type {VPSV1MetricsMetricsResource}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'cpu_usage': VPSV1MetricsMetricsResource | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsResource}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'ram_usage': VPSV1MetricsMetricsResource | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsResource}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'disk_space': VPSV1MetricsMetricsResource | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsResource}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'outgoing_traffic': VPSV1MetricsMetricsResource | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsResource}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'incoming_traffic': VPSV1MetricsMetricsResource | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsResource}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'uptime': VPSV1MetricsMetricsResource | null;
}
/**
 * 
 * @export
 * @interface VPSV1MetricsMetricsResource
 */
export interface VPSV1MetricsMetricsResource {
    /**
     * Measurement unit
     * @type {string}
     * @memberof VPSV1MetricsMetricsResource
     */
    'unit': string;
    /**
     * Object, containing UNIX timestamps as a key and measurement as a value.
     * @type {object}
     * @memberof VPSV1MetricsMetricsResource
     */
    'usage': object;
}
/**
 * 
 * @export
 * @interface VPSV1PostInstallScriptPostInstallScriptResource
 */
export interface VPSV1PostInstallScriptPostInstallScriptResource {
    /**
     * Post-install script ID
     * @type {number}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'id': number;
    /**
     * Name of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'name': string;
    /**
     * Content of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1PostInstallScriptStoreRequest
 */
export interface VPSV1PostInstallScriptStoreRequest {
    /**
     * Name of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptStoreRequest
     */
    'name': string;
    /**
     * Content of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptStoreRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface VPSV1PublicKeyAttachRequest
 */
export interface VPSV1PublicKeyAttachRequest {
    /**
     * Public Key IDs to attach
     * @type {Array<number>}
     * @memberof VPSV1PublicKeyAttachRequest
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface VPSV1PublicKeyPublicKeyResource
 */
export interface VPSV1PublicKeyPublicKeyResource {
    /**
     * Public key ID
     * @type {number}
     * @memberof VPSV1PublicKeyPublicKeyResource
     */
    'id': number;
    /**
     * Public key name
     * @type {string}
     * @memberof VPSV1PublicKeyPublicKeyResource
     */
    'name': string;
    /**
     * Public key content
     * @type {string}
     * @memberof VPSV1PublicKeyPublicKeyResource
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface VPSV1PublicKeyStoreRequest
 */
export interface VPSV1PublicKeyStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1PublicKeyStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1PublicKeyStoreRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface VPSV1SnapshotSnapshotResource
 */
export interface VPSV1SnapshotSnapshotResource {
    /**
     * Snapshot ID
     * @type {number}
     * @memberof VPSV1SnapshotSnapshotResource
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VPSV1SnapshotSnapshotResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1SnapshotSnapshotResource
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1TemplateTemplateResource
 */
export interface VPSV1TemplateTemplateResource {
    /**
     * Template ID
     * @type {number}
     * @memberof VPSV1TemplateTemplateResource
     */
    'id': number;
    /**
     * Template name
     * @type {string}
     * @memberof VPSV1TemplateTemplateResource
     */
    'name': string;
    /**
     * Template description
     * @type {string}
     * @memberof VPSV1TemplateTemplateResource
     */
    'description': string;
    /**
     * Link to official OS documentation
     * @type {string}
     * @memberof VPSV1TemplateTemplateResource
     */
    'documentation': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineDockerManagerUpRequest
 */
export interface VPSV1VirtualMachineDockerManagerUpRequest {
    /**
     * Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @type {string}
     * @memberof VPSV1VirtualMachineDockerManagerUpRequest
     */
    'project_name': string;
    /**
     * URL pointing to docker-compose.yaml file, Github repository or raw YAML content of the compose file
     * @type {string}
     * @memberof VPSV1VirtualMachineDockerManagerUpRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineHostnameUpdateRequest
 */
export interface VPSV1VirtualMachineHostnameUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineHostnameUpdateRequest
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineMetricGetRequest
 */
export interface VPSV1VirtualMachineMetricGetRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineMetricGetRequest
     */
    'date_from': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineMetricGetRequest
     */
    'date_to': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineNameserversUpdateRequest
 */
export interface VPSV1VirtualMachineNameserversUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineNameserversUpdateRequest
     */
    'ns1': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineNameserversUpdateRequest
     */
    'ns2': string | null;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineNameserversUpdateRequest
     */
    'ns3': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachinePTRStoreRequest
 */
export interface VPSV1VirtualMachinePTRStoreRequest {
    /**
     * Pointer record domain
     * @type {string}
     * @memberof VPSV1VirtualMachinePTRStoreRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachinePanelPasswordUpdateRequest
 */
export interface VPSV1VirtualMachinePanelPasswordUpdateRequest {
    /**
     * Panel password for the virtual machine
     * @type {string}
     * @memberof VPSV1VirtualMachinePanelPasswordUpdateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachinePurchaseRequest
 */
export interface VPSV1VirtualMachinePurchaseRequest {
    /**
     * Catalog price item ID
     * @type {string}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'item_id': string;
    /**
     * Payment method ID, default will be used if not provided
     * @type {number}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'payment_method_id': number;
    /**
     * 
     * @type {VPSV1VirtualMachineSetupRequest}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'setup': VPSV1VirtualMachineSetupRequest;
    /**
     * Discount coupon codes
     * @type {Array<any>}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'coupons': Array<any>;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineRecoveryStartRequest
 */
export interface VPSV1VirtualMachineRecoveryStartRequest {
    /**
     * Temporary root password for recovery mode
     * @type {string}
     * @memberof VPSV1VirtualMachineRecoveryStartRequest
     */
    'root_password': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineRecreateRequest
 */
export interface VPSV1VirtualMachineRecreateRequest {
    /**
     * Template ID
     * @type {number}
     * @memberof VPSV1VirtualMachineRecreateRequest
     */
    'template_id': number;
    /**
     * Root password for the virtual machine. If not provided, random password will be generated. Password will not be shown in the response.
     * @type {string}
     * @memberof VPSV1VirtualMachineRecreateRequest
     */
    'password': string;
    /**
     * Panel password for the panel-based OS template. If not provided, random password will be generated. If OS does not support panel_password this field will be ignored. Password will not be shown in the response.
     * @type {string}
     * @memberof VPSV1VirtualMachineRecreateRequest
     */
    'panel_password': string;
    /**
     * Post-install script to execute after virtual machine was recreated
     * @type {number}
     * @memberof VPSV1VirtualMachineRecreateRequest
     */
    'post_install_script_id': number;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineRootPasswordUpdateRequest
 */
export interface VPSV1VirtualMachineRootPasswordUpdateRequest {
    /**
     * Root password for the virtual machine
     * @type {string}
     * @memberof VPSV1VirtualMachineRootPasswordUpdateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineSetupRequest
 */
export interface VPSV1VirtualMachineSetupRequest {
    /**
     * Template ID
     * @type {number}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'template_id': number;
    /**
     * Data center ID
     * @type {number}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'data_center_id': number;
    /**
     * Post-install script ID
     * @type {number}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'post_install_script_id': number;
    /**
     * Password for the virtual machine. If not provided, random password will be generated. Password will not be shown in the response.
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'password': string;
    /**
     * Override default hostname of the virtual machine
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'hostname': string;
    /**
     * Install Monarx malware scanner (if supported)
     * @type {boolean}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'install_monarx': boolean;
    /**
     * Enable weekly backup schedule
     * @type {boolean}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'enable_backups': boolean;
    /**
     * Name server 1
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'ns1': string;
    /**
     * Name server 2
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'ns2': string;
    /**
     * 
     * @type {VPSV1VirtualMachineSetupRequestPublicKey}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'public_key': VPSV1VirtualMachineSetupRequestPublicKey;
}
/**
 * Use SSH key
 * @export
 * @interface VPSV1VirtualMachineSetupRequestPublicKey
 */
export interface VPSV1VirtualMachineSetupRequestPublicKey {
    /**
     * Name of the SSH key
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequestPublicKey
     */
    'name': string;
    /**
     * Contents of the SSH key
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequestPublicKey
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineVirtualMachineResource
 */
export interface VPSV1VirtualMachineVirtualMachineResource {
    /**
     * Virtual machine ID
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'id': number;
    /**
     * Active firewall ID, `null` if disabled
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'firewall_group_id': number | null;
    /**
     * Subscription ID
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'subscription_id': string | null;
    /**
     * VPS plan name
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'plan': string | null;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'state': VPSV1VirtualMachineVirtualMachineResourceStateEnum;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'actions_lock': VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum;
    /**
     * CPUs count assigned to virtual machine
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'cpus': number;
    /**
     * Memory available to virtual machine (in megabytes)
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'memory': number;
    /**
     * Virtual machine disk size (in megabytes)
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'disk': number;
    /**
     * Monthly internet traffic available to virtual machine (in megabytes)
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'bandwidth': number;
    /**
     * Primary DNS resolver
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ns1': string | null;
    /**
     * Secondary DNS resolver
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ns2': string | null;
    /**
     * Array of [`VPS.V1.IPAddress.IPAddressResource`](#model/vpsv1ipaddressipaddressresource)
     * @type {Array<VPSV1IPAddressIPAddressResource>}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ipv4': Array<VPSV1IPAddressIPAddressResource>;
    /**
     * Array of [`VPS.V1.IPAddress.IPAddressResource`](#model/vpsv1ipaddressipaddressresource)
     * @type {Array<VPSV1IPAddressIPAddressResource>}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ipv6': Array<VPSV1IPAddressIPAddressResource>;
    /**
     * 
     * @type {VPSV1TemplateTemplateResource}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'template': VPSV1TemplateTemplateResource | null;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'created_at': string;
}

export const VPSV1VirtualMachineVirtualMachineResourceStateEnum = {
    Running: 'running',
    Starting: 'starting',
    Stopping: 'stopping',
    Stopped: 'stopped',
    Creating: 'creating',
    Initial: 'initial',
    Error: 'error',
    Suspending: 'suspending',
    Unsuspending: 'unsuspending',
    Suspended: 'suspended',
    Destroying: 'destroying',
    Destroyed: 'destroyed',
    Recreating: 'recreating',
    Restoring: 'restoring',
    Recovery: 'recovery',
    StoppingRecovery: 'stopping_recovery'
} as const;

export type VPSV1VirtualMachineVirtualMachineResourceStateEnum = typeof VPSV1VirtualMachineVirtualMachineResourceStateEnum[keyof typeof VPSV1VirtualMachineVirtualMachineResourceStateEnum];
export const VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum = {
    Unlocked: 'unlocked',
    Locked: 'locked'
} as const;

export type VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum = typeof VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum[keyof typeof VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum];


/**
 * BillingCatalogApi - axios parameter creator
 * @export
 */
export const BillingCatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve catalog items available for order.  Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.  Use this endpoint to view available services and pricing before placing orders.
         * @summary Get catalog item list
         * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
         * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogItemListV1: async (category?: GetCatalogItemListV1CategoryEnum, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/v1/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingCatalogApi - functional programming interface
 * @export
 */
export const BillingCatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingCatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve catalog items available for order.  Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.  Use this endpoint to view available services and pricing before placing orders.
         * @summary Get catalog item list
         * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
         * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogItemListV1(category?: GetCatalogItemListV1CategoryEnum, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingV1CatalogCatalogItemResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogItemListV1(category, name, options);
            const localVarOperationServerBasePath = operationServerMap['BillingCatalogApi.getCatalogItemListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingCatalogApi - factory interface
 * @export
 */
export const BillingCatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingCatalogApiFp(configuration)
    return {
        /**
         * Retrieve catalog items available for order.  Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.  Use this endpoint to view available services and pricing before placing orders.
         * @summary Get catalog item list
         * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
         * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogItemListV1(category?: GetCatalogItemListV1CategoryEnum, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BillingV1CatalogCatalogItemResource>> {
            return localVarFp.getCatalogItemListV1(category, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingCatalogApi - object-oriented interface
 * @export
 * @class BillingCatalogApi
 * @extends {BaseAPI}
 */
export class BillingCatalogApi extends BaseAPI {
    /**
     * Retrieve catalog items available for order.  Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.  Use this endpoint to view available services and pricing before placing orders.
     * @summary Get catalog item list
     * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
     * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingCatalogApi
     */
    public getCatalogItemListV1(category?: GetCatalogItemListV1CategoryEnum, name?: string, options?: RawAxiosRequestConfig) {
        return BillingCatalogApiFp(this.configuration).getCatalogItemListV1(category, name, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCatalogItemListV1CategoryEnum = {
    Domain: 'DOMAIN',
    Vps: 'VPS'
} as const;
export type GetCatalogItemListV1CategoryEnum = typeof GetCatalogItemListV1CategoryEnum[keyof typeof GetCatalogItemListV1CategoryEnum];


/**
 * BillingOrdersApi - axios parameter creator
 * @export
 */
export const BillingOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
         * @summary Create service order
         * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createServiceOrderV1: async (billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billingV1OrderStoreRequest' is not null or undefined
            assertParamExists('createServiceOrderV1', 'billingV1OrderStoreRequest', billingV1OrderStoreRequest)
            const localVarPath = `/api/billing/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingV1OrderStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingOrdersApi - functional programming interface
 * @export
 */
export const BillingOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
         * @summary Create service order
         * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createServiceOrderV1(billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingV1OrderOrderResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceOrderV1(billingV1OrderStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['BillingOrdersApi.createServiceOrderV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingOrdersApi - factory interface
 * @export
 */
export const BillingOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingOrdersApiFp(configuration)
    return {
        /**
         * Create a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
         * @summary Create service order
         * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createServiceOrderV1(billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingV1OrderOrderResource> {
            return localVarFp.createServiceOrderV1(billingV1OrderStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingOrdersApi - object-oriented interface
 * @export
 * @class BillingOrdersApi
 * @extends {BaseAPI}
 */
export class BillingOrdersApi extends BaseAPI {
    /**
     * Create a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
     * @summary Create service order
     * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof BillingOrdersApi
     */
    public createServiceOrderV1(billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options?: RawAxiosRequestConfig) {
        return BillingOrdersApiFp(this.configuration).createServiceOrderV1(billingV1OrderStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingPaymentMethodsApi - axios parameter creator
 * @export
 */
export const BillingPaymentMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a payment method from your account.  Use this endpoint to remove unused payment methods from user accounts.
         * @summary Delete payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodV1: async (paymentMethodId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('deletePaymentMethodV1', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/api/billing/v1/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).  Use this endpoint to view available payment options before creating orders.
         * @summary Get payment method list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/v1/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the default payment method for your account.  Use this endpoint to configure the primary payment method for future orders.
         * @summary Set default payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodV1: async (paymentMethodId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('setDefaultPaymentMethodV1', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/api/billing/v1/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingPaymentMethodsApi - functional programming interface
 * @export
 */
export const BillingPaymentMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingPaymentMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a payment method from your account.  Use this endpoint to remove unused payment methods from user accounts.
         * @summary Delete payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentMethodV1(paymentMethodId, options);
            const localVarOperationServerBasePath = operationServerMap['BillingPaymentMethodsApi.deletePaymentMethodV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).  Use this endpoint to view available payment options before creating orders.
         * @summary Get payment method list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingV1PaymentMethodPaymentMethodResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodListV1(options);
            const localVarOperationServerBasePath = operationServerMap['BillingPaymentMethodsApi.getPaymentMethodListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set the default payment method for your account.  Use this endpoint to configure the primary payment method for future orders.
         * @summary Set default payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethodV1(paymentMethodId, options);
            const localVarOperationServerBasePath = operationServerMap['BillingPaymentMethodsApi.setDefaultPaymentMethodV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingPaymentMethodsApi - factory interface
 * @export
 */
export const BillingPaymentMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingPaymentMethodsApiFp(configuration)
    return {
        /**
         * Delete a payment method from your account.  Use this endpoint to remove unused payment methods from user accounts.
         * @summary Delete payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deletePaymentMethodV1(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).  Use this endpoint to view available payment options before creating orders.
         * @summary Get payment method list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<BillingV1PaymentMethodPaymentMethodResource>> {
            return localVarFp.getPaymentMethodListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Set the default payment method for your account.  Use this endpoint to configure the primary payment method for future orders.
         * @summary Set default payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.setDefaultPaymentMethodV1(paymentMethodId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingPaymentMethodsApi - object-oriented interface
 * @export
 * @class BillingPaymentMethodsApi
 * @extends {BaseAPI}
 */
export class BillingPaymentMethodsApi extends BaseAPI {
    /**
     * Delete a payment method from your account.  Use this endpoint to remove unused payment methods from user accounts.
     * @summary Delete payment method
     * @param {number} paymentMethodId Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPaymentMethodsApi
     */
    public deletePaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig) {
        return BillingPaymentMethodsApiFp(this.configuration).deletePaymentMethodV1(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).  Use this endpoint to view available payment options before creating orders.
     * @summary Get payment method list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPaymentMethodsApi
     */
    public getPaymentMethodListV1(options?: RawAxiosRequestConfig) {
        return BillingPaymentMethodsApiFp(this.configuration).getPaymentMethodListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the default payment method for your account.  Use this endpoint to configure the primary payment method for future orders.
     * @summary Set default payment method
     * @param {number} paymentMethodId Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPaymentMethodsApi
     */
    public setDefaultPaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig) {
        return BillingPaymentMethodsApiFp(this.configuration).setDefaultPaymentMethodV1(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingSubscriptionsApi - axios parameter creator
 * @export
 */
export const BillingSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a subscription and stop any further billing.  Use this endpoint when users want to terminate active services.
         * @summary Cancel subscription
         * @param {string} subscriptionId Subscription ID
         * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionV1: async (subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('cancelSubscriptionV1', 'subscriptionId', subscriptionId)
            // verify required parameter 'billingV1SubscriptionCancelRequest' is not null or undefined
            assertParamExists('cancelSubscriptionV1', 'billingV1SubscriptionCancelRequest', billingV1SubscriptionCancelRequest)
            const localVarPath = `/api/billing/v1/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingV1SubscriptionCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all subscriptions associated with your account.  Use this endpoint to monitor active services and billing status.
         * @summary Get subscription list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/v1/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingSubscriptionsApi - functional programming interface
 * @export
 */
export const BillingSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a subscription and stop any further billing.  Use this endpoint when users want to terminate active services.
         * @summary Cancel subscription
         * @param {string} subscriptionId Subscription ID
         * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscriptionV1(subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscriptionV1(subscriptionId, billingV1SubscriptionCancelRequest, options);
            const localVarOperationServerBasePath = operationServerMap['BillingSubscriptionsApi.cancelSubscriptionV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all subscriptions associated with your account.  Use this endpoint to monitor active services and billing status.
         * @summary Get subscription list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingV1SubscriptionSubscriptionResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionListV1(options);
            const localVarOperationServerBasePath = operationServerMap['BillingSubscriptionsApi.getSubscriptionListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingSubscriptionsApi - factory interface
 * @export
 */
export const BillingSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingSubscriptionsApiFp(configuration)
    return {
        /**
         * Cancel a subscription and stop any further billing.  Use this endpoint when users want to terminate active services.
         * @summary Cancel subscription
         * @param {string} subscriptionId Subscription ID
         * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionV1(subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.cancelSubscriptionV1(subscriptionId, billingV1SubscriptionCancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all subscriptions associated with your account.  Use this endpoint to monitor active services and billing status.
         * @summary Get subscription list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<BillingV1SubscriptionSubscriptionResource>> {
            return localVarFp.getSubscriptionListV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingSubscriptionsApi - object-oriented interface
 * @export
 * @class BillingSubscriptionsApi
 * @extends {BaseAPI}
 */
export class BillingSubscriptionsApi extends BaseAPI {
    /**
     * Cancel a subscription and stop any further billing.  Use this endpoint when users want to terminate active services.
     * @summary Cancel subscription
     * @param {string} subscriptionId Subscription ID
     * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingSubscriptionsApi
     */
    public cancelSubscriptionV1(subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options?: RawAxiosRequestConfig) {
        return BillingSubscriptionsApiFp(this.configuration).cancelSubscriptionV1(subscriptionId, billingV1SubscriptionCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all subscriptions associated with your account.  Use this endpoint to monitor active services and billing status.
     * @summary Get subscription list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingSubscriptionsApi
     */
    public getSubscriptionListV1(options?: RawAxiosRequestConfig) {
        return BillingSubscriptionsApiFp(this.configuration).getSubscriptionListV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DNSSnapshotApi - axios parameter creator
 * @export
 */
export const DNSSnapshotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve DNS snapshots for a domain.  Use this endpoint to view available DNS backup points for restoration.
         * @summary Get DNS snapshot list
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSSnapshotListV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDNSSnapshotListV1', 'domain', domain)
            const localVarPath = `/api/dns/v1/snapshots/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve particular DNS snapshot with contents of DNS zone records.  Use this endpoint to view historical DNS configurations for domains.
         * @summary Get DNS snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSSnapshotV1: async (domain: string, snapshotId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDNSSnapshotV1', 'domain', domain)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('getDNSSnapshotV1', 'snapshotId', snapshotId)
            const localVarPath = `/api/dns/v1/snapshots/{domain}/{snapshotId}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore DNS zone to the selected snapshot.  Use this endpoint to revert domain DNS to a previous configuration.
         * @summary Restore DNS snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDNSSnapshotV1: async (domain: string, snapshotId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('restoreDNSSnapshotV1', 'domain', domain)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('restoreDNSSnapshotV1', 'snapshotId', snapshotId)
            const localVarPath = `/api/dns/v1/snapshots/{domain}/{snapshotId}/restore`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DNSSnapshotApi - functional programming interface
 * @export
 */
export const DNSSnapshotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DNSSnapshotApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve DNS snapshots for a domain.  Use this endpoint to view available DNS backup points for restoration.
         * @summary Get DNS snapshot list
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDNSSnapshotListV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DNSV1SnapshotSnapshotResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDNSSnapshotListV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DNSSnapshotApi.getDNSSnapshotListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve particular DNS snapshot with contents of DNS zone records.  Use this endpoint to view historical DNS configurations for domains.
         * @summary Get DNS snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDNSSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSV1SnapshotSnapshotWithContentResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDNSSnapshotV1(domain, snapshotId, options);
            const localVarOperationServerBasePath = operationServerMap['DNSSnapshotApi.getDNSSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore DNS zone to the selected snapshot.  Use this endpoint to revert domain DNS to a previous configuration.
         * @summary Restore DNS snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDNSSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDNSSnapshotV1(domain, snapshotId, options);
            const localVarOperationServerBasePath = operationServerMap['DNSSnapshotApi.restoreDNSSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DNSSnapshotApi - factory interface
 * @export
 */
export const DNSSnapshotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DNSSnapshotApiFp(configuration)
    return {
        /**
         * Retrieve DNS snapshots for a domain.  Use this endpoint to view available DNS backup points for restoration.
         * @summary Get DNS snapshot list
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSSnapshotListV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DNSV1SnapshotSnapshotResource>> {
            return localVarFp.getDNSSnapshotListV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve particular DNS snapshot with contents of DNS zone records.  Use this endpoint to view historical DNS configurations for domains.
         * @summary Get DNS snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): AxiosPromise<DNSV1SnapshotSnapshotWithContentResource> {
            return localVarFp.getDNSSnapshotV1(domain, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore DNS zone to the selected snapshot.  Use this endpoint to revert domain DNS to a previous configuration.
         * @summary Restore DNS snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDNSSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.restoreDNSSnapshotV1(domain, snapshotId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DNSSnapshotApi - object-oriented interface
 * @export
 * @class DNSSnapshotApi
 * @extends {BaseAPI}
 */
export class DNSSnapshotApi extends BaseAPI {
    /**
     * Retrieve DNS snapshots for a domain.  Use this endpoint to view available DNS backup points for restoration.
     * @summary Get DNS snapshot list
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSSnapshotApi
     */
    public getDNSSnapshotListV1(domain: string, options?: RawAxiosRequestConfig) {
        return DNSSnapshotApiFp(this.configuration).getDNSSnapshotListV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve particular DNS snapshot with contents of DNS zone records.  Use this endpoint to view historical DNS configurations for domains.
     * @summary Get DNS snapshot
     * @param {string} domain Domain name
     * @param {number} snapshotId Snapshot ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSSnapshotApi
     */
    public getDNSSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig) {
        return DNSSnapshotApiFp(this.configuration).getDNSSnapshotV1(domain, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore DNS zone to the selected snapshot.  Use this endpoint to revert domain DNS to a previous configuration.
     * @summary Restore DNS snapshot
     * @param {string} domain Domain name
     * @param {number} snapshotId Snapshot ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSSnapshotApi
     */
    public restoreDNSSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig) {
        return DNSSnapshotApiFp(this.configuration).restoreDNSSnapshotV1(domain, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DNSZoneApi - axios parameter creator
 * @export
 */
export const DNSZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.  Use this endpoint to remove specific DNS records from domains.
         * @summary Delete DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDNSRecordsV1: async (domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('deleteDNSRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneDestroyRequest' is not null or undefined
            assertParamExists('deleteDNSRecordsV1', 'dNSV1ZoneDestroyRequest', dNSV1ZoneDestroyRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneDestroyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve DNS zone records for a specific domain.  Use this endpoint to view current DNS configuration for domain management.
         * @summary Get DNS records
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSRecordsV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDNSRecordsV1', 'domain', domain)
            const localVarPath = `/api/dns/v1/zones/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset DNS zone to the default records.  Use this endpoint to restore domain DNS to original configuration.
         * @summary Reset DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetDNSRecordsV1: async (domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('resetDNSRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneResetRequest' is not null or undefined
            assertParamExists('resetDNSRecordsV1', 'dNSV1ZoneResetRequest', dNSV1ZoneResetRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}/reset`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update DNS records for the selected domain.  Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.  Use this endpoint to modify domain DNS configuration.
         * @summary Update DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDNSRecordsV1: async (domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('updateDNSRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneUpdateRequest' is not null or undefined
            assertParamExists('updateDNSRecordsV1', 'dNSV1ZoneUpdateRequest', dNSV1ZoneUpdateRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate DNS records prior to update for the selected domain.  If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.  Use this endpoint to verify DNS record validity before applying changes.
         * @summary Validate DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDNSRecordsV1: async (domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('validateDNSRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneUpdateRequest' is not null or undefined
            assertParamExists('validateDNSRecordsV1', 'dNSV1ZoneUpdateRequest', dNSV1ZoneUpdateRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}/validate`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DNSZoneApi - functional programming interface
 * @export
 */
export const DNSZoneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DNSZoneApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.  Use this endpoint to remove specific DNS records from domains.
         * @summary Delete DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDNSRecordsV1(domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDNSRecordsV1(domain, dNSV1ZoneDestroyRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.deleteDNSRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve DNS zone records for a specific domain.  Use this endpoint to view current DNS configuration for domain management.
         * @summary Get DNS records
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDNSRecordsV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DNSV1ZoneRecordResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDNSRecordsV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.getDNSRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset DNS zone to the default records.  Use this endpoint to restore domain DNS to original configuration.
         * @summary Reset DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetDNSRecordsV1(domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetDNSRecordsV1(domain, dNSV1ZoneResetRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.resetDNSRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update DNS records for the selected domain.  Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.  Use this endpoint to modify domain DNS configuration.
         * @summary Update DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDNSRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDNSRecordsV1(domain, dNSV1ZoneUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.updateDNSRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate DNS records prior to update for the selected domain.  If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.  Use this endpoint to verify DNS record validity before applying changes.
         * @summary Validate DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateDNSRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateDNSRecordsV1(domain, dNSV1ZoneUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.validateDNSRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DNSZoneApi - factory interface
 * @export
 */
export const DNSZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DNSZoneApiFp(configuration)
    return {
        /**
         * Delete DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.  Use this endpoint to remove specific DNS records from domains.
         * @summary Delete DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDNSRecordsV1(domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteDNSRecordsV1(domain, dNSV1ZoneDestroyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve DNS zone records for a specific domain.  Use this endpoint to view current DNS configuration for domain management.
         * @summary Get DNS records
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSRecordsV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DNSV1ZoneRecordResource>> {
            return localVarFp.getDNSRecordsV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset DNS zone to the default records.  Use this endpoint to restore domain DNS to original configuration.
         * @summary Reset DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetDNSRecordsV1(domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.resetDNSRecordsV1(domain, dNSV1ZoneResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update DNS records for the selected domain.  Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.  Use this endpoint to modify domain DNS configuration.
         * @summary Update DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDNSRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.updateDNSRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate DNS records prior to update for the selected domain.  If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.  Use this endpoint to verify DNS record validity before applying changes.
         * @summary Validate DNS records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDNSRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.validateDNSRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DNSZoneApi - object-oriented interface
 * @export
 * @class DNSZoneApi
 * @extends {BaseAPI}
 */
export class DNSZoneApi extends BaseAPI {
    /**
     * Delete DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.  Use this endpoint to remove specific DNS records from domains.
     * @summary Delete DNS records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public deleteDNSRecordsV1(domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).deleteDNSRecordsV1(domain, dNSV1ZoneDestroyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve DNS zone records for a specific domain.  Use this endpoint to view current DNS configuration for domain management.
     * @summary Get DNS records
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public getDNSRecordsV1(domain: string, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).getDNSRecordsV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset DNS zone to the default records.  Use this endpoint to restore domain DNS to original configuration.
     * @summary Reset DNS records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public resetDNSRecordsV1(domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).resetDNSRecordsV1(domain, dNSV1ZoneResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update DNS records for the selected domain.  Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.  Use this endpoint to modify domain DNS configuration.
     * @summary Update DNS records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public updateDNSRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).updateDNSRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate DNS records prior to update for the selected domain.  If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.  Use this endpoint to verify DNS record validity before applying changes.
     * @summary Validate DNS records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public validateDNSRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).validateDNSRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsAvailabilityApi - axios parameter creator
 * @export
 */
export const DomainsAvailabilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check availability of domain names across multiple TLDs.  Multiple TLDs can be checked at once. If you want alternative domains with response, provide only one TLD and set `with_alternatives` to `true`. TLDs should be provided without leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.  Use this endpoint to verify domain availability before purchase.
         * @summary Check domain availability
         * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailabilityV1: async (domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1AvailabilityAvailabilityRequest' is not null or undefined
            assertParamExists('checkDomainAvailabilityV1', 'domainsV1AvailabilityAvailabilityRequest', domainsV1AvailabilityAvailabilityRequest)
            const localVarPath = `/api/domains/v1/availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1AvailabilityAvailabilityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsAvailabilityApi - functional programming interface
 * @export
 */
export const DomainsAvailabilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsAvailabilityApiAxiosParamCreator(configuration)
    return {
        /**
         * Check availability of domain names across multiple TLDs.  Multiple TLDs can be checked at once. If you want alternative domains with response, provide only one TLD and set `with_alternatives` to `true`. TLDs should be provided without leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.  Use this endpoint to verify domain availability before purchase.
         * @summary Check domain availability
         * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainsV1AvailabilityAvailabilityResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsAvailabilityApi.checkDomainAvailabilityV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsAvailabilityApi - factory interface
 * @export
 */
export const DomainsAvailabilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsAvailabilityApiFp(configuration)
    return {
        /**
         * Check availability of domain names across multiple TLDs.  Multiple TLDs can be checked at once. If you want alternative domains with response, provide only one TLD and set `with_alternatives` to `true`. TLDs should be provided without leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.  Use this endpoint to verify domain availability before purchase.
         * @summary Check domain availability
         * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DomainsV1AvailabilityAvailabilityResource>> {
            return localVarFp.checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsAvailabilityApi - object-oriented interface
 * @export
 * @class DomainsAvailabilityApi
 * @extends {BaseAPI}
 */
export class DomainsAvailabilityApi extends BaseAPI {
    /**
     * Check availability of domain names across multiple TLDs.  Multiple TLDs can be checked at once. If you want alternative domains with response, provide only one TLD and set `with_alternatives` to `true`. TLDs should be provided without leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.  Use this endpoint to verify domain availability before purchase.
     * @summary Check domain availability
     * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsAvailabilityApi
     */
    public checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options?: RawAxiosRequestConfig) {
        return DomainsAvailabilityApiFp(this.configuration).checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsForwardingApi - axios parameter creator
 * @export
 */
export const DomainsForwardingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create domain forwarding configuration.  Use this endpoint to set up domain redirects to other URLs.
         * @summary Create domain forwarding
         * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainForwardingV1: async (domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1ForwardingStoreRequest' is not null or undefined
            assertParamExists('createDomainForwardingV1', 'domainsV1ForwardingStoreRequest', domainsV1ForwardingStoreRequest)
            const localVarPath = `/api/domains/v1/forwarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1ForwardingStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete domain forwarding data.  Use this endpoint to remove redirect configuration from domains.
         * @summary Delete domain forwarding
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainForwardingV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('deleteDomainForwardingV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/forwarding/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve domain forwarding data.  Use this endpoint to view current redirect configuration for domains.
         * @summary Get domain forwarding
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainForwardingV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDomainForwardingV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/forwarding/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsForwardingApi - functional programming interface
 * @export
 */
export const DomainsForwardingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsForwardingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create domain forwarding configuration.  Use this endpoint to set up domain redirects to other URLs.
         * @summary Create domain forwarding
         * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainForwardingV1(domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1ForwardingForwardingResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainForwardingV1(domainsV1ForwardingStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsForwardingApi.createDomainForwardingV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete domain forwarding data.  Use this endpoint to remove redirect configuration from domains.
         * @summary Delete domain forwarding
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainForwardingV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainForwardingV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsForwardingApi.deleteDomainForwardingV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve domain forwarding data.  Use this endpoint to view current redirect configuration for domains.
         * @summary Get domain forwarding
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainForwardingV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1ForwardingForwardingResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainForwardingV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsForwardingApi.getDomainForwardingV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsForwardingApi - factory interface
 * @export
 */
export const DomainsForwardingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsForwardingApiFp(configuration)
    return {
        /**
         * Create domain forwarding configuration.  Use this endpoint to set up domain redirects to other URLs.
         * @summary Create domain forwarding
         * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainForwardingV1(domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1ForwardingForwardingResource> {
            return localVarFp.createDomainForwardingV1(domainsV1ForwardingStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete domain forwarding data.  Use this endpoint to remove redirect configuration from domains.
         * @summary Delete domain forwarding
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainForwardingV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteDomainForwardingV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve domain forwarding data.  Use this endpoint to view current redirect configuration for domains.
         * @summary Get domain forwarding
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainForwardingV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1ForwardingForwardingResource> {
            return localVarFp.getDomainForwardingV1(domain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsForwardingApi - object-oriented interface
 * @export
 * @class DomainsForwardingApi
 * @extends {BaseAPI}
 */
export class DomainsForwardingApi extends BaseAPI {
    /**
     * Create domain forwarding configuration.  Use this endpoint to set up domain redirects to other URLs.
     * @summary Create domain forwarding
     * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsForwardingApi
     */
    public createDomainForwardingV1(domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options?: RawAxiosRequestConfig) {
        return DomainsForwardingApiFp(this.configuration).createDomainForwardingV1(domainsV1ForwardingStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete domain forwarding data.  Use this endpoint to remove redirect configuration from domains.
     * @summary Delete domain forwarding
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsForwardingApi
     */
    public deleteDomainForwardingV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsForwardingApiFp(this.configuration).deleteDomainForwardingV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve domain forwarding data.  Use this endpoint to view current redirect configuration for domains.
     * @summary Get domain forwarding
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsForwardingApi
     */
    public getDomainForwardingV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsForwardingApiFp(this.configuration).getDomainForwardingV1(domain, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsPortfolioApi - axios parameter creator
 * @export
 */
export const DomainsPortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Disable domain lock for the domain.  Domain lock needs to be disabled before transferring the domain to another registrar.  Use this endpoint to prepare domains for transfer to other registrars.
         * @summary Disable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableDomainLockV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('disableDomainLockV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/domain-lock`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable privacy protection for the domain.  When privacy protection is disabled, domain owner\'s personal information is visible in public WHOIS database.  Use this endpoint to make domain owner\'s information publicly visible.
         * @summary Disable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePrivacyProtectionV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('disablePrivacyProtectionV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/privacy-protection`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable domain lock for the domain.  When domain lock is enabled, the domain cannot be transferred to another registrar without first disabling the lock.  Use this endpoint to secure domains against unauthorized transfers.
         * @summary Enable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableDomainLockV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('enableDomainLockV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/domain-lock`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable privacy protection for the domain.  When privacy protection is enabled, domain owner\'s personal information is hidden from public WHOIS database.  Use this endpoint to protect domain owner\'s personal information from public view.
         * @summary Enable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePrivacyProtectionV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('enablePrivacyProtectionV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/privacy-protection`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information for specified domain.  Use this endpoint to view comprehensive domain configuration and status.
         * @summary Get domain details
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainDetailsV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDomainDetailsV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all domains associated with your account.  Use this endpoint to view user\'s domain portfolio.
         * @summary Get domain list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/domains/v1/portfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchase and register a new domain name.  If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, default contact information for that TLD will be used.  Before making request, ensure WHOIS information for desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing purchase.  Use this endpoint to register new domains for users.
         * @summary Purchase new domain
         * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewDomainV1: async (domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1PortfolioPurchaseRequest' is not null or undefined
            assertParamExists('purchaseNewDomainV1', 'domainsV1PortfolioPurchaseRequest', domainsV1PortfolioPurchaseRequest)
            const localVarPath = `/api/domains/v1/portfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1PortfolioPurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable.  Use this endpoint to configure custom DNS hosting for domains.
         * @summary Update domain nameservers
         * @param {string} domain Domain name
         * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameserversV1: async (domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('updateDomainNameserversV1', 'domain', domain)
            // verify required parameter 'domainsV1PortfolioUpdateNameserversRequest' is not null or undefined
            assertParamExists('updateDomainNameserversV1', 'domainsV1PortfolioUpdateNameserversRequest', domainsV1PortfolioUpdateNameserversRequest)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/nameservers`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1PortfolioUpdateNameserversRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsPortfolioApi - functional programming interface
 * @export
 */
export const DomainsPortfolioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsPortfolioApiAxiosParamCreator(configuration)
    return {
        /**
         * Disable domain lock for the domain.  Domain lock needs to be disabled before transferring the domain to another registrar.  Use this endpoint to prepare domains for transfer to other registrars.
         * @summary Disable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableDomainLockV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.disableDomainLockV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable privacy protection for the domain.  When privacy protection is disabled, domain owner\'s personal information is visible in public WHOIS database.  Use this endpoint to make domain owner\'s information publicly visible.
         * @summary Disable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disablePrivacyProtectionV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.disablePrivacyProtectionV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable domain lock for the domain.  When domain lock is enabled, the domain cannot be transferred to another registrar without first disabling the lock.  Use this endpoint to secure domains against unauthorized transfers.
         * @summary Enable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableDomainLockV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.enableDomainLockV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable privacy protection for the domain.  When privacy protection is enabled, domain owner\'s personal information is hidden from public WHOIS database.  Use this endpoint to protect domain owner\'s personal information from public view.
         * @summary Enable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enablePrivacyProtectionV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.enablePrivacyProtectionV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information for specified domain.  Use this endpoint to view comprehensive domain configuration and status.
         * @summary Get domain details
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainDetailsV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1DomainDomainExtendedResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainDetailsV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.getDomainDetailsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all domains associated with your account.  Use this endpoint to view user\'s domain portfolio.
         * @summary Get domain list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainsV1DomainDomainResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainListV1(options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.getDomainListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Purchase and register a new domain name.  If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, default contact information for that TLD will be used.  Before making request, ensure WHOIS information for desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing purchase.  Use this endpoint to register new domains for users.
         * @summary Purchase new domain
         * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingV1OrderOrderResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.purchaseNewDomainV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable.  Use this endpoint to configure custom DNS hosting for domains.
         * @summary Update domain nameservers
         * @param {string} domain Domain name
         * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameserversV1(domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameserversV1(domain, domainsV1PortfolioUpdateNameserversRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.updateDomainNameserversV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsPortfolioApi - factory interface
 * @export
 */
export const DomainsPortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsPortfolioApiFp(configuration)
    return {
        /**
         * Disable domain lock for the domain.  Domain lock needs to be disabled before transferring the domain to another registrar.  Use this endpoint to prepare domains for transfer to other registrars.
         * @summary Disable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.disableDomainLockV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable privacy protection for the domain.  When privacy protection is disabled, domain owner\'s personal information is visible in public WHOIS database.  Use this endpoint to make domain owner\'s information publicly visible.
         * @summary Disable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.disablePrivacyProtectionV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable domain lock for the domain.  When domain lock is enabled, the domain cannot be transferred to another registrar without first disabling the lock.  Use this endpoint to secure domains against unauthorized transfers.
         * @summary Enable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.enableDomainLockV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable privacy protection for the domain.  When privacy protection is enabled, domain owner\'s personal information is hidden from public WHOIS database.  Use this endpoint to protect domain owner\'s personal information from public view.
         * @summary Enable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.enablePrivacyProtectionV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information for specified domain.  Use this endpoint to view comprehensive domain configuration and status.
         * @summary Get domain details
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainDetailsV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1DomainDomainExtendedResource> {
            return localVarFp.getDomainDetailsV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all domains associated with your account.  Use this endpoint to view user\'s domain portfolio.
         * @summary Get domain list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<DomainsV1DomainDomainResource>> {
            return localVarFp.getDomainListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase and register a new domain name.  If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, default contact information for that TLD will be used.  Before making request, ensure WHOIS information for desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing purchase.  Use this endpoint to register new domains for users.
         * @summary Purchase new domain
         * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingV1OrderOrderResource> {
            return localVarFp.purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable.  Use this endpoint to configure custom DNS hosting for domains.
         * @summary Update domain nameservers
         * @param {string} domain Domain name
         * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameserversV1(domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.updateDomainNameserversV1(domain, domainsV1PortfolioUpdateNameserversRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsPortfolioApi - object-oriented interface
 * @export
 * @class DomainsPortfolioApi
 * @extends {BaseAPI}
 */
export class DomainsPortfolioApi extends BaseAPI {
    /**
     * Disable domain lock for the domain.  Domain lock needs to be disabled before transferring the domain to another registrar.  Use this endpoint to prepare domains for transfer to other registrars.
     * @summary Disable domain lock
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public disableDomainLockV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).disableDomainLockV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable privacy protection for the domain.  When privacy protection is disabled, domain owner\'s personal information is visible in public WHOIS database.  Use this endpoint to make domain owner\'s information publicly visible.
     * @summary Disable privacy protection
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public disablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).disablePrivacyProtectionV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable domain lock for the domain.  When domain lock is enabled, the domain cannot be transferred to another registrar without first disabling the lock.  Use this endpoint to secure domains against unauthorized transfers.
     * @summary Enable domain lock
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public enableDomainLockV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).enableDomainLockV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable privacy protection for the domain.  When privacy protection is enabled, domain owner\'s personal information is hidden from public WHOIS database.  Use this endpoint to protect domain owner\'s personal information from public view.
     * @summary Enable privacy protection
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public enablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).enablePrivacyProtectionV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information for specified domain.  Use this endpoint to view comprehensive domain configuration and status.
     * @summary Get domain details
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public getDomainDetailsV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).getDomainDetailsV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all domains associated with your account.  Use this endpoint to view user\'s domain portfolio.
     * @summary Get domain list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public getDomainListV1(options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).getDomainListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purchase and register a new domain name.  If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, default contact information for that TLD will be used.  Before making request, ensure WHOIS information for desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing purchase.  Use this endpoint to register new domains for users.
     * @summary Purchase new domain
     * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable.  Use this endpoint to configure custom DNS hosting for domains.
     * @summary Update domain nameservers
     * @param {string} domain Domain name
     * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public updateDomainNameserversV1(domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).updateDomainNameserversV1(domain, domainsV1PortfolioUpdateNameserversRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsWHOISApi - axios parameter creator
 * @export
 */
export const DomainsWHOISApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create WHOIS contact profile.  Use this endpoint to add new contact information for domain registration.
         * @summary Create WHOIS profile
         * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWHOISProfileV1: async (domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1WHOISStoreRequest' is not null or undefined
            assertParamExists('createWHOISProfileV1', 'domainsV1WHOISStoreRequest', domainsV1WHOISStoreRequest)
            const localVarPath = `/api/domains/v1/whois`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1WHOISStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete WHOIS contact profile.  Use this endpoint to remove unused contact profiles from account.
         * @summary Delete WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWHOISProfileV1: async (whoisId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whoisId' is not null or undefined
            assertParamExists('deleteWHOISProfileV1', 'whoisId', whoisId)
            const localVarPath = `/api/domains/v1/whois/{whoisId}`
                .replace(`{${"whoisId"}}`, encodeURIComponent(String(whoisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve WHOIS contact profiles.  Use this endpoint to view available contact profiles for domain registration.
         * @summary Get WHOIS profile list
         * @param {string} [tld] Filter by TLD (without leading dot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileListV1: async (tld?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/domains/v1/whois`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tld !== undefined) {
                localVarQueryParameter['tld'] = tld;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve domain list where provided WHOIS contact profile is used.  Use this endpoint to view which domains use specific contact profiles.
         * @summary Get WHOIS profile usage
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileUsageV1: async (whoisId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whoisId' is not null or undefined
            assertParamExists('getWHOISProfileUsageV1', 'whoisId', whoisId)
            const localVarPath = `/api/domains/v1/whois/{whoisId}/usage`
                .replace(`{${"whoisId"}}`, encodeURIComponent(String(whoisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a WHOIS contact profile.  Use this endpoint to view domain registration contact information.
         * @summary Get WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileV1: async (whoisId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whoisId' is not null or undefined
            assertParamExists('getWHOISProfileV1', 'whoisId', whoisId)
            const localVarPath = `/api/domains/v1/whois/{whoisId}`
                .replace(`{${"whoisId"}}`, encodeURIComponent(String(whoisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsWHOISApi - functional programming interface
 * @export
 */
export const DomainsWHOISApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsWHOISApiAxiosParamCreator(configuration)
    return {
        /**
         * Create WHOIS contact profile.  Use this endpoint to add new contact information for domain registration.
         * @summary Create WHOIS profile
         * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWHOISProfileV1(domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1WHOISProfileResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWHOISProfileV1(domainsV1WHOISStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.createWHOISProfileV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete WHOIS contact profile.  Use this endpoint to remove unused contact profiles from account.
         * @summary Delete WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWHOISProfileV1(whoisId, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.deleteWHOISProfileV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve WHOIS contact profiles.  Use this endpoint to view available contact profiles for domain registration.
         * @summary Get WHOIS profile list
         * @param {string} [tld] Filter by TLD (without leading dot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWHOISProfileListV1(tld?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainsV1WHOISProfileResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWHOISProfileListV1(tld, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.getWHOISProfileListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve domain list where provided WHOIS contact profile is used.  Use this endpoint to view which domains use specific contact profiles.
         * @summary Get WHOIS profile usage
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWHOISProfileUsageV1(whoisId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWHOISProfileUsageV1(whoisId, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.getWHOISProfileUsageV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a WHOIS contact profile.  Use this endpoint to view domain registration contact information.
         * @summary Get WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1WHOISProfileResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWHOISProfileV1(whoisId, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.getWHOISProfileV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsWHOISApi - factory interface
 * @export
 */
export const DomainsWHOISApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsWHOISApiFp(configuration)
    return {
        /**
         * Create WHOIS contact profile.  Use this endpoint to add new contact information for domain registration.
         * @summary Create WHOIS profile
         * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWHOISProfileV1(domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1WHOISProfileResource> {
            return localVarFp.createWHOISProfileV1(domainsV1WHOISStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete WHOIS contact profile.  Use this endpoint to remove unused contact profiles from account.
         * @summary Delete WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteWHOISProfileV1(whoisId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve WHOIS contact profiles.  Use this endpoint to view available contact profiles for domain registration.
         * @summary Get WHOIS profile list
         * @param {string} [tld] Filter by TLD (without leading dot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileListV1(tld?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DomainsV1WHOISProfileResource>> {
            return localVarFp.getWHOISProfileListV1(tld, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve domain list where provided WHOIS contact profile is used.  Use this endpoint to view which domains use specific contact profiles.
         * @summary Get WHOIS profile usage
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileUsageV1(whoisId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getWHOISProfileUsageV1(whoisId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a WHOIS contact profile.  Use this endpoint to view domain registration contact information.
         * @summary Get WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1WHOISProfileResource> {
            return localVarFp.getWHOISProfileV1(whoisId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsWHOISApi - object-oriented interface
 * @export
 * @class DomainsWHOISApi
 * @extends {BaseAPI}
 */
export class DomainsWHOISApi extends BaseAPI {
    /**
     * Create WHOIS contact profile.  Use this endpoint to add new contact information for domain registration.
     * @summary Create WHOIS profile
     * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public createWHOISProfileV1(domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).createWHOISProfileV1(domainsV1WHOISStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete WHOIS contact profile.  Use this endpoint to remove unused contact profiles from account.
     * @summary Delete WHOIS profile
     * @param {number} whoisId WHOIS ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public deleteWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).deleteWHOISProfileV1(whoisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve WHOIS contact profiles.  Use this endpoint to view available contact profiles for domain registration.
     * @summary Get WHOIS profile list
     * @param {string} [tld] Filter by TLD (without leading dot)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public getWHOISProfileListV1(tld?: string, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).getWHOISProfileListV1(tld, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve domain list where provided WHOIS contact profile is used.  Use this endpoint to view which domains use specific contact profiles.
     * @summary Get WHOIS profile usage
     * @param {number} whoisId WHOIS ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public getWHOISProfileUsageV1(whoisId: number, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).getWHOISProfileUsageV1(whoisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a WHOIS contact profile.  Use this endpoint to view domain registration contact information.
     * @summary Get WHOIS profile
     * @param {number} whoisId WHOIS ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public getWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).getWHOISProfileV1(whoisId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSActionsApi - axios parameter creator
 * @export
 */
export const VPSActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve detailed information about a specific action performed on a specified virtual machine.  Use this endpoint to monitor specific VPS operation status and details.
         * @summary Get action details
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} actionId Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionDetailsV1: async (virtualMachineId: number, actionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getActionDetailsV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('getActionDetailsV1', 'actionId', actionId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/actions/{actionId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.  Use this endpoint to view VPS operation history and troubleshoot issues.
         * @summary Get actions
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionsV1: async (virtualMachineId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getActionsV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/actions`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSActionsApi - functional programming interface
 * @export
 */
export const VPSActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve detailed information about a specific action performed on a specified virtual machine.  Use this endpoint to monitor specific VPS operation status and details.
         * @summary Get action details
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} actionId Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionDetailsV1(virtualMachineId: number, actionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionDetailsV1(virtualMachineId, actionId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSActionsApi.getActionDetailsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.  Use this endpoint to view VPS operation history and troubleshoot issues.
         * @summary Get actions
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionsV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetActionsV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionsV1(virtualMachineId, page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSActionsApi.getActionsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSActionsApi - factory interface
 * @export
 */
export const VPSActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSActionsApiFp(configuration)
    return {
        /**
         * Retrieve detailed information about a specific action performed on a specified virtual machine.  Use this endpoint to monitor specific VPS operation status and details.
         * @summary Get action details
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} actionId Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionDetailsV1(virtualMachineId: number, actionId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.getActionDetailsV1(virtualMachineId, actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.  Use this endpoint to view VPS operation history and troubleshoot issues.
         * @summary Get actions
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionsV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetActionsV1200Response> {
            return localVarFp.getActionsV1(virtualMachineId, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSActionsApi - object-oriented interface
 * @export
 * @class VPSActionsApi
 * @extends {BaseAPI}
 */
export class VPSActionsApi extends BaseAPI {
    /**
     * Retrieve detailed information about a specific action performed on a specified virtual machine.  Use this endpoint to monitor specific VPS operation status and details.
     * @summary Get action details
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} actionId Action ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSActionsApi
     */
    public getActionDetailsV1(virtualMachineId: number, actionId: number, options?: RawAxiosRequestConfig) {
        return VPSActionsApiFp(this.configuration).getActionDetailsV1(virtualMachineId, actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.  Use this endpoint to view VPS operation history and troubleshoot issues.
     * @summary Get actions
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSActionsApi
     */
    public getActionsV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig) {
        return VPSActionsApiFp(this.configuration).getActionsV1(virtualMachineId, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSBackupsApi - axios parameter creator
 * @export
 */
export const VPSBackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve backups for a specified virtual machine.  Use this endpoint to view available backup points for VPS data recovery.
         * @summary Get backups
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupsV1: async (virtualMachineId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getBackupsV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/backups`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**  Use this endpoint to recover VPS data from backup points.
         * @summary Restore backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBackupV1: async (virtualMachineId: number, backupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('restoreBackupV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('restoreBackupV1', 'backupId', backupId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/backups/{backupId}/restore`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSBackupsApi - functional programming interface
 * @export
 */
export const VPSBackupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSBackupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve backups for a specified virtual machine.  Use this endpoint to view available backup points for VPS data recovery.
         * @summary Get backups
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupsV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetBackupsV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupsV1(virtualMachineId, page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSBackupsApi.getBackupsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**  Use this endpoint to recover VPS data from backup points.
         * @summary Restore backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreBackupV1(virtualMachineId, backupId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSBackupsApi.restoreBackupV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSBackupsApi - factory interface
 * @export
 */
export const VPSBackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSBackupsApiFp(configuration)
    return {
        /**
         * Retrieve backups for a specified virtual machine.  Use this endpoint to view available backup points for VPS data recovery.
         * @summary Get backups
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupsV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetBackupsV1200Response> {
            return localVarFp.getBackupsV1(virtualMachineId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**  Use this endpoint to recover VPS data from backup points.
         * @summary Restore backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.restoreBackupV1(virtualMachineId, backupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSBackupsApi - object-oriented interface
 * @export
 * @class VPSBackupsApi
 * @extends {BaseAPI}
 */
export class VPSBackupsApi extends BaseAPI {
    /**
     * Retrieve backups for a specified virtual machine.  Use this endpoint to view available backup points for VPS data recovery.
     * @summary Get backups
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSBackupsApi
     */
    public getBackupsV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig) {
        return VPSBackupsApiFp(this.configuration).getBackupsV1(virtualMachineId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**  Use this endpoint to recover VPS data from backup points.
     * @summary Restore backup
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} backupId Backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSBackupsApi
     */
    public restoreBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig) {
        return VPSBackupsApiFp(this.configuration).restoreBackupV1(virtualMachineId, backupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSDataCentersApi - axios parameter creator
 * @export
 */
export const VPSDataCentersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all available data centers.  Use this endpoint to view location options before deploying VPS instances.
         * @summary Get data center list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCenterListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/data-centers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSDataCentersApi - functional programming interface
 * @export
 */
export const VPSDataCentersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSDataCentersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all available data centers.  Use this endpoint to view location options before deploying VPS instances.
         * @summary Get data center list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataCenterListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1DataCenterDataCenterResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataCenterListV1(options);
            const localVarOperationServerBasePath = operationServerMap['VPSDataCentersApi.getDataCenterListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSDataCentersApi - factory interface
 * @export
 */
export const VPSDataCentersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSDataCentersApiFp(configuration)
    return {
        /**
         * Retrieve all available data centers.  Use this endpoint to view location options before deploying VPS instances.
         * @summary Get data center list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCenterListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1DataCenterDataCenterResource>> {
            return localVarFp.getDataCenterListV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSDataCentersApi - object-oriented interface
 * @export
 * @class VPSDataCentersApi
 * @extends {BaseAPI}
 */
export class VPSDataCentersApi extends BaseAPI {
    /**
     * Retrieve all available data centers.  Use this endpoint to view location options before deploying VPS instances.
     * @summary Get data center list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDataCentersApi
     */
    public getDataCenterListV1(options?: RawAxiosRequestConfig) {
        return VPSDataCentersApiFp(this.configuration).getDataCenterListV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSDockerManagerApi - axios parameter creator
 * @export
 */
export const VPSDockerManagerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploy new project from docker-compose.yaml contents or download contents from URL.   URL can be Github repository url in format https://github.com/[user]/[repo] and it will be automatically resolved to  docker-compose.yaml file in master branch. Any other URL provided must return docker-compose.yaml file contents.  If project already exists, it will be replaced.
         * @summary Create new project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineDockerManagerUpRequest} vPSV1VirtualMachineDockerManagerUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewProjectV1: async (virtualMachineId: number, vPSV1VirtualMachineDockerManagerUpRequest: VPSV1VirtualMachineDockerManagerUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('createNewProjectV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineDockerManagerUpRequest' is not null or undefined
            assertParamExists('createNewProjectV1', 'vPSV1VirtualMachineDockerManagerUpRequest', vPSV1VirtualMachineDockerManagerUpRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineDockerManagerUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely removes a Docker Compose project from the virtual machine, stopping all containers and cleaning up  associated resources including networks, volumes, and images.   This operation is irreversible and will delete all project data.   Use this when you want to permanently remove a project and free up system resources.
         * @summary Delete project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deleteProjectV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('deleteProjectV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}/down`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all containers belonging to a specific Docker Compose project on the virtual machine.   This endpoint returns detailed information about each container including their current status, port mappings, and runtime configuration.   Use this to monitor the health and state of all services within your Docker Compose project.
         * @summary Get project containers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectContainersV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getProjectContainersV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getProjectContainersV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}/containers`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the complete project information including the docker-compose.yml file contents, project metadata, and current deployment status.   This endpoint provides the full configuration and state details of a specific Docker Compose project.   Use this to inspect project settings, review the compose file, or check the overall project health.
         * @summary Get project contents
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectContentsV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getProjectContentsV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getProjectContentsV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all Docker Compose projects currently deployed on the virtual machine.   This endpoint returns basic information about each project including name, status, and file path.   Use this to get an overview of all Docker projects on your VPS instance.
         * @summary Get project list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectListV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getProjectListV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregated log entries from all services within a Docker Compose project.   This endpoint returns recent log output from each container, organized by service name with timestamps.  The response contains the last 300 log entries across all services.   Use this for debugging, monitoring application behavior, and troubleshooting issues across your entire project stack.
         * @summary Get project logs
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectLogsV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getProjectLogsV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('getProjectLogsV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}/logs`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts all services in a Docker Compose project by stopping and starting containers in the correct dependency order.   This operation preserves data volumes and network configurations while refreshing the running containers.   Use this to apply configuration changes or recover from service failures.
         * @summary Restart project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProjectV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('restartProjectV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('restartProjectV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}/restart`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts all services in a Docker Compose project that are currently stopped.   This operation brings up containers in the correct dependency order as defined in the compose file.   Use this to resume a project that was previously stopped or to start services after a system reboot.
         * @summary Start project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProjectV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('startProjectV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('startProjectV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}/start`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops all running services in a Docker Compose project while preserving container configurations and data volumes.   This operation gracefully shuts down containers in reverse dependency order.   Use this to temporarily halt a project without removing data or configurations.
         * @summary Stop project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopProjectV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('stopProjectV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('stopProjectV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}/stop`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Docker Compose project by pulling the latest image versions and recreating containers with new configurations.   This operation preserves data volumes while applying changes from the compose file.   Use this to deploy application updates, apply configuration changes, or refresh container images to their latest versions.
         * @summary Update project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectV1: async (virtualMachineId: number, projectName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('updateProjectV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'projectName' is not null or undefined
            assertParamExists('updateProjectV1', 'projectName', projectName)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/docker/{projectName}/update`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSDockerManagerApi - functional programming interface
 * @export
 */
export const VPSDockerManagerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSDockerManagerApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploy new project from docker-compose.yaml contents or download contents from URL.   URL can be Github repository url in format https://github.com/[user]/[repo] and it will be automatically resolved to  docker-compose.yaml file in master branch. Any other URL provided must return docker-compose.yaml file contents.  If project already exists, it will be replaced.
         * @summary Create new project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineDockerManagerUpRequest} vPSV1VirtualMachineDockerManagerUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewProjectV1(virtualMachineId: number, vPSV1VirtualMachineDockerManagerUpRequest: VPSV1VirtualMachineDockerManagerUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewProjectV1(virtualMachineId, vPSV1VirtualMachineDockerManagerUpRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.createNewProjectV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely removes a Docker Compose project from the virtual machine, stopping all containers and cleaning up  associated resources including networks, volumes, and images.   This operation is irreversible and will delete all project data.   Use this when you want to permanently remove a project and free up system resources.
         * @summary Delete project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.deleteProjectV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all containers belonging to a specific Docker Compose project on the virtual machine.   This endpoint returns detailed information about each container including their current status, port mappings, and runtime configuration.   Use this to monitor the health and state of all services within your Docker Compose project.
         * @summary Get project containers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectContainersV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1DockerManagerContainerResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectContainersV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.getProjectContainersV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the complete project information including the docker-compose.yml file contents, project metadata, and current deployment status.   This endpoint provides the full configuration and state details of a specific Docker Compose project.   Use this to inspect project settings, review the compose file, or check the overall project health.
         * @summary Get project contents
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectContentsV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1DockerManagerContentResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectContentsV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.getProjectContentsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all Docker Compose projects currently deployed on the virtual machine.   This endpoint returns basic information about each project including name, status, and file path.   Use this to get an overview of all Docker projects on your VPS instance.
         * @summary Get project list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectListV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1DockerManagerProjectResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectListV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.getProjectListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregated log entries from all services within a Docker Compose project.   This endpoint returns recent log output from each container, organized by service name with timestamps.  The response contains the last 300 log entries across all services.   Use this for debugging, monitoring application behavior, and troubleshooting issues across your entire project stack.
         * @summary Get project logs
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectLogsV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1DockerManagerLogsResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectLogsV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.getProjectLogsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restarts all services in a Docker Compose project by stopping and starting containers in the correct dependency order.   This operation preserves data volumes and network configurations while refreshing the running containers.   Use this to apply configuration changes or recover from service failures.
         * @summary Restart project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartProjectV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.restartProjectV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts all services in a Docker Compose project that are currently stopped.   This operation brings up containers in the correct dependency order as defined in the compose file.   Use this to resume a project that was previously stopped or to start services after a system reboot.
         * @summary Start project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProjectV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.startProjectV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops all running services in a Docker Compose project while preserving container configurations and data volumes.   This operation gracefully shuts down containers in reverse dependency order.   Use this to temporarily halt a project without removing data or configurations.
         * @summary Stop project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopProjectV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.stopProjectV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a Docker Compose project by pulling the latest image versions and recreating containers with new configurations.   This operation preserves data volumes while applying changes from the compose file.   Use this to deploy application updates, apply configuration changes, or refresh container images to their latest versions.
         * @summary Update project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectV1(virtualMachineId, projectName, options);
            const localVarOperationServerBasePath = operationServerMap['VPSDockerManagerApi.updateProjectV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSDockerManagerApi - factory interface
 * @export
 */
export const VPSDockerManagerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSDockerManagerApiFp(configuration)
    return {
        /**
         * Deploy new project from docker-compose.yaml contents or download contents from URL.   URL can be Github repository url in format https://github.com/[user]/[repo] and it will be automatically resolved to  docker-compose.yaml file in master branch. Any other URL provided must return docker-compose.yaml file contents.  If project already exists, it will be replaced.
         * @summary Create new project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineDockerManagerUpRequest} vPSV1VirtualMachineDockerManagerUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewProjectV1(virtualMachineId: number, vPSV1VirtualMachineDockerManagerUpRequest: VPSV1VirtualMachineDockerManagerUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.createNewProjectV1(virtualMachineId, vPSV1VirtualMachineDockerManagerUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely removes a Docker Compose project from the virtual machine, stopping all containers and cleaning up  associated resources including networks, volumes, and images.   This operation is irreversible and will delete all project data.   Use this when you want to permanently remove a project and free up system resources.
         * @summary Delete project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.deleteProjectV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all containers belonging to a specific Docker Compose project on the virtual machine.   This endpoint returns detailed information about each container including their current status, port mappings, and runtime configuration.   Use this to monitor the health and state of all services within your Docker Compose project.
         * @summary Get project containers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectContainersV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1DockerManagerContainerResource>> {
            return localVarFp.getProjectContainersV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the complete project information including the docker-compose.yml file contents, project metadata, and current deployment status.   This endpoint provides the full configuration and state details of a specific Docker Compose project.   Use this to inspect project settings, review the compose file, or check the overall project health.
         * @summary Get project contents
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectContentsV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1DockerManagerContentResource> {
            return localVarFp.getProjectContentsV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all Docker Compose projects currently deployed on the virtual machine.   This endpoint returns basic information about each project including name, status, and file path.   Use this to get an overview of all Docker projects on your VPS instance.
         * @summary Get project list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectListV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1DockerManagerProjectResource>> {
            return localVarFp.getProjectListV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregated log entries from all services within a Docker Compose project.   This endpoint returns recent log output from each container, organized by service name with timestamps.  The response contains the last 300 log entries across all services.   Use this for debugging, monitoring application behavior, and troubleshooting issues across your entire project stack.
         * @summary Get project logs
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectLogsV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1DockerManagerLogsResource>> {
            return localVarFp.getProjectLogsV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts all services in a Docker Compose project by stopping and starting containers in the correct dependency order.   This operation preserves data volumes and network configurations while refreshing the running containers.   Use this to apply configuration changes or recover from service failures.
         * @summary Restart project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.restartProjectV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts all services in a Docker Compose project that are currently stopped.   This operation brings up containers in the correct dependency order as defined in the compose file.   Use this to resume a project that was previously stopped or to start services after a system reboot.
         * @summary Start project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.startProjectV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops all running services in a Docker Compose project while preserving container configurations and data volumes.   This operation gracefully shuts down containers in reverse dependency order.   Use this to temporarily halt a project without removing data or configurations.
         * @summary Stop project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.stopProjectV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Docker Compose project by pulling the latest image versions and recreating containers with new configurations.   This operation preserves data volumes while applying changes from the compose file.   Use this to deploy application updates, apply configuration changes, or refresh container images to their latest versions.
         * @summary Update project
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.updateProjectV1(virtualMachineId, projectName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSDockerManagerApi - object-oriented interface
 * @export
 * @class VPSDockerManagerApi
 * @extends {BaseAPI}
 */
export class VPSDockerManagerApi extends BaseAPI {
    /**
     * Deploy new project from docker-compose.yaml contents or download contents from URL.   URL can be Github repository url in format https://github.com/[user]/[repo] and it will be automatically resolved to  docker-compose.yaml file in master branch. Any other URL provided must return docker-compose.yaml file contents.  If project already exists, it will be replaced.
     * @summary Create new project
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineDockerManagerUpRequest} vPSV1VirtualMachineDockerManagerUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public createNewProjectV1(virtualMachineId: number, vPSV1VirtualMachineDockerManagerUpRequest: VPSV1VirtualMachineDockerManagerUpRequest, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).createNewProjectV1(virtualMachineId, vPSV1VirtualMachineDockerManagerUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely removes a Docker Compose project from the virtual machine, stopping all containers and cleaning up  associated resources including networks, volumes, and images.   This operation is irreversible and will delete all project data.   Use this when you want to permanently remove a project and free up system resources.
     * @summary Delete project
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public deleteProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).deleteProjectV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all containers belonging to a specific Docker Compose project on the virtual machine.   This endpoint returns detailed information about each container including their current status, port mappings, and runtime configuration.   Use this to monitor the health and state of all services within your Docker Compose project.
     * @summary Get project containers
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public getProjectContainersV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).getProjectContainersV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the complete project information including the docker-compose.yml file contents, project metadata, and current deployment status.   This endpoint provides the full configuration and state details of a specific Docker Compose project.   Use this to inspect project settings, review the compose file, or check the overall project health.
     * @summary Get project contents
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public getProjectContentsV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).getProjectContentsV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all Docker Compose projects currently deployed on the virtual machine.   This endpoint returns basic information about each project including name, status, and file path.   Use this to get an overview of all Docker projects on your VPS instance.
     * @summary Get project list
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public getProjectListV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).getProjectListV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregated log entries from all services within a Docker Compose project.   This endpoint returns recent log output from each container, organized by service name with timestamps.  The response contains the last 300 log entries across all services.   Use this for debugging, monitoring application behavior, and troubleshooting issues across your entire project stack.
     * @summary Get project logs
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public getProjectLogsV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).getProjectLogsV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restarts all services in a Docker Compose project by stopping and starting containers in the correct dependency order.   This operation preserves data volumes and network configurations while refreshing the running containers.   Use this to apply configuration changes or recover from service failures.
     * @summary Restart project
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public restartProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).restartProjectV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts all services in a Docker Compose project that are currently stopped.   This operation brings up containers in the correct dependency order as defined in the compose file.   Use this to resume a project that was previously stopped or to start services after a system reboot.
     * @summary Start project
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public startProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).startProjectV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops all running services in a Docker Compose project while preserving container configurations and data volumes.   This operation gracefully shuts down containers in reverse dependency order.   Use this to temporarily halt a project without removing data or configurations.
     * @summary Stop project
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public stopProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).stopProjectV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Docker Compose project by pulling the latest image versions and recreating containers with new configurations.   This operation preserves data volumes while applying changes from the compose file.   Use this to deploy application updates, apply configuration changes, or refresh container images to their latest versions.
     * @summary Update project
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} projectName Docker Compose project name using alphanumeric characters, dashes, and underscores only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDockerManagerApi
     */
    public updateProjectV1(virtualMachineId: number, projectName: string, options?: RawAxiosRequestConfig) {
        return VPSDockerManagerApiFp(this.configuration).updateProjectV1(virtualMachineId, projectName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSFirewallApi - axios parameter creator
 * @export
 */
export const VPSFirewallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a firewall for a specified virtual machine.  Only one firewall can be active for a virtual machine at a time.  Use this endpoint to apply firewall rules to VPS instances.
         * @summary Activate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateFirewallV1: async (firewallId: number, virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('activateFirewallV1', 'firewallId', firewallId)
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('activateFirewallV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/activate/{virtualMachineId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new firewall rule for a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to add new security rules to firewalls.
         * @summary Create firewall rule
         * @param {number} firewallId Firewall ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleV1: async (firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('createFirewallRuleV1', 'firewallId', firewallId)
            // verify required parameter 'vPSV1FirewallRulesStoreRequest' is not null or undefined
            assertParamExists('createFirewallRuleV1', 'vPSV1FirewallRulesStoreRequest', vPSV1FirewallRulesStoreRequest)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/rules`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1FirewallRulesStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new firewall.  Use this endpoint to set up new firewall configurations for VPS security.
         * @summary Create new firewall
         * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFirewallV1: async (vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1FirewallStoreRequest' is not null or undefined
            assertParamExists('createNewFirewallV1', 'vPSV1FirewallStoreRequest', vPSV1FirewallStoreRequest)
            const localVarPath = `/api/vps/v1/firewall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1FirewallStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a firewall for a specified virtual machine.  Use this endpoint to remove firewall protection from VPS instances.
         * @summary Deactivate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFirewallV1: async (firewallId: number, virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('deactivateFirewallV1', 'firewallId', firewallId)
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deactivateFirewallV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/deactivate/{virtualMachineId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.         Use this endpoint to remove specific firewall rules.
         * @summary Delete firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleV1: async (firewallId: number, ruleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('deleteFirewallRuleV1', 'firewallId', firewallId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('deleteFirewallRuleV1', 'ruleId', ruleId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/rules/{ruleId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specified firewall.  Any virtual machine that has this firewall activated will automatically have it deactivated.  Use this endpoint to remove unused firewall configurations.
         * @summary Delete firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallV1: async (firewallId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('deleteFirewallV1', 'firewallId', firewallId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve firewall by its ID and rules associated with it.  Use this endpoint to view specific firewall configuration and rules.
         * @summary Get firewall details
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallDetailsV1: async (firewallId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('getFirewallDetailsV1', 'firewallId', firewallId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available firewalls.  Use this endpoint to view existing firewall configurations.
         * @summary Get firewall list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallListV1: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/firewall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync a firewall for a specified virtual machine.  Firewall can lose sync with virtual machine if the firewall has new rules added, removed or updated.  Use this endpoint to apply updated firewall rules to VPS instances.
         * @summary Sync firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFirewallV1: async (firewallId: number, virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('syncFirewallV1', 'firewallId', firewallId)
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('syncFirewallV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/sync/{virtualMachineId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to modify existing firewall rules.
         * @summary Update firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleV1: async (firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('updateFirewallRuleV1', 'firewallId', firewallId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('updateFirewallRuleV1', 'ruleId', ruleId)
            // verify required parameter 'vPSV1FirewallRulesStoreRequest' is not null or undefined
            assertParamExists('updateFirewallRuleV1', 'vPSV1FirewallRulesStoreRequest', vPSV1FirewallRulesStoreRequest)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/rules/{ruleId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1FirewallRulesStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSFirewallApi - functional programming interface
 * @export
 */
export const VPSFirewallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSFirewallApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a firewall for a specified virtual machine.  Only one firewall can be active for a virtual machine at a time.  Use this endpoint to apply firewall rules to VPS instances.
         * @summary Activate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateFirewallV1(firewallId, virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.activateFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new firewall rule for a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to add new security rules to firewalls.
         * @summary Create firewall rule
         * @param {number} firewallId Firewall ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleV1(firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallRuleResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleV1(firewallId, vPSV1FirewallRulesStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.createFirewallRuleV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new firewall.  Use this endpoint to set up new firewall configurations for VPS security.
         * @summary Create new firewall
         * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewFirewallV1(vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewFirewallV1(vPSV1FirewallStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.createNewFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate a firewall for a specified virtual machine.  Use this endpoint to remove firewall protection from VPS instances.
         * @summary Deactivate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateFirewallV1(firewallId, virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.deactivateFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.         Use this endpoint to remove specific firewall rules.
         * @summary Delete firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleV1(firewallId: number, ruleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleV1(firewallId, ruleId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.deleteFirewallRuleV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specified firewall.  Any virtual machine that has this firewall activated will automatically have it deactivated.  Use this endpoint to remove unused firewall configurations.
         * @summary Delete firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallV1(firewallId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallV1(firewallId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.deleteFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve firewall by its ID and rules associated with it.  Use this endpoint to view specific firewall configuration and rules.
         * @summary Get firewall details
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallDetailsV1(firewallId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallDetailsV1(firewallId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.getFirewallDetailsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available firewalls.  Use this endpoint to view existing firewall configurations.
         * @summary Get firewall list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallListV1(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetFirewallListV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallListV1(page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.getFirewallListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sync a firewall for a specified virtual machine.  Firewall can lose sync with virtual machine if the firewall has new rules added, removed or updated.  Use this endpoint to apply updated firewall rules to VPS instances.
         * @summary Sync firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncFirewallV1(firewallId, virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.syncFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to modify existing firewall rules.
         * @summary Update firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleV1(firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallRuleResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleV1(firewallId, ruleId, vPSV1FirewallRulesStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.updateFirewallRuleV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSFirewallApi - factory interface
 * @export
 */
export const VPSFirewallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSFirewallApiFp(configuration)
    return {
        /**
         * Activate a firewall for a specified virtual machine.  Only one firewall can be active for a virtual machine at a time.  Use this endpoint to apply firewall rules to VPS instances.
         * @summary Activate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.activateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new firewall rule for a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to add new security rules to firewalls.
         * @summary Create firewall rule
         * @param {number} firewallId Firewall ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleV1(firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallRuleResource> {
            return localVarFp.createFirewallRuleV1(firewallId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new firewall.  Use this endpoint to set up new firewall configurations for VPS security.
         * @summary Create new firewall
         * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFirewallV1(vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallResource> {
            return localVarFp.createNewFirewallV1(vPSV1FirewallStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate a firewall for a specified virtual machine.  Use this endpoint to remove firewall protection from VPS instances.
         * @summary Deactivate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.deactivateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.         Use this endpoint to remove specific firewall rules.
         * @summary Delete firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleV1(firewallId: number, ruleId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteFirewallRuleV1(firewallId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specified firewall.  Any virtual machine that has this firewall activated will automatically have it deactivated.  Use this endpoint to remove unused firewall configurations.
         * @summary Delete firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallV1(firewallId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteFirewallV1(firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve firewall by its ID and rules associated with it.  Use this endpoint to view specific firewall configuration and rules.
         * @summary Get firewall details
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallDetailsV1(firewallId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallResource> {
            return localVarFp.getFirewallDetailsV1(firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available firewalls.  Use this endpoint to view existing firewall configurations.
         * @summary Get firewall list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallListV1(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetFirewallListV1200Response> {
            return localVarFp.getFirewallListV1(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync a firewall for a specified virtual machine.  Firewall can lose sync with virtual machine if the firewall has new rules added, removed or updated.  Use this endpoint to apply updated firewall rules to VPS instances.
         * @summary Sync firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.syncFirewallV1(firewallId, virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to modify existing firewall rules.
         * @summary Update firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleV1(firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallRuleResource> {
            return localVarFp.updateFirewallRuleV1(firewallId, ruleId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSFirewallApi - object-oriented interface
 * @export
 * @class VPSFirewallApi
 * @extends {BaseAPI}
 */
export class VPSFirewallApi extends BaseAPI {
    /**
     * Activate a firewall for a specified virtual machine.  Only one firewall can be active for a virtual machine at a time.  Use this endpoint to apply firewall rules to VPS instances.
     * @summary Activate firewall
     * @param {number} firewallId Firewall ID
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public activateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).activateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new firewall rule for a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to add new security rules to firewalls.
     * @summary Create firewall rule
     * @param {number} firewallId Firewall ID
     * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public createFirewallRuleV1(firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).createFirewallRuleV1(firewallId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new firewall.  Use this endpoint to set up new firewall configurations for VPS security.
     * @summary Create new firewall
     * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public createNewFirewallV1(vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).createNewFirewallV1(vPSV1FirewallStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate a firewall for a specified virtual machine.  Use this endpoint to remove firewall protection from VPS instances.
     * @summary Deactivate firewall
     * @param {number} firewallId Firewall ID
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public deactivateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).deactivateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.         Use this endpoint to remove specific firewall rules.
     * @summary Delete firewall rule
     * @param {number} firewallId Firewall ID
     * @param {number} ruleId Firewall Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public deleteFirewallRuleV1(firewallId: number, ruleId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).deleteFirewallRuleV1(firewallId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specified firewall.  Any virtual machine that has this firewall activated will automatically have it deactivated.  Use this endpoint to remove unused firewall configurations.
     * @summary Delete firewall
     * @param {number} firewallId Firewall ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public deleteFirewallV1(firewallId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).deleteFirewallV1(firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve firewall by its ID and rules associated with it.  Use this endpoint to view specific firewall configuration and rules.
     * @summary Get firewall details
     * @param {number} firewallId Firewall ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public getFirewallDetailsV1(firewallId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).getFirewallDetailsV1(firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available firewalls.  Use this endpoint to view existing firewall configurations.
     * @summary Get firewall list
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public getFirewallListV1(page?: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).getFirewallListV1(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync a firewall for a specified virtual machine.  Firewall can lose sync with virtual machine if the firewall has new rules added, removed or updated.  Use this endpoint to apply updated firewall rules to VPS instances.
     * @summary Sync firewall
     * @param {number} firewallId Firewall ID
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public syncFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).syncFirewallV1(firewallId, virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will lose sync with the firewall and will have to be synced again manually.  Use this endpoint to modify existing firewall rules.
     * @summary Update firewall rule
     * @param {number} firewallId Firewall ID
     * @param {number} ruleId Firewall Rule ID
     * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public updateFirewallRuleV1(firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).updateFirewallRuleV1(firewallId, ruleId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSMalwareScannerApi - axios parameter creator
 * @export
 */
export const VPSMalwareScannerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine.  The scan metrics provide detailed information about malware scans performed by Monarx, including number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring security status of the  virtual machine and assessing effectiveness of the malware scanner.  Use this endpoint to monitor VPS security scan results and threat detection.
         * @summary Get scan metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanMetricsV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getScanMetricsV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/monarx`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install the Monarx malware scanner on a specified virtual machine.  [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.  Use this endpoint to enable malware protection on VPS instances.
         * @summary Install Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installMonarxV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('installMonarxV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/monarx`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uninstall the Monarx malware scanner on a specified virtual machine.  If Monarx is not installed, the request will still be processed without any effect.  Use this endpoint to remove malware scanner from VPS instances.
         * @summary Uninstall Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallMonarxV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('uninstallMonarxV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/monarx`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSMalwareScannerApi - functional programming interface
 * @export
 */
export const VPSMalwareScannerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSMalwareScannerApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine.  The scan metrics provide detailed information about malware scans performed by Monarx, including number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring security status of the  virtual machine and assessing effectiveness of the malware scanner.  Use this endpoint to monitor VPS security scan results and threat detection.
         * @summary Get scan metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanMetricsV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1MalwareMetricsResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanMetricsV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSMalwareScannerApi.getScanMetricsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Install the Monarx malware scanner on a specified virtual machine.  [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.  Use this endpoint to enable malware protection on VPS instances.
         * @summary Install Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installMonarxV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSMalwareScannerApi.installMonarxV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uninstall the Monarx malware scanner on a specified virtual machine.  If Monarx is not installed, the request will still be processed without any effect.  Use this endpoint to remove malware scanner from VPS instances.
         * @summary Uninstall Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallMonarxV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSMalwareScannerApi.uninstallMonarxV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSMalwareScannerApi - factory interface
 * @export
 */
export const VPSMalwareScannerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSMalwareScannerApiFp(configuration)
    return {
        /**
         * Retrieve scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine.  The scan metrics provide detailed information about malware scans performed by Monarx, including number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring security status of the  virtual machine and assessing effectiveness of the malware scanner.  Use this endpoint to monitor VPS security scan results and threat detection.
         * @summary Get scan metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanMetricsV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1MalwareMetricsResource> {
            return localVarFp.getScanMetricsV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Install the Monarx malware scanner on a specified virtual machine.  [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.  Use this endpoint to enable malware protection on VPS instances.
         * @summary Install Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.installMonarxV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uninstall the Monarx malware scanner on a specified virtual machine.  If Monarx is not installed, the request will still be processed without any effect.  Use this endpoint to remove malware scanner from VPS instances.
         * @summary Uninstall Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.uninstallMonarxV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSMalwareScannerApi - object-oriented interface
 * @export
 * @class VPSMalwareScannerApi
 * @extends {BaseAPI}
 */
export class VPSMalwareScannerApi extends BaseAPI {
    /**
     * Retrieve scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine.  The scan metrics provide detailed information about malware scans performed by Monarx, including number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring security status of the  virtual machine and assessing effectiveness of the malware scanner.  Use this endpoint to monitor VPS security scan results and threat detection.
     * @summary Get scan metrics
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSMalwareScannerApi
     */
    public getScanMetricsV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSMalwareScannerApiFp(this.configuration).getScanMetricsV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install the Monarx malware scanner on a specified virtual machine.  [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.  Use this endpoint to enable malware protection on VPS instances.
     * @summary Install Monarx
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSMalwareScannerApi
     */
    public installMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSMalwareScannerApiFp(this.configuration).installMonarxV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uninstall the Monarx malware scanner on a specified virtual machine.  If Monarx is not installed, the request will still be processed without any effect.  Use this endpoint to remove malware scanner from VPS instances.
     * @summary Uninstall Monarx
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSMalwareScannerApi
     */
    public uninstallMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSMalwareScannerApiFp(this.configuration).uninstallMonarxV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSOSTemplatesApi - axios parameter creator
 * @export
 */
export const VPSOSTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve detailed information about a specific OS template for virtual machines.  Use this endpoint to view specific template specifications before deployment.
         * @summary Get template details
         * @param {number} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateDetailsV1: async (templateId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getTemplateDetailsV1', 'templateId', templateId)
            const localVarPath = `/api/vps/v1/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve available OS templates for virtual machines.  Use this endpoint to view operating system options before creating or recreating VPS instances.
         * @summary Get templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplatesV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSOSTemplatesApi - functional programming interface
 * @export
 */
export const VPSOSTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSOSTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve detailed information about a specific OS template for virtual machines.  Use this endpoint to view specific template specifications before deployment.
         * @summary Get template details
         * @param {number} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateDetailsV1(templateId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1TemplateTemplateResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateDetailsV1(templateId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSOSTemplatesApi.getTemplateDetailsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve available OS templates for virtual machines.  Use this endpoint to view operating system options before creating or recreating VPS instances.
         * @summary Get templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplatesV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1TemplateTemplateResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplatesV1(options);
            const localVarOperationServerBasePath = operationServerMap['VPSOSTemplatesApi.getTemplatesV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSOSTemplatesApi - factory interface
 * @export
 */
export const VPSOSTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSOSTemplatesApiFp(configuration)
    return {
        /**
         * Retrieve detailed information about a specific OS template for virtual machines.  Use this endpoint to view specific template specifications before deployment.
         * @summary Get template details
         * @param {number} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateDetailsV1(templateId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1TemplateTemplateResource> {
            return localVarFp.getTemplateDetailsV1(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve available OS templates for virtual machines.  Use this endpoint to view operating system options before creating or recreating VPS instances.
         * @summary Get templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplatesV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1TemplateTemplateResource>> {
            return localVarFp.getTemplatesV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSOSTemplatesApi - object-oriented interface
 * @export
 * @class VPSOSTemplatesApi
 * @extends {BaseAPI}
 */
export class VPSOSTemplatesApi extends BaseAPI {
    /**
     * Retrieve detailed information about a specific OS template for virtual machines.  Use this endpoint to view specific template specifications before deployment.
     * @summary Get template details
     * @param {number} templateId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSOSTemplatesApi
     */
    public getTemplateDetailsV1(templateId: number, options?: RawAxiosRequestConfig) {
        return VPSOSTemplatesApiFp(this.configuration).getTemplateDetailsV1(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve available OS templates for virtual machines.  Use this endpoint to view operating system options before creating or recreating VPS instances.
     * @summary Get templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSOSTemplatesApi
     */
    public getTemplatesV1(options?: RawAxiosRequestConfig) {
        return VPSOSTemplatesApiFp(this.configuration).getTemplatesV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSPTRRecordsApi - axios parameter creator
 * @export
 */
export const VPSPTRRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or update a PTR (Pointer) record for a specified virtual machine.  Use this endpoint to configure reverse DNS lookup for VPS IP addresses.
         * @summary Create PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} ipAddressId IP Address ID
         * @param {VPSV1VirtualMachinePTRStoreRequest} vPSV1VirtualMachinePTRStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPTRRecordV1: async (virtualMachineId: number, ipAddressId: number, vPSV1VirtualMachinePTRStoreRequest: VPSV1VirtualMachinePTRStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('createPTRRecordV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'ipAddressId' is not null or undefined
            assertParamExists('createPTRRecordV1', 'ipAddressId', ipAddressId)
            // verify required parameter 'vPSV1VirtualMachinePTRStoreRequest' is not null or undefined
            assertParamExists('createPTRRecordV1', 'vPSV1VirtualMachinePTRStoreRequest', vPSV1VirtualMachinePTRStoreRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/ptr/{ipAddressId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"ipAddressId"}}`, encodeURIComponent(String(ipAddressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachinePTRStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a PTR (Pointer) record for a specified virtual machine.  Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.  Use this endpoint to remove reverse DNS configuration from VPS instances.
         * @summary Delete PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} ipAddressId IP Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePTRRecordV1: async (virtualMachineId: number, ipAddressId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deletePTRRecordV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'ipAddressId' is not null or undefined
            assertParamExists('deletePTRRecordV1', 'ipAddressId', ipAddressId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/ptr/{ipAddressId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"ipAddressId"}}`, encodeURIComponent(String(ipAddressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSPTRRecordsApi - functional programming interface
 * @export
 */
export const VPSPTRRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSPTRRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or update a PTR (Pointer) record for a specified virtual machine.  Use this endpoint to configure reverse DNS lookup for VPS IP addresses.
         * @summary Create PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} ipAddressId IP Address ID
         * @param {VPSV1VirtualMachinePTRStoreRequest} vPSV1VirtualMachinePTRStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPTRRecordV1(virtualMachineId: number, ipAddressId: number, vPSV1VirtualMachinePTRStoreRequest: VPSV1VirtualMachinePTRStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPTRRecordV1(virtualMachineId, ipAddressId, vPSV1VirtualMachinePTRStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPTRRecordsApi.createPTRRecordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a PTR (Pointer) record for a specified virtual machine.  Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.  Use this endpoint to remove reverse DNS configuration from VPS instances.
         * @summary Delete PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} ipAddressId IP Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePTRRecordV1(virtualMachineId: number, ipAddressId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePTRRecordV1(virtualMachineId, ipAddressId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPTRRecordsApi.deletePTRRecordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSPTRRecordsApi - factory interface
 * @export
 */
export const VPSPTRRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSPTRRecordsApiFp(configuration)
    return {
        /**
         * Create or update a PTR (Pointer) record for a specified virtual machine.  Use this endpoint to configure reverse DNS lookup for VPS IP addresses.
         * @summary Create PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} ipAddressId IP Address ID
         * @param {VPSV1VirtualMachinePTRStoreRequest} vPSV1VirtualMachinePTRStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPTRRecordV1(virtualMachineId: number, ipAddressId: number, vPSV1VirtualMachinePTRStoreRequest: VPSV1VirtualMachinePTRStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.createPTRRecordV1(virtualMachineId, ipAddressId, vPSV1VirtualMachinePTRStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a PTR (Pointer) record for a specified virtual machine.  Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.  Use this endpoint to remove reverse DNS configuration from VPS instances.
         * @summary Delete PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} ipAddressId IP Address ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePTRRecordV1(virtualMachineId: number, ipAddressId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.deletePTRRecordV1(virtualMachineId, ipAddressId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSPTRRecordsApi - object-oriented interface
 * @export
 * @class VPSPTRRecordsApi
 * @extends {BaseAPI}
 */
export class VPSPTRRecordsApi extends BaseAPI {
    /**
     * Create or update a PTR (Pointer) record for a specified virtual machine.  Use this endpoint to configure reverse DNS lookup for VPS IP addresses.
     * @summary Create PTR record
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} ipAddressId IP Address ID
     * @param {VPSV1VirtualMachinePTRStoreRequest} vPSV1VirtualMachinePTRStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPTRRecordsApi
     */
    public createPTRRecordV1(virtualMachineId: number, ipAddressId: number, vPSV1VirtualMachinePTRStoreRequest: VPSV1VirtualMachinePTRStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSPTRRecordsApiFp(this.configuration).createPTRRecordV1(virtualMachineId, ipAddressId, vPSV1VirtualMachinePTRStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a PTR (Pointer) record for a specified virtual machine.  Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.  Use this endpoint to remove reverse DNS configuration from VPS instances.
     * @summary Delete PTR record
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} ipAddressId IP Address ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPTRRecordsApi
     */
    public deletePTRRecordV1(virtualMachineId: number, ipAddressId: number, options?: RawAxiosRequestConfig) {
        return VPSPTRRecordsApiFp(this.configuration).deletePTRRecordV1(virtualMachineId, ipAddressId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSPostInstallScriptsApi - axios parameter creator
 * @export
 */
export const VPSPostInstallScriptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new post-install script to your account, which can then be used after virtual machine installation.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB.  Use this endpoint to create automation scripts for VPS setup tasks.
         * @summary Create post-install script
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostInstallScriptV1: async (vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1PostInstallScriptStoreRequest' is not null or undefined
            assertParamExists('createPostInstallScriptV1', 'vPSV1PostInstallScriptStoreRequest', vPSV1PostInstallScriptStoreRequest)
            const localVarPath = `/api/vps/v1/post-install-scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PostInstallScriptStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a post-install script from your account.         Use this endpoint to remove unused automation scripts.
         * @summary Delete post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostInstallScriptV1: async (postInstallScriptId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postInstallScriptId' is not null or undefined
            assertParamExists('deletePostInstallScriptV1', 'postInstallScriptId', postInstallScriptId)
            const localVarPath = `/api/vps/v1/post-install-scripts/{postInstallScriptId}`
                .replace(`{${"postInstallScriptId"}}`, encodeURIComponent(String(postInstallScriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve post-install script by its ID.  Use this endpoint to view specific automation script details.
         * @summary Get post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptV1: async (postInstallScriptId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postInstallScriptId' is not null or undefined
            assertParamExists('getPostInstallScriptV1', 'postInstallScriptId', postInstallScriptId)
            const localVarPath = `/api/vps/v1/post-install-scripts/{postInstallScriptId}`
                .replace(`{${"postInstallScriptId"}}`, encodeURIComponent(String(postInstallScriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve post-install scripts associated with your account.  Use this endpoint to view available automation scripts for VPS deployment.
         * @summary Get post-install scripts
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptsV1: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/post-install-scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific post-install script.  Use this endpoint to modify existing automation scripts.
         * @summary Update post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostInstallScriptV1: async (postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postInstallScriptId' is not null or undefined
            assertParamExists('updatePostInstallScriptV1', 'postInstallScriptId', postInstallScriptId)
            // verify required parameter 'vPSV1PostInstallScriptStoreRequest' is not null or undefined
            assertParamExists('updatePostInstallScriptV1', 'vPSV1PostInstallScriptStoreRequest', vPSV1PostInstallScriptStoreRequest)
            const localVarPath = `/api/vps/v1/post-install-scripts/{postInstallScriptId}`
                .replace(`{${"postInstallScriptId"}}`, encodeURIComponent(String(postInstallScriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PostInstallScriptStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSPostInstallScriptsApi - functional programming interface
 * @export
 */
export const VPSPostInstallScriptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSPostInstallScriptsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new post-install script to your account, which can then be used after virtual machine installation.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB.  Use this endpoint to create automation scripts for VPS setup tasks.
         * @summary Create post-install script
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.createPostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a post-install script from your account.         Use this endpoint to remove unused automation scripts.
         * @summary Delete post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePostInstallScriptV1(postInstallScriptId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.deletePostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve post-install script by its ID.  Use this endpoint to view specific automation script details.
         * @summary Get post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostInstallScriptV1(postInstallScriptId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.getPostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve post-install scripts associated with your account.  Use this endpoint to view available automation scripts for VPS deployment.
         * @summary Get post-install scripts
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostInstallScriptsV1(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetPostInstallScriptsV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostInstallScriptsV1(page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.getPostInstallScriptsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific post-install script.  Use this endpoint to modify existing automation scripts.
         * @summary Update post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePostInstallScriptV1(postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePostInstallScriptV1(postInstallScriptId, vPSV1PostInstallScriptStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.updatePostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSPostInstallScriptsApi - factory interface
 * @export
 */
export const VPSPostInstallScriptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSPostInstallScriptsApiFp(configuration)
    return {
        /**
         * Add a new post-install script to your account, which can then be used after virtual machine installation.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB.  Use this endpoint to create automation scripts for VPS setup tasks.
         * @summary Create post-install script
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource> {
            return localVarFp.createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a post-install script from your account.         Use this endpoint to remove unused automation scripts.
         * @summary Delete post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deletePostInstallScriptV1(postInstallScriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve post-install script by its ID.  Use this endpoint to view specific automation script details.
         * @summary Get post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource> {
            return localVarFp.getPostInstallScriptV1(postInstallScriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve post-install scripts associated with your account.  Use this endpoint to view available automation scripts for VPS deployment.
         * @summary Get post-install scripts
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptsV1(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetPostInstallScriptsV1200Response> {
            return localVarFp.getPostInstallScriptsV1(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific post-install script.  Use this endpoint to modify existing automation scripts.
         * @summary Update post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostInstallScriptV1(postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource> {
            return localVarFp.updatePostInstallScriptV1(postInstallScriptId, vPSV1PostInstallScriptStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSPostInstallScriptsApi - object-oriented interface
 * @export
 * @class VPSPostInstallScriptsApi
 * @extends {BaseAPI}
 */
export class VPSPostInstallScriptsApi extends BaseAPI {
    /**
     * Add a new post-install script to your account, which can then be used after virtual machine installation.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB.  Use this endpoint to create automation scripts for VPS setup tasks.
     * @summary Create post-install script
     * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a post-install script from your account.         Use this endpoint to remove unused automation scripts.
     * @summary Delete post-install script
     * @param {number} postInstallScriptId Post-install script ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public deletePostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).deletePostInstallScriptV1(postInstallScriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve post-install script by its ID.  Use this endpoint to view specific automation script details.
     * @summary Get post-install script
     * @param {number} postInstallScriptId Post-install script ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public getPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).getPostInstallScriptV1(postInstallScriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve post-install scripts associated with your account.  Use this endpoint to view available automation scripts for VPS deployment.
     * @summary Get post-install scripts
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public getPostInstallScriptsV1(page?: number, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).getPostInstallScriptsV1(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific post-install script.  Use this endpoint to modify existing automation scripts.
     * @summary Update post-install script
     * @param {number} postInstallScriptId Post-install script ID
     * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public updatePostInstallScriptV1(postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).updatePostInstallScriptV1(postInstallScriptId, vPSV1PostInstallScriptStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSPublicKeysApi - axios parameter creator
 * @export
 */
export const VPSPublicKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attach existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.  Use this endpoint to enable SSH key authentication for VPS instances.
         * @summary Attach public key
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicKeyV1: async (virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('attachPublicKeyV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1PublicKeyAttachRequest' is not null or undefined
            assertParamExists('attachPublicKeyV1', 'vPSV1PublicKeyAttachRequest', vPSV1PublicKeyAttachRequest)
            const localVarPath = `/api/vps/v1/public-keys/attach/{virtualMachineId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PublicKeyAttachRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new public key to your account.  Use this endpoint to register SSH keys for VPS authentication.
         * @summary Create public key
         * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyV1: async (vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1PublicKeyStoreRequest' is not null or undefined
            assertParamExists('createPublicKeyV1', 'vPSV1PublicKeyStoreRequest', vPSV1PublicKeyStoreRequest)
            const localVarPath = `/api/vps/v1/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PublicKeyStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public key from your account.   **Deleting public key from account does not remove it from virtual machine**          Use this endpoint to remove unused SSH keys from account.
         * @summary Delete public key
         * @param {number} publicKeyId Public Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKeyV1: async (publicKeyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKeyId' is not null or undefined
            assertParamExists('deletePublicKeyV1', 'publicKeyId', publicKeyId)
            const localVarPath = `/api/vps/v1/public-keys/{publicKeyId}`
                .replace(`{${"publicKeyId"}}`, encodeURIComponent(String(publicKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve public keys associated with your account.  Use this endpoint to view available SSH keys for VPS authentication.
         * @summary Get public keys
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysV1: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSPublicKeysApi - functional programming interface
 * @export
 */
export const VPSPublicKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSPublicKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Attach existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.  Use this endpoint to enable SSH key authentication for VPS instances.
         * @summary Attach public key
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPublicKeyV1(virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPublicKeyV1(virtualMachineId, vPSV1PublicKeyAttachRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.attachPublicKeyV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new public key to your account.  Use this endpoint to register SSH keys for VPS authentication.
         * @summary Create public key
         * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKeyV1(vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PublicKeyPublicKeyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKeyV1(vPSV1PublicKeyStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.createPublicKeyV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a public key from your account.   **Deleting public key from account does not remove it from virtual machine**          Use this endpoint to remove unused SSH keys from account.
         * @summary Delete public key
         * @param {number} publicKeyId Public Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKeyV1(publicKeyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKeyV1(publicKeyId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.deletePublicKeyV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve public keys associated with your account.  Use this endpoint to view available SSH keys for VPS authentication.
         * @summary Get public keys
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeysV1(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetPublicKeysV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeysV1(page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.getPublicKeysV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSPublicKeysApi - factory interface
 * @export
 */
export const VPSPublicKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSPublicKeysApiFp(configuration)
    return {
        /**
         * Attach existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.  Use this endpoint to enable SSH key authentication for VPS instances.
         * @summary Attach public key
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicKeyV1(virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.attachPublicKeyV1(virtualMachineId, vPSV1PublicKeyAttachRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new public key to your account.  Use this endpoint to register SSH keys for VPS authentication.
         * @summary Create public key
         * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKeyV1(vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PublicKeyPublicKeyResource> {
            return localVarFp.createPublicKeyV1(vPSV1PublicKeyStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public key from your account.   **Deleting public key from account does not remove it from virtual machine**          Use this endpoint to remove unused SSH keys from account.
         * @summary Delete public key
         * @param {number} publicKeyId Public Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKeyV1(publicKeyId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deletePublicKeyV1(publicKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve public keys associated with your account.  Use this endpoint to view available SSH keys for VPS authentication.
         * @summary Get public keys
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeysV1(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetPublicKeysV1200Response> {
            return localVarFp.getPublicKeysV1(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSPublicKeysApi - object-oriented interface
 * @export
 * @class VPSPublicKeysApi
 * @extends {BaseAPI}
 */
export class VPSPublicKeysApi extends BaseAPI {
    /**
     * Attach existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.  Use this endpoint to enable SSH key authentication for VPS instances.
     * @summary Attach public key
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public attachPublicKeyV1(virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).attachPublicKeyV1(virtualMachineId, vPSV1PublicKeyAttachRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new public key to your account.  Use this endpoint to register SSH keys for VPS authentication.
     * @summary Create public key
     * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public createPublicKeyV1(vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).createPublicKeyV1(vPSV1PublicKeyStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public key from your account.   **Deleting public key from account does not remove it from virtual machine**          Use this endpoint to remove unused SSH keys from account.
     * @summary Delete public key
     * @param {number} publicKeyId Public Key ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public deletePublicKeyV1(publicKeyId: number, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).deletePublicKeyV1(publicKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve public keys associated with your account.  Use this endpoint to view available SSH keys for VPS authentication.
     * @summary Get public keys
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public getPublicKeysV1(page?: number, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).getPublicKeysV1(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSRecoveryApi - axios parameter creator
 * @export
 */
export const VPSRecoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.  Use this endpoint to enable system rescue operations on VPS instances.
         * @summary Start recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecoveryModeV1: async (virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('startRecoveryModeV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineRecoveryStartRequest' is not null or undefined
            assertParamExists('startRecoveryModeV1', 'vPSV1VirtualMachineRecoveryStartRequest', vPSV1VirtualMachineRecoveryStartRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/recovery`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineRecoveryStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.  Use this endpoint to exit system rescue mode and return VPS to normal operation.
         * @summary Stop recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecoveryModeV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('stopRecoveryModeV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/recovery`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSRecoveryApi - functional programming interface
 * @export
 */
export const VPSRecoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSRecoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.  Use this endpoint to enable system rescue operations on VPS instances.
         * @summary Start recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecoveryModeV1(virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecoveryModeV1(virtualMachineId, vPSV1VirtualMachineRecoveryStartRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSRecoveryApi.startRecoveryModeV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.  Use this endpoint to exit system rescue mode and return VPS to normal operation.
         * @summary Stop recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRecoveryModeV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRecoveryModeV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSRecoveryApi.stopRecoveryModeV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSRecoveryApi - factory interface
 * @export
 */
export const VPSRecoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSRecoveryApiFp(configuration)
    return {
        /**
         * Initiate recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.  Use this endpoint to enable system rescue operations on VPS instances.
         * @summary Start recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecoveryModeV1(virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.startRecoveryModeV1(virtualMachineId, vPSV1VirtualMachineRecoveryStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.  Use this endpoint to exit system rescue mode and return VPS to normal operation.
         * @summary Stop recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecoveryModeV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.stopRecoveryModeV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSRecoveryApi - object-oriented interface
 * @export
 * @class VPSRecoveryApi
 * @extends {BaseAPI}
 */
export class VPSRecoveryApi extends BaseAPI {
    /**
     * Initiate recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.  Use this endpoint to enable system rescue operations on VPS instances.
     * @summary Start recovery mode
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSRecoveryApi
     */
    public startRecoveryModeV1(virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options?: RawAxiosRequestConfig) {
        return VPSRecoveryApiFp(this.configuration).startRecoveryModeV1(virtualMachineId, vPSV1VirtualMachineRecoveryStartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.  Use this endpoint to exit system rescue mode and return VPS to normal operation.
     * @summary Stop recovery mode
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSRecoveryApi
     */
    public stopRecoveryModeV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSRecoveryApiFp(this.configuration).stopRecoveryModeV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSSnapshotsApi - axios parameter creator
 * @export
 */
export const VPSSnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**  Use this endpoint to capture VPS state for backup and recovery purposes.
         * @summary Create snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('createSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a snapshot of a specified virtual machine.  Use this endpoint to remove VPS snapshots.
         * @summary Delete snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deleteSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve snapshot for a specified virtual machine.  Use this endpoint to view current VPS snapshot information.
         * @summary Get snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.  Use this endpoint to revert VPS instances to previous saved states.
         * @summary Restore snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('restoreSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot/restore`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSSnapshotsApi - functional programming interface
 * @export
 */
export const VPSSnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSSnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**  Use this endpoint to capture VPS state for backup and recovery purposes.
         * @summary Create snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.createSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a snapshot of a specified virtual machine.  Use this endpoint to remove VPS snapshots.
         * @summary Delete snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.deleteSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve snapshot for a specified virtual machine.  Use this endpoint to view current VPS snapshot information.
         * @summary Get snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1SnapshotSnapshotResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.getSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.  Use this endpoint to revert VPS instances to previous saved states.
         * @summary Restore snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.restoreSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSSnapshotsApi - factory interface
 * @export
 */
export const VPSSnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSSnapshotsApiFp(configuration)
    return {
        /**
         * Create a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**  Use this endpoint to capture VPS state for backup and recovery purposes.
         * @summary Create snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.createSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a snapshot of a specified virtual machine.  Use this endpoint to remove VPS snapshots.
         * @summary Delete snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.deleteSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve snapshot for a specified virtual machine.  Use this endpoint to view current VPS snapshot information.
         * @summary Get snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1SnapshotSnapshotResource> {
            return localVarFp.getSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.  Use this endpoint to revert VPS instances to previous saved states.
         * @summary Restore snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.restoreSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSSnapshotsApi - object-oriented interface
 * @export
 * @class VPSSnapshotsApi
 * @extends {BaseAPI}
 */
export class VPSSnapshotsApi extends BaseAPI {
    /**
     * Create a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**  Use this endpoint to capture VPS state for backup and recovery purposes.
     * @summary Create snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public createSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).createSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a snapshot of a specified virtual machine.  Use this endpoint to remove VPS snapshots.
     * @summary Delete snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public deleteSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).deleteSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve snapshot for a specified virtual machine.  Use this endpoint to view current VPS snapshot information.
     * @summary Get snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public getSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).getSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.  Use this endpoint to revert VPS instances to previous saved states.
     * @summary Restore snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public restoreSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).restoreSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSVirtualMachineApi - axios parameter creator
 * @export
 */
export const VPSVirtualMachineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve public keys attached to a specified virtual machine.  Use this endpoint to view SSH keys configured for specific VPS instances.
         * @summary Get attached public keys
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachedPublicKeysV1: async (virtualMachineId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getAttachedPublicKeysV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/public-keys`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve historical metrics for a specified virtual machine.  It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime  Use this endpoint to monitor VPS performance and resource utilization over time.
         * @summary Get metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} dateFrom 
         * @param {string} dateTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1: async (virtualMachineId: number, dateFrom: string, dateTo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getMetricsV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('getMetricsV1', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('getMetricsV1', 'dateTo', dateTo)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/metrics`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specified virtual machine.  Use this endpoint to view comprehensive VPS configuration and status.
         * @summary Get virtual machine details
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachineDetailsV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getVirtualMachineDetailsV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available virtual machines.  Use this endpoint to view available VPS instances.
         * @summary Get virtual machines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachinesV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchase and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.  Use this endpoint to create new VPS instances.                        
         * @summary Purchase new virtual machine
         * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewVirtualMachineV1: async (vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1VirtualMachinePurchaseRequest' is not null or undefined
            assertParamExists('purchaseNewVirtualMachineV1', 'vPSV1VirtualMachinePurchaseRequest', vPSV1VirtualMachinePurchaseRequest)
            const localVarPath = `/api/vps/v1/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachinePurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**  Use this endpoint to completely rebuild VPS instances with fresh OS installation.
         * @summary Recreate virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateVirtualMachineV1: async (virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('recreateVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineRecreateRequest' is not null or undefined
            assertParamExists('recreateVirtualMachineV1', 'vPSV1VirtualMachineRecreateRequest', vPSV1VirtualMachineRecreateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/recreate`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineRecreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset hostname and PTR record of a specified virtual machine to default value.  Use this endpoint to restore default hostname configuration for VPS instances.
         * @summary Reset hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetHostnameV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('resetHostnameV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/hostname`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restart a specified virtual machine by fully stopping and starting it.  If the virtual machine was stopped, it will be started.  Use this endpoint to reboot VPS instances.
         * @summary Restart virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartVirtualMachineV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('restartVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/restart`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.  Use this endpoint to configure custom hostnames for VPS instances.
         * @summary Set hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHostnameV1: async (virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setHostnameV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineHostnameUpdateRequest' is not null or undefined
            assertParamExists('setHostnameV1', 'vPSV1VirtualMachineHostnameUpdateRequest', vPSV1VirtualMachineHostnameUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/hostname`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineHostnameUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set nameservers for a specified virtual machine.  Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.  Use this endpoint to configure custom DNS resolvers for VPS instances.
         * @summary Set nameservers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNameserversV1: async (virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setNameserversV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineNameserversUpdateRequest' is not null or undefined
            assertParamExists('setNameserversV1', 'vPSV1VirtualMachineNameserversUpdateRequest', vPSV1VirtualMachineNameserversUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/nameservers`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineNameserversUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to configure control panel access credentials for VPS instances.
         * @summary Set panel password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPanelPasswordV1: async (virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setPanelPasswordV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachinePanelPasswordUpdateRequest' is not null or undefined
            assertParamExists('setPanelPasswordV1', 'vPSV1VirtualMachinePanelPasswordUpdateRequest', vPSV1VirtualMachinePanelPasswordUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/panel-password`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachinePanelPasswordUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set root password for a specified virtual machine.  Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to update administrator credentials for VPS instances.
         * @summary Set root password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRootPasswordV1: async (virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setRootPasswordV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineRootPasswordUpdateRequest' is not null or undefined
            assertParamExists('setRootPasswordV1', 'vPSV1VirtualMachineRootPasswordUpdateRequest', vPSV1VirtualMachineRootPasswordUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/root-password`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineRootPasswordUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Setup newly purchased virtual machine with `initial` state.  Use this endpoint to configure and initialize purchased VPS instances.
         * @summary Setup purchased virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPurchasedVirtualMachineV1: async (virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setupPurchasedVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineSetupRequest' is not null or undefined
            assertParamExists('setupPurchasedVirtualMachineV1', 'vPSV1VirtualMachineSetupRequest', vPSV1VirtualMachineSetupRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/setup`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineSetupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.  Use this endpoint to power on stopped VPS instances.
         * @summary Start virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startVirtualMachineV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('startVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/start`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.  Use this endpoint to power off running VPS instances.
         * @summary Stop virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopVirtualMachineV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('stopVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/stop`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSVirtualMachineApi - functional programming interface
 * @export
 */
export const VPSVirtualMachineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSVirtualMachineApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve public keys attached to a specified virtual machine.  Use this endpoint to view SSH keys configured for specific VPS instances.
         * @summary Get attached public keys
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachedPublicKeysV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetPublicKeysV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachedPublicKeysV1(virtualMachineId, page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getAttachedPublicKeysV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve historical metrics for a specified virtual machine.  It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime  Use this endpoint to monitor VPS performance and resource utilization over time.
         * @summary Get metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} dateFrom 
         * @param {string} dateTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1(virtualMachineId: number, dateFrom: string, dateTo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1MetricsMetricsCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsV1(virtualMachineId, dateFrom, dateTo, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getMetricsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specified virtual machine.  Use this endpoint to view comprehensive VPS configuration and status.
         * @summary Get virtual machine details
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualMachineDetailsV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1VirtualMachineVirtualMachineResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualMachineDetailsV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getVirtualMachineDetailsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available virtual machines.  Use this endpoint to view available VPS instances.
         * @summary Get virtual machines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualMachinesV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1VirtualMachineVirtualMachineResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualMachinesV1(options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getVirtualMachinesV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Purchase and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.  Use this endpoint to create new VPS instances.                        
         * @summary Purchase new virtual machine
         * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingV1OrderVirtualMachineOrderResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.purchaseNewVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**  Use this endpoint to completely rebuild VPS instances with fresh OS installation.
         * @summary Recreate virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recreateVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recreateVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineRecreateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.recreateVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset hostname and PTR record of a specified virtual machine to default value.  Use this endpoint to restore default hostname configuration for VPS instances.
         * @summary Reset hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetHostnameV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetHostnameV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.resetHostnameV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restart a specified virtual machine by fully stopping and starting it.  If the virtual machine was stopped, it will be started.  Use this endpoint to reboot VPS instances.
         * @summary Restart virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartVirtualMachineV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.restartVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.  Use this endpoint to configure custom hostnames for VPS instances.
         * @summary Set hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setHostnameV1(virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setHostnameV1(virtualMachineId, vPSV1VirtualMachineHostnameUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setHostnameV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set nameservers for a specified virtual machine.  Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.  Use this endpoint to configure custom DNS resolvers for VPS instances.
         * @summary Set nameservers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setNameserversV1(virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setNameserversV1(virtualMachineId, vPSV1VirtualMachineNameserversUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setNameserversV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to configure control panel access credentials for VPS instances.
         * @summary Set panel password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPanelPasswordV1(virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPanelPasswordV1(virtualMachineId, vPSV1VirtualMachinePanelPasswordUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setPanelPasswordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set root password for a specified virtual machine.  Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to update administrator credentials for VPS instances.
         * @summary Set root password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRootPasswordV1(virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRootPasswordV1(virtualMachineId, vPSV1VirtualMachineRootPasswordUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setRootPasswordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Setup newly purchased virtual machine with `initial` state.  Use this endpoint to configure and initialize purchased VPS instances.
         * @summary Setup purchased virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupPurchasedVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1VirtualMachineVirtualMachineResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupPurchasedVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineSetupRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setupPurchasedVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.  Use this endpoint to power on stopped VPS instances.
         * @summary Start virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startVirtualMachineV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.startVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.  Use this endpoint to power off running VPS instances.
         * @summary Stop virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopVirtualMachineV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.stopVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSVirtualMachineApi - factory interface
 * @export
 */
export const VPSVirtualMachineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSVirtualMachineApiFp(configuration)
    return {
        /**
         * Retrieve public keys attached to a specified virtual machine.  Use this endpoint to view SSH keys configured for specific VPS instances.
         * @summary Get attached public keys
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachedPublicKeysV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetPublicKeysV1200Response> {
            return localVarFp.getAttachedPublicKeysV1(virtualMachineId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve historical metrics for a specified virtual machine.  It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime  Use this endpoint to monitor VPS performance and resource utilization over time.
         * @summary Get metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} dateFrom 
         * @param {string} dateTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(virtualMachineId: number, dateFrom: string, dateTo: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1MetricsMetricsCollection> {
            return localVarFp.getMetricsV1(virtualMachineId, dateFrom, dateTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specified virtual machine.  Use this endpoint to view comprehensive VPS configuration and status.
         * @summary Get virtual machine details
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachineDetailsV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1VirtualMachineVirtualMachineResource> {
            return localVarFp.getVirtualMachineDetailsV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available virtual machines.  Use this endpoint to view available VPS instances.
         * @summary Get virtual machines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachinesV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1VirtualMachineVirtualMachineResource>> {
            return localVarFp.getVirtualMachinesV1(options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.  Use this endpoint to create new VPS instances.                        
         * @summary Purchase new virtual machine
         * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingV1OrderVirtualMachineOrderResource> {
            return localVarFp.purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**  Use this endpoint to completely rebuild VPS instances with fresh OS installation.
         * @summary Recreate virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.recreateVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineRecreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset hostname and PTR record of a specified virtual machine to default value.  Use this endpoint to restore default hostname configuration for VPS instances.
         * @summary Reset hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetHostnameV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.resetHostnameV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restart a specified virtual machine by fully stopping and starting it.  If the virtual machine was stopped, it will be started.  Use this endpoint to reboot VPS instances.
         * @summary Restart virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.restartVirtualMachineV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.  Use this endpoint to configure custom hostnames for VPS instances.
         * @summary Set hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHostnameV1(virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setHostnameV1(virtualMachineId, vPSV1VirtualMachineHostnameUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set nameservers for a specified virtual machine.  Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.  Use this endpoint to configure custom DNS resolvers for VPS instances.
         * @summary Set nameservers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNameserversV1(virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setNameserversV1(virtualMachineId, vPSV1VirtualMachineNameserversUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to configure control panel access credentials for VPS instances.
         * @summary Set panel password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPanelPasswordV1(virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setPanelPasswordV1(virtualMachineId, vPSV1VirtualMachinePanelPasswordUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set root password for a specified virtual machine.  Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to update administrator credentials for VPS instances.
         * @summary Set root password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRootPasswordV1(virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setRootPasswordV1(virtualMachineId, vPSV1VirtualMachineRootPasswordUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Setup newly purchased virtual machine with `initial` state.  Use this endpoint to configure and initialize purchased VPS instances.
         * @summary Setup purchased virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPurchasedVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1VirtualMachineVirtualMachineResource> {
            return localVarFp.setupPurchasedVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineSetupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.  Use this endpoint to power on stopped VPS instances.
         * @summary Start virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.startVirtualMachineV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.  Use this endpoint to power off running VPS instances.
         * @summary Stop virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.stopVirtualMachineV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSVirtualMachineApi - object-oriented interface
 * @export
 * @class VPSVirtualMachineApi
 * @extends {BaseAPI}
 */
export class VPSVirtualMachineApi extends BaseAPI {
    /**
     * Retrieve public keys attached to a specified virtual machine.  Use this endpoint to view SSH keys configured for specific VPS instances.
     * @summary Get attached public keys
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getAttachedPublicKeysV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getAttachedPublicKeysV1(virtualMachineId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve historical metrics for a specified virtual machine.  It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime  Use this endpoint to monitor VPS performance and resource utilization over time.
     * @summary Get metrics
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} dateFrom 
     * @param {string} dateTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getMetricsV1(virtualMachineId: number, dateFrom: string, dateTo: string, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getMetricsV1(virtualMachineId, dateFrom, dateTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specified virtual machine.  Use this endpoint to view comprehensive VPS configuration and status.
     * @summary Get virtual machine details
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getVirtualMachineDetailsV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getVirtualMachineDetailsV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available virtual machines.  Use this endpoint to view available VPS instances.
     * @summary Get virtual machines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getVirtualMachinesV1(options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getVirtualMachinesV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purchase and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.  Use this endpoint to create new VPS instances.                        
     * @summary Purchase new virtual machine
     * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**  Use this endpoint to completely rebuild VPS instances with fresh OS installation.
     * @summary Recreate virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public recreateVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).recreateVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineRecreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset hostname and PTR record of a specified virtual machine to default value.  Use this endpoint to restore default hostname configuration for VPS instances.
     * @summary Reset hostname
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public resetHostnameV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).resetHostnameV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restart a specified virtual machine by fully stopping and starting it.  If the virtual machine was stopped, it will be started.  Use this endpoint to reboot VPS instances.
     * @summary Restart virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public restartVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).restartVirtualMachineV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.  Use this endpoint to configure custom hostnames for VPS instances.
     * @summary Set hostname
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setHostnameV1(virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setHostnameV1(virtualMachineId, vPSV1VirtualMachineHostnameUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set nameservers for a specified virtual machine.  Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.  Use this endpoint to configure custom DNS resolvers for VPS instances.
     * @summary Set nameservers
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setNameserversV1(virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setNameserversV1(virtualMachineId, vPSV1VirtualMachineNameserversUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to configure control panel access credentials for VPS instances.
     * @summary Set panel password
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setPanelPasswordV1(virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setPanelPasswordV1(virtualMachineId, vPSV1VirtualMachinePanelPasswordUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set root password for a specified virtual machine.  Requirements for password are same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).  Use this endpoint to update administrator credentials for VPS instances.
     * @summary Set root password
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setRootPasswordV1(virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setRootPasswordV1(virtualMachineId, vPSV1VirtualMachineRootPasswordUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Setup newly purchased virtual machine with `initial` state.  Use this endpoint to configure and initialize purchased VPS instances.
     * @summary Setup purchased virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setupPurchasedVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setupPurchasedVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineSetupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.  Use this endpoint to power on stopped VPS instances.
     * @summary Start virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public startVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).startVirtualMachineV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.  Use this endpoint to power off running VPS instances.
     * @summary Stop virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public stopVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).stopVirtualMachineV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



