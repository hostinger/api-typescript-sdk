/* tslint:disable */
/* eslint-disable */
/**
 * Hostinger API
 *
 * API Version: 0.0.68
 *
 * NOTE: This file is auto-generated, DO NOT EDIT THIS FILE MANUALLY!
 * If you want to contribute or request a new feature, please create an issue or pull request on https://github.com/hostinger/api
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BillingCreateNewServiceOrderV1422Response
 */
export interface BillingCreateNewServiceOrderV1422Response {
    /**
     * Validation error message
     * @type {string}
     * @memberof BillingCreateNewServiceOrderV1422Response
     */
    'message': string;
    /**
     * 
     * @type {BillingCreateNewServiceOrderV1422ResponseErrors}
     * @memberof BillingCreateNewServiceOrderV1422Response
     */
    'errors': BillingCreateNewServiceOrderV1422ResponseErrors;
    /**
     * Request correlation ID
     * @type {string}
     * @memberof BillingCreateNewServiceOrderV1422Response
     */
    'correlation_id': string;
}
/**
 * Object of detailed errors for each field
 * @export
 * @interface BillingCreateNewServiceOrderV1422ResponseErrors
 */
export interface BillingCreateNewServiceOrderV1422ResponseErrors {
    /**
     * 
     * @type {Array<any>}
     * @memberof BillingCreateNewServiceOrderV1422ResponseErrors
     */
    'field_1': Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof BillingCreateNewServiceOrderV1422ResponseErrors
     */
    'field_2': Array<any>;
}
/**
 * 
 * @export
 * @interface BillingGetCatalogItemListV1401Response
 */
export interface BillingGetCatalogItemListV1401Response {
    /**
     * Message of the error
     * @type {string}
     * @memberof BillingGetCatalogItemListV1401Response
     */
    'message': string;
    /**
     * Request correlation ID
     * @type {string}
     * @memberof BillingGetCatalogItemListV1401Response
     */
    'correlation_id': string;
}
/**
 * 
 * @export
 * @interface BillingGetCatalogItemListV1500Response
 */
export interface BillingGetCatalogItemListV1500Response {
    /**
     * Message of the error
     * @type {string}
     * @memberof BillingGetCatalogItemListV1500Response
     */
    'message': string;
    /**
     * Request correlation ID
     * @type {string}
     * @memberof BillingGetCatalogItemListV1500Response
     */
    'correlation_id': string;
}
/**
 * 
 * @export
 * @interface BillingV1CatalogCatalogItemPriceResource
 */
export interface BillingV1CatalogCatalogItemPriceResource {
    /**
     * Price item ID
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'id': string;
    /**
     * Price item name
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'name': string;
    /**
     * Currency code
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'currency': string;
    /**
     * Price in cents
     * @type {number}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'price': number;
    /**
     * First period price in cents
     * @type {number}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'first_period_price': number;
    /**
     * Period
     * @type {number}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'period': number;
    /**
     * Period unit
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemPriceResource
     */
    'period_unit': BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum;
}

export const BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year',
    None: 'none'
} as const;

export type BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum = typeof BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum[keyof typeof BillingV1CatalogCatalogItemPriceResourcePeriodUnitEnum];

/**
 * 
 * @export
 * @interface BillingV1CatalogCatalogItemResource
 */
export interface BillingV1CatalogCatalogItemResource {
    /**
     * Catalog item ID
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'category': string;
    /**
     * Array of [`Billing.V1.Catalog.CatalogItemPriceResource`](#model/billingv1catalogcatalogitempriceresource)
     * @type {Array<BillingV1CatalogCatalogItemPriceResource>}
     * @memberof BillingV1CatalogCatalogItemResource
     */
    'prices': Array<BillingV1CatalogCatalogItemPriceResource>;
}
/**
 * 
 * @export
 * @interface BillingV1OrderOrderBillingAddressResource
 */
export interface BillingV1OrderOrderBillingAddressResource {
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'company': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'address_1': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'address_2': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'city': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'state': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'zip': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'country': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderBillingAddressResource
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface BillingV1OrderOrderResource
 */
export interface BillingV1OrderOrderResource {
    /**
     * Order ID
     * @type {number}
     * @memberof BillingV1OrderOrderResource
     */
    'id': number;
    /**
     * Subscription ID
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'subscription_id': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'status': BillingV1OrderOrderResourceStatusEnum;
    /**
     * Currency code
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'currency': string;
    /**
     * Subtotal price (exc. VAT) in cents
     * @type {number}
     * @memberof BillingV1OrderOrderResource
     */
    'subtotal': number;
    /**
     * Total price (inc. VAT) in cents
     * @type {number}
     * @memberof BillingV1OrderOrderResource
     */
    'total': number;
    /**
     * 
     * @type {BillingV1OrderOrderBillingAddressResource}
     * @memberof BillingV1OrderOrderResource
     */
    'billing_address': BillingV1OrderOrderBillingAddressResource;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1OrderOrderResource
     */
    'updated_at': string;
}

export const BillingV1OrderOrderResourceStatusEnum = {
    Completed: 'completed',
    Pending: 'pending',
    Processing: 'processing',
    Failed: 'failed',
    Refunded: 'refunded',
    Cancelled: 'cancelled',
    AwaitingPayment: 'awaiting_payment',
    PaymentInitiated: 'payment_initiated',
    FraudRefund: 'fraud_refund'
} as const;

export type BillingV1OrderOrderResourceStatusEnum = typeof BillingV1OrderOrderResourceStatusEnum[keyof typeof BillingV1OrderOrderResourceStatusEnum];

/**
 * 
 * @export
 * @interface BillingV1OrderStoreRequest
 */
export interface BillingV1OrderStoreRequest {
    /**
     * Payment method ID
     * @type {number}
     * @memberof BillingV1OrderStoreRequest
     */
    'payment_method_id': number;
    /**
     * 
     * @type {Array<BillingV1OrderStoreRequestItemsInner>}
     * @memberof BillingV1OrderStoreRequest
     */
    'items': Array<BillingV1OrderStoreRequestItemsInner>;
    /**
     * Discount coupon codes
     * @type {Array<any>}
     * @memberof BillingV1OrderStoreRequest
     */
    'coupons': Array<any>;
}
/**
 * 
 * @export
 * @interface BillingV1OrderStoreRequestItemsInner
 */
export interface BillingV1OrderStoreRequestItemsInner {
    /**
     * Price Item ID
     * @type {string}
     * @memberof BillingV1OrderStoreRequestItemsInner
     */
    'item_id': string;
    /**
     * 
     * @type {number}
     * @memberof BillingV1OrderStoreRequestItemsInner
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface BillingV1OrderVirtualMachineOrderResource
 */
export interface BillingV1OrderVirtualMachineOrderResource {
    /**
     * 
     * @type {BillingV1OrderOrderResource}
     * @memberof BillingV1OrderVirtualMachineOrderResource
     */
    'order': BillingV1OrderOrderResource;
    /**
     * 
     * @type {VPSV1VirtualMachineVirtualMachineResource}
     * @memberof BillingV1OrderVirtualMachineOrderResource
     */
    'virtual_machine': VPSV1VirtualMachineVirtualMachineResource;
}
/**
 * 
 * @export
 * @interface BillingV1PaymentMethodPaymentMethodResource
 */
export interface BillingV1PaymentMethodPaymentMethodResource {
    /**
     * Payment method ID
     * @type {number}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'payment_method': string;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'is_default': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'is_expired': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'is_suspended': boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1PaymentMethodPaymentMethodResource
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface BillingV1SubscriptionCancelRequest
 */
export interface BillingV1SubscriptionCancelRequest {
    /**
     * Cancellation reason code
     * @type {string}
     * @memberof BillingV1SubscriptionCancelRequest
     */
    'reason_code': BillingV1SubscriptionCancelRequestReasonCodeEnum | null;
    /**
     * Cancellation option
     * @type {string}
     * @memberof BillingV1SubscriptionCancelRequest
     */
    'cancel_option': BillingV1SubscriptionCancelRequestCancelOptionEnum | null;
}

export const BillingV1SubscriptionCancelRequestReasonCodeEnum = {
    Other: 'other'
} as const;

export type BillingV1SubscriptionCancelRequestReasonCodeEnum = typeof BillingV1SubscriptionCancelRequestReasonCodeEnum[keyof typeof BillingV1SubscriptionCancelRequestReasonCodeEnum];
export const BillingV1SubscriptionCancelRequestCancelOptionEnum = {
    Immediately: 'immediately'
} as const;

export type BillingV1SubscriptionCancelRequestCancelOptionEnum = typeof BillingV1SubscriptionCancelRequestCancelOptionEnum[keyof typeof BillingV1SubscriptionCancelRequestCancelOptionEnum];

/**
 * 
 * @export
 * @interface BillingV1SubscriptionSubscriptionResource
 */
export interface BillingV1SubscriptionSubscriptionResource {
    /**
     * Subscription ID
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'status': BillingV1SubscriptionSubscriptionResourceStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'billing_period': number;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'billing_period_unit': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'currency_code': string;
    /**
     * Total price in cents
     * @type {number}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'total_price': number;
    /**
     * Renewal price in cents
     * @type {number}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'renewal_price': number;
    /**
     * 
     * @type {boolean}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'is_auto_renewed': boolean;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'expires_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof BillingV1SubscriptionSubscriptionResource
     */
    'next_billing_at': string | null;
}

export const BillingV1SubscriptionSubscriptionResourceStatusEnum = {
    Active: 'active',
    Paused: 'paused',
    Cancelled: 'cancelled',
    NotRenewing: 'not_renewing',
    Transferred: 'transferred',
    InTrial: 'in_trial',
    Future: 'future'
} as const;

export type BillingV1SubscriptionSubscriptionResourceStatusEnum = typeof BillingV1SubscriptionSubscriptionResourceStatusEnum[keyof typeof BillingV1SubscriptionSubscriptionResourceStatusEnum];

/**
 * 
 * @export
 * @interface CommonSchemaPaginationMetaSchema
 */
export interface CommonSchemaPaginationMetaSchema {
    /**
     * 
     * @type {number}
     * @memberof CommonSchemaPaginationMetaSchema
     */
    'current_page': number;
    /**
     * 
     * @type {number}
     * @memberof CommonSchemaPaginationMetaSchema
     */
    'per_page': number;
    /**
     * 
     * @type {number}
     * @memberof CommonSchemaPaginationMetaSchema
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface CommonSuccessEmptyResource
 */
export interface CommonSuccessEmptyResource {
    /**
     * 
     * @type {string}
     * @memberof CommonSuccessEmptyResource
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DNSV1SnapshotSnapshotResource
 */
export interface DNSV1SnapshotSnapshotResource {
    /**
     * Snapshot ID
     * @type {number}
     * @memberof DNSV1SnapshotSnapshotResource
     */
    'id': number;
    /**
     * Reason of the update
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotResource
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotResource
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface DNSV1SnapshotSnapshotWithContentResource
 */
export interface DNSV1SnapshotSnapshotWithContentResource {
    /**
     * Snapshot ID
     * @type {number}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'id': number;
    /**
     * Reason of the update
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'reason': string;
    /**
     * Array of [`DNS.V1.Zone.RecordResource`](#model/dnsv1zonerecordresource)
     * @type {Array<DNSV1ZoneRecordResource>}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'snapshot': Array<DNSV1ZoneRecordResource>;
    /**
     * 
     * @type {string}
     * @memberof DNSV1SnapshotSnapshotWithContentResource
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneDestroyRequest
 */
export interface DNSV1ZoneDestroyRequest {
    /**
     * Filter records for deletion
     * @type {Array<DNSV1ZoneDestroyRequestFiltersInner>}
     * @memberof DNSV1ZoneDestroyRequest
     */
    'filters': Array<DNSV1ZoneDestroyRequestFiltersInner>;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneDestroyRequestFiltersInner
 */
export interface DNSV1ZoneDestroyRequestFiltersInner {
    /**
     * Name of the record
     * @type {string}
     * @memberof DNSV1ZoneDestroyRequestFiltersInner
     */
    'name': string;
    /**
     * Type of the record
     * @type {string}
     * @memberof DNSV1ZoneDestroyRequestFiltersInner
     */
    'type': DNSV1ZoneDestroyRequestFiltersInnerTypeEnum;
}

export const DNSV1ZoneDestroyRequestFiltersInnerTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Alias: 'ALIAS',
    Mx: 'MX',
    Txt: 'TXT',
    Ns: 'NS',
    Soa: 'SOA',
    Srv: 'SRV',
    Caa: 'CAA'
} as const;

export type DNSV1ZoneDestroyRequestFiltersInnerTypeEnum = typeof DNSV1ZoneDestroyRequestFiltersInnerTypeEnum[keyof typeof DNSV1ZoneDestroyRequestFiltersInnerTypeEnum];

/**
 * 
 * @export
 * @interface DNSV1ZoneNameRecordResource
 */
export interface DNSV1ZoneNameRecordResource {
    /**
     * Content of the name record
     * @type {string}
     * @memberof DNSV1ZoneNameRecordResource
     */
    'content': string;
    /**
     * Flag to mark name record as disabled
     * @type {boolean}
     * @memberof DNSV1ZoneNameRecordResource
     */
    'is_disabled': boolean;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneRecordResource
 */
export interface DNSV1ZoneRecordResource {
    /**
     * Name of the record (use `@` for wildcard name)
     * @type {string}
     * @memberof DNSV1ZoneRecordResource
     */
    'name': string;
    /**
     * Array of [`DNS.V1.Zone.NameRecordResource`](#model/dnsv1zonenamerecordresource)
     * @type {Array<DNSV1ZoneNameRecordResource>}
     * @memberof DNSV1ZoneRecordResource
     */
    'records': Array<DNSV1ZoneNameRecordResource>;
    /**
     * TTL (Time-To-Live) of the record
     * @type {number}
     * @memberof DNSV1ZoneRecordResource
     */
    'ttl': number;
    /**
     * Type of the record
     * @type {string}
     * @memberof DNSV1ZoneRecordResource
     */
    'type': DNSV1ZoneRecordResourceTypeEnum;
}

export const DNSV1ZoneRecordResourceTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Alias: 'ALIAS',
    Mx: 'MX',
    Txt: 'TXT',
    Ns: 'NS',
    Soa: 'SOA',
    Srv: 'SRV',
    Caa: 'CAA'
} as const;

export type DNSV1ZoneRecordResourceTypeEnum = typeof DNSV1ZoneRecordResourceTypeEnum[keyof typeof DNSV1ZoneRecordResourceTypeEnum];

/**
 * 
 * @export
 * @interface DNSV1ZoneResetRequest
 */
export interface DNSV1ZoneResetRequest {
    /**
     * Determines if operation should be run synchronously
     * @type {boolean}
     * @memberof DNSV1ZoneResetRequest
     */
    'sync': boolean;
    /**
     * Determines if email records should be reset
     * @type {boolean}
     * @memberof DNSV1ZoneResetRequest
     */
    'reset_email_records': boolean;
    /**
     * Specifies which record types to not reset
     * @type {Array<string>}
     * @memberof DNSV1ZoneResetRequest
     */
    'whitelisted_record_types': Array<string>;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneUpdateRequest
 */
export interface DNSV1ZoneUpdateRequest {
    /**
     * If `true`, resource records (RRs) matching name and type will be deleted and new RRs will be created, otherwise resource records\' ttl\'s are updated and new records are appended. If no matching RRs are found, they are created.
     * @type {boolean}
     * @memberof DNSV1ZoneUpdateRequest
     */
    'overwrite': boolean;
    /**
     * 
     * @type {Array<DNSV1ZoneUpdateRequestZoneInner>}
     * @memberof DNSV1ZoneUpdateRequest
     */
    'zone': Array<DNSV1ZoneUpdateRequestZoneInner>;
}
/**
 * 
 * @export
 * @interface DNSV1ZoneUpdateRequestZoneInner
 */
export interface DNSV1ZoneUpdateRequestZoneInner {
    /**
     * Name of the record (use `@` for wildcard name)
     * @type {string}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'name': string;
    /**
     * Records assigned to the name
     * @type {Array<DNSV1ZoneUpdateRequestZoneInnerRecordsInner>}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'records': Array<DNSV1ZoneUpdateRequestZoneInnerRecordsInner>;
    /**
     * TTL (Time-To-Live) of the record
     * @type {number}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'ttl': number;
    /**
     * Type of the record
     * @type {string}
     * @memberof DNSV1ZoneUpdateRequestZoneInner
     */
    'type': DNSV1ZoneUpdateRequestZoneInnerTypeEnum;
}

export const DNSV1ZoneUpdateRequestZoneInnerTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Alias: 'ALIAS',
    Mx: 'MX',
    Txt: 'TXT',
    Ns: 'NS',
    Soa: 'SOA',
    Srv: 'SRV',
    Caa: 'CAA'
} as const;

export type DNSV1ZoneUpdateRequestZoneInnerTypeEnum = typeof DNSV1ZoneUpdateRequestZoneInnerTypeEnum[keyof typeof DNSV1ZoneUpdateRequestZoneInnerTypeEnum];

/**
 * 
 * @export
 * @interface DNSV1ZoneUpdateRequestZoneInnerRecordsInner
 */
export interface DNSV1ZoneUpdateRequestZoneInnerRecordsInner {
    /**
     * Content of the name record
     * @type {string}
     * @memberof DNSV1ZoneUpdateRequestZoneInnerRecordsInner
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface DomainsV1AvailabilityAvailabilityRequest
 */
export interface DomainsV1AvailabilityAvailabilityRequest {
    /**
     * Domain name (without TLD)
     * @type {string}
     * @memberof DomainsV1AvailabilityAvailabilityRequest
     */
    'domain': string;
    /**
     * TLDs list
     * @type {Array<string>}
     * @memberof DomainsV1AvailabilityAvailabilityRequest
     */
    'tlds': Array<string>;
    /**
     * Should response include alternatives
     * @type {boolean}
     * @memberof DomainsV1AvailabilityAvailabilityRequest
     */
    'with_alternatives': boolean;
}
/**
 * 
 * @export
 * @interface DomainsV1AvailabilityAvailabilityResource
 */
export interface DomainsV1AvailabilityAvailabilityResource {
    /**
     * Domain name, `null` when not claimed free domain
     * @type {string}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'domain': string | null;
    /**
     * `true` if domain is available for registration
     * @type {boolean}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'is_available': boolean;
    /**
     * `true` if domain is provided as an alternative
     * @type {boolean}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'is_alternative': boolean;
    /**
     * Special rules and/or restrictions applied for registering TLD
     * @type {string}
     * @memberof DomainsV1AvailabilityAvailabilityResource
     */
    'restriction': string | null;
}
/**
 * 
 * @export
 * @interface DomainsV1DomainDomainExtendedResource
 */
export interface DomainsV1DomainDomainExtendedResource {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'domain': string;
    /**
     * Status of the domain
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'status': DomainsV1DomainDomainExtendedResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'message': string | null;
    /**
     * Is privacy protection allowed for the domain
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_privacy_protection_allowed': boolean;
    /**
     * Is privacy protection enabled for the domain
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_privacy_protected': boolean;
    /**
     * Is domain allowed to be locked
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_lockable': boolean;
    /**
     * Is domain locked
     * @type {boolean}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'is_locked': boolean;
    /**
     * 
     * @type {DomainsV1DomainDomainExtendedResourceNameServers}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'name_servers': DomainsV1DomainDomainExtendedResourceNameServers;
    /**
     * Child name servers
     * @type {Array<Array<string>>}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'child_name_servers': Array<Array<string>>;
    /**
     * 
     * @type {DomainsV1DomainDomainExtendedResourceDomainContacts}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'domain_contacts': DomainsV1DomainDomainExtendedResourceDomainContacts;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    '60_days_lock_expires_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'registered_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResource
     */
    'expires_at': string | null;
}

export const DomainsV1DomainDomainExtendedResourceStatusEnum = {
    Active: 'active',
    PendingSetup: 'pending_setup',
    Expired: 'expired',
    Requested: 'requested',
    PendingVerification: 'pending_verification'
} as const;

export type DomainsV1DomainDomainExtendedResourceStatusEnum = typeof DomainsV1DomainDomainExtendedResourceStatusEnum[keyof typeof DomainsV1DomainDomainExtendedResourceStatusEnum];

/**
 * WHOIS profiles
 * @export
 * @interface DomainsV1DomainDomainExtendedResourceDomainContacts
 */
export interface DomainsV1DomainDomainExtendedResourceDomainContacts {
    /**
     * Admin WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'admin_id': number;
    /**
     * Owner WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'owner_id': number;
    /**
     * Billing WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'billing_id': number;
    /**
     * Technician WHOIS profile ID
     * @type {number}
     * @memberof DomainsV1DomainDomainExtendedResourceDomainContacts
     */
    'tech_id': number;
}
/**
 * Name servers
 * @export
 * @interface DomainsV1DomainDomainExtendedResourceNameServers
 */
export interface DomainsV1DomainDomainExtendedResourceNameServers {
    /**
     * Name server 1
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResourceNameServers
     */
    'ns1': string;
    /**
     * Name server 2
     * @type {string}
     * @memberof DomainsV1DomainDomainExtendedResourceNameServers
     */
    'ns2': string;
}
/**
 * 
 * @export
 * @interface DomainsV1DomainDomainResource
 */
export interface DomainsV1DomainDomainResource {
    /**
     * Domain ID
     * @type {number}
     * @memberof DomainsV1DomainDomainResource
     */
    'id': number;
    /**
     * Domain name, `null` when not claimed free domain
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'domain': string | null;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'type': DomainsV1DomainDomainResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'status': DomainsV1DomainDomainResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1DomainDomainResource
     */
    'expires_at': string | null;
}

export const DomainsV1DomainDomainResourceTypeEnum = {
    Domain: 'domain',
    FreeDomain: 'free_domain'
} as const;

export type DomainsV1DomainDomainResourceTypeEnum = typeof DomainsV1DomainDomainResourceTypeEnum[keyof typeof DomainsV1DomainDomainResourceTypeEnum];
export const DomainsV1DomainDomainResourceStatusEnum = {
    Active: 'active',
    PendingSetup: 'pending_setup',
    Expired: 'expired',
    Requested: 'requested',
    PendingVerification: 'pending_verification'
} as const;

export type DomainsV1DomainDomainResourceStatusEnum = typeof DomainsV1DomainDomainResourceStatusEnum[keyof typeof DomainsV1DomainDomainResourceStatusEnum];

/**
 * 
 * @export
 * @interface DomainsV1ForwardingForwardingResource
 */
export interface DomainsV1ForwardingForwardingResource {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'domain': string | null;
    /**
     * Redirect type
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'redirect_type': DomainsV1ForwardingForwardingResourceRedirectTypeEnum;
    /**
     * URL domain is forwarded to
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'redirect_url': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1ForwardingForwardingResource
     */
    'updated_at': string | null;
}

export const DomainsV1ForwardingForwardingResourceRedirectTypeEnum = {
    _301: '301',
    _302: '302'
} as const;

export type DomainsV1ForwardingForwardingResourceRedirectTypeEnum = typeof DomainsV1ForwardingForwardingResourceRedirectTypeEnum[keyof typeof DomainsV1ForwardingForwardingResourceRedirectTypeEnum];

/**
 * 
 * @export
 * @interface DomainsV1ForwardingStoreRequest
 */
export interface DomainsV1ForwardingStoreRequest {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1ForwardingStoreRequest
     */
    'domain': string;
    /**
     * Redirect type
     * @type {string}
     * @memberof DomainsV1ForwardingStoreRequest
     */
    'redirect_type': DomainsV1ForwardingStoreRequestRedirectTypeEnum;
    /**
     * URL to forward domain to
     * @type {string}
     * @memberof DomainsV1ForwardingStoreRequest
     */
    'redirect_url': string;
}

export const DomainsV1ForwardingStoreRequestRedirectTypeEnum = {
    _301: '301',
    _302: '302'
} as const;

export type DomainsV1ForwardingStoreRequestRedirectTypeEnum = typeof DomainsV1ForwardingStoreRequestRedirectTypeEnum[keyof typeof DomainsV1ForwardingStoreRequestRedirectTypeEnum];

/**
 * 
 * @export
 * @interface DomainsV1PortfolioPurchaseRequest
 */
export interface DomainsV1PortfolioPurchaseRequest {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'domain': string;
    /**
     * Catalog price item ID
     * @type {string}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'item_id': string;
    /**
     * Payment method ID, default will be used if not provided
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'payment_method_id': number;
    /**
     * 
     * @type {DomainsV1PortfolioPurchaseRequestDomainContacts}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'domain_contacts': DomainsV1PortfolioPurchaseRequestDomainContacts;
    /**
     * Additional registration data, possible values depends on TLD
     * @type {object}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'additional_details': object;
    /**
     * Discount coupon codes
     * @type {Array<any>}
     * @memberof DomainsV1PortfolioPurchaseRequest
     */
    'coupons': Array<any>;
}
/**
 * Domain contact information
 * @export
 * @interface DomainsV1PortfolioPurchaseRequestDomainContacts
 */
export interface DomainsV1PortfolioPurchaseRequestDomainContacts {
    /**
     * Owner contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'owner_id': number;
    /**
     * Administrative contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'admin_id': number;
    /**
     * Billing contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'billing_id': number;
    /**
     * Technical contact WHOIS record ID
     * @type {number}
     * @memberof DomainsV1PortfolioPurchaseRequestDomainContacts
     */
    'tech_id': number;
}
/**
 * 
 * @export
 * @interface DomainsV1PortfolioUpdateNameserversRequest
 */
export interface DomainsV1PortfolioUpdateNameserversRequest {
    /**
     * First name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns1': string;
    /**
     * Second name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns2': string;
    /**
     * Third name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns3': string;
    /**
     * Fourth name server
     * @type {string}
     * @memberof DomainsV1PortfolioUpdateNameserversRequest
     */
    'ns4': string;
}
/**
 * 
 * @export
 * @interface DomainsV1WHOISProfileResource
 */
export interface DomainsV1WHOISProfileResource {
    /**
     * WHOIS Profile ID
     * @type {number}
     * @memberof DomainsV1WHOISProfileResource
     */
    'id': number;
    /**
     * TLD to which contact profile can be applied to
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'tld': string;
    /**
     * ISO 3166 2-letter country code
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'country': string;
    /**
     * WHOIS profile entity type
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'entity_type': DomainsV1WHOISProfileResourceEntityTypeEnum;
    /**
     * WHOIS profile details
     * @type {object}
     * @memberof DomainsV1WHOISProfileResource
     */
    'whois_details': object;
    /**
     * TLD details
     * @type {object}
     * @memberof DomainsV1WHOISProfileResource
     */
    'tld_details': object;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DomainsV1WHOISProfileResource
     */
    'updated_at': string;
}

export const DomainsV1WHOISProfileResourceEntityTypeEnum = {
    Individual: 'individual',
    Organization: 'organization'
} as const;

export type DomainsV1WHOISProfileResourceEntityTypeEnum = typeof DomainsV1WHOISProfileResourceEntityTypeEnum[keyof typeof DomainsV1WHOISProfileResourceEntityTypeEnum];

/**
 * 
 * @export
 * @interface DomainsV1WHOISStoreRequest
 */
export interface DomainsV1WHOISStoreRequest {
    /**
     * TLD of the domain (without leading dot)
     * @type {string}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'tld': string;
    /**
     * ISO 3166 2-letter country code
     * @type {string}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'country': string;
    /**
     * Legal entity type
     * @type {string}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'entity_type': DomainsV1WHOISStoreRequestEntityTypeEnum;
    /**
     * TLD details
     * @type {object}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'tld_details': object;
    /**
     * WHOIS details
     * @type {object}
     * @memberof DomainsV1WHOISStoreRequest
     */
    'whois_details': object;
}

export const DomainsV1WHOISStoreRequestEntityTypeEnum = {
    Individual: 'individual',
    Organization: 'organization'
} as const;

export type DomainsV1WHOISStoreRequestEntityTypeEnum = typeof DomainsV1WHOISStoreRequestEntityTypeEnum[keyof typeof DomainsV1WHOISStoreRequestEntityTypeEnum];

/**
 * 
 * @export
 * @interface VPSGetActionListV1200Response
 */
export interface VPSGetActionListV1200Response {
    /**
     * Array of [`VPS.V1.Action.ActionResource`](#model/vpsv1actionactionresource)
     * @type {Array<VPSV1ActionActionResource>}
     * @memberof VPSGetActionListV1200Response
     */
    'data': Array<VPSV1ActionActionResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetActionListV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetBackupListV1200Response
 */
export interface VPSGetBackupListV1200Response {
    /**
     * Array of [`VPS.V1.Backup.BackupResource`](#model/vpsv1backupbackupresource)
     * @type {Array<VPSV1BackupBackupResource>}
     * @memberof VPSGetBackupListV1200Response
     */
    'data': Array<VPSV1BackupBackupResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetBackupListV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetFirewallListV1200Response
 */
export interface VPSGetFirewallListV1200Response {
    /**
     * Array of [`VPS.V1.Firewall.FirewallResource`](#model/vpsv1firewallfirewallresource)
     * @type {Array<VPSV1FirewallFirewallResource>}
     * @memberof VPSGetFirewallListV1200Response
     */
    'data': Array<VPSV1FirewallFirewallResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetFirewallListV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetPostInstallScriptListV1200Response
 */
export interface VPSGetPostInstallScriptListV1200Response {
    /**
     * Array of [`VPS.V1.PostInstallScript.PostInstallScriptResource`](#model/vpsv1postinstallscriptpostinstallscriptresource)
     * @type {Array<VPSV1PostInstallScriptPostInstallScriptResource>}
     * @memberof VPSGetPostInstallScriptListV1200Response
     */
    'data': Array<VPSV1PostInstallScriptPostInstallScriptResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetPostInstallScriptListV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSGetPublicKeyListV1200Response
 */
export interface VPSGetPublicKeyListV1200Response {
    /**
     * Array of [`VPS.V1.PublicKey.PublicKeyResource`](#model/vpsv1publickeypublickeyresource)
     * @type {Array<VPSV1PublicKeyPublicKeyResource>}
     * @memberof VPSGetPublicKeyListV1200Response
     */
    'data': Array<VPSV1PublicKeyPublicKeyResource>;
    /**
     * 
     * @type {CommonSchemaPaginationMetaSchema}
     * @memberof VPSGetPublicKeyListV1200Response
     */
    'meta': CommonSchemaPaginationMetaSchema;
}
/**
 * 
 * @export
 * @interface VPSV1ActionActionResource
 */
export interface VPSV1ActionActionResource {
    /**
     * Action ID
     * @type {number}
     * @memberof VPSV1ActionActionResource
     */
    'id': number;
    /**
     * Action name
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'name': string;
    /**
     * Action state
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'state': VPSV1ActionActionResourceStateEnum;
    /**
     * 
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1ActionActionResource
     */
    'updated_at': string;
}

export const VPSV1ActionActionResourceStateEnum = {
    Success: 'success',
    Error: 'error',
    Delayed: 'delayed',
    Sent: 'sent',
    Created: 'created'
} as const;

export type VPSV1ActionActionResourceStateEnum = typeof VPSV1ActionActionResourceStateEnum[keyof typeof VPSV1ActionActionResourceStateEnum];

/**
 * 
 * @export
 * @interface VPSV1BackupBackupResource
 */
export interface VPSV1BackupBackupResource {
    /**
     * Backup ID
     * @type {number}
     * @memberof VPSV1BackupBackupResource
     */
    'id': number;
    /**
     * Location of the backup
     * @type {string}
     * @memberof VPSV1BackupBackupResource
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1BackupBackupResource
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1DataCenterDataCenterResource
 */
export interface VPSV1DataCenterDataCenterResource {
    /**
     * Data center ID
     * @type {number}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'id': number;
    /**
     * Data center name
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'name': string | null;
    /**
     * Data center location country (two letter code)
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'location': string | null;
    /**
     * Data center location city
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'city': string | null;
    /**
     * Data center location continent
     * @type {string}
     * @memberof VPSV1DataCenterDataCenterResource
     */
    'continent': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1FirewallFirewallResource
 */
export interface VPSV1FirewallFirewallResource {
    /**
     * Firewall ID
     * @type {number}
     * @memberof VPSV1FirewallFirewallResource
     */
    'id': number;
    /**
     * Firewall name
     * @type {string}
     * @memberof VPSV1FirewallFirewallResource
     */
    'name': string;
    /**
     * Is current firewall synced with VPS
     * @type {boolean}
     * @memberof VPSV1FirewallFirewallResource
     */
    'is_synced': boolean;
    /**
     * Array of [`VPS.V1.Firewall.FirewallRuleResource`](#model/vpsv1firewallfirewallruleresource)
     * @type {Array<VPSV1FirewallFirewallRuleResource>}
     * @memberof VPSV1FirewallFirewallResource
     */
    'rules': Array<VPSV1FirewallFirewallRuleResource>;
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallFirewallResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallFirewallResource
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1FirewallFirewallRuleResource
 */
export interface VPSV1FirewallFirewallRuleResource {
    /**
     * Firewall rule ID
     * @type {number}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'id': number;
    /**
     * Firewall rule action
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'action': VPSV1FirewallFirewallRuleResourceActionEnum;
    /**
     * Firewall rule protocol
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'protocol': VPSV1FirewallFirewallRuleResourceProtocolEnum;
    /**
     * Firewall rule destination port: single or port range
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'port': string;
    /**
     * Firewall rule source. Can be `any` or `custom`
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'source': string;
    /**
     * Firewall rule source detail. Can be `any` or IP address, CIDR or range
     * @type {string}
     * @memberof VPSV1FirewallFirewallRuleResource
     */
    'source_detail': string;
}

export const VPSV1FirewallFirewallRuleResourceActionEnum = {
    Accept: 'accept',
    Drop: 'drop'
} as const;

export type VPSV1FirewallFirewallRuleResourceActionEnum = typeof VPSV1FirewallFirewallRuleResourceActionEnum[keyof typeof VPSV1FirewallFirewallRuleResourceActionEnum];
export const VPSV1FirewallFirewallRuleResourceProtocolEnum = {
    Tcp: 'TCP',
    Udp: 'UDP',
    Icmp: 'ICMP',
    Gre: 'GRE',
    Any: 'any',
    Esp: 'ESP',
    Ah: 'AH',
    Icmpv6: 'ICMPv6',
    Ssh: 'SSH',
    Http: 'HTTP',
    Https: 'HTTPS',
    MySql: 'MySQL',
    PostgreSql: 'PostgreSQL'
} as const;

export type VPSV1FirewallFirewallRuleResourceProtocolEnum = typeof VPSV1FirewallFirewallRuleResourceProtocolEnum[keyof typeof VPSV1FirewallFirewallRuleResourceProtocolEnum];

/**
 * 
 * @export
 * @interface VPSV1FirewallRulesStoreRequest
 */
export interface VPSV1FirewallRulesStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'protocol': VPSV1FirewallRulesStoreRequestProtocolEnum;
    /**
     * Port or port range, ex: 1024:2048
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'port': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'source': VPSV1FirewallRulesStoreRequestSourceEnum;
    /**
     * IP range, CIDR, single IP or `any`
     * @type {string}
     * @memberof VPSV1FirewallRulesStoreRequest
     */
    'source_detail': string;
}

export const VPSV1FirewallRulesStoreRequestProtocolEnum = {
    Tcp: 'TCP',
    Udp: 'UDP',
    Icmp: 'ICMP',
    Gre: 'GRE',
    Any: 'any',
    Esp: 'ESP',
    Ah: 'AH',
    Icmpv6: 'ICMPv6',
    Ssh: 'SSH',
    Http: 'HTTP',
    Https: 'HTTPS',
    MySql: 'MySQL',
    PostgreSql: 'PostgreSQL'
} as const;

export type VPSV1FirewallRulesStoreRequestProtocolEnum = typeof VPSV1FirewallRulesStoreRequestProtocolEnum[keyof typeof VPSV1FirewallRulesStoreRequestProtocolEnum];
export const VPSV1FirewallRulesStoreRequestSourceEnum = {
    Any: 'any',
    Custom: 'custom'
} as const;

export type VPSV1FirewallRulesStoreRequestSourceEnum = typeof VPSV1FirewallRulesStoreRequestSourceEnum[keyof typeof VPSV1FirewallRulesStoreRequestSourceEnum];

/**
 * 
 * @export
 * @interface VPSV1FirewallStoreRequest
 */
export interface VPSV1FirewallStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1FirewallStoreRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface VPSV1IPAddressIPAddressResource
 */
export interface VPSV1IPAddressIPAddressResource {
    /**
     * IP address ID
     * @type {number}
     * @memberof VPSV1IPAddressIPAddressResource
     */
    'id': number;
    /**
     * IP address: IPv4 or IPv6
     * @type {string}
     * @memberof VPSV1IPAddressIPAddressResource
     */
    'address': string;
    /**
     * IP address PTR record
     * @type {string}
     * @memberof VPSV1IPAddressIPAddressResource
     */
    'ptr': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1MalwareMetricsResource
 */
export interface VPSV1MalwareMetricsResource {
    /**
     * Records found during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'records': number;
    /**
     * Malicious files found during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'malicious': number;
    /**
     * Compromised files found during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'compromised': number;
    /**
     * Total number of files scanned during last scan
     * @type {number}
     * @memberof VPSV1MalwareMetricsResource
     */
    'scanned_files': number;
    /**
     * 
     * @type {string}
     * @memberof VPSV1MalwareMetricsResource
     */
    'scan_started_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1MalwareMetricsResource
     */
    'scan_ended_at': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1MetricsMetricsCollection
 */
export interface VPSV1MetricsMetricsCollection {
    /**
     * 
     * @type {VPSV1MetricsMetricsCollectionCpuUsage}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'cpu_usage': VPSV1MetricsMetricsCollectionCpuUsage | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsCollectionRamUsage}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'ram_usage': VPSV1MetricsMetricsCollectionRamUsage | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsCollectionDiskSpace}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'disk_space': VPSV1MetricsMetricsCollectionDiskSpace | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsCollectionOutgoingTraffic}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'outgoing_traffic': VPSV1MetricsMetricsCollectionOutgoingTraffic | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsCollectionIncomingTraffic}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'incoming_traffic': VPSV1MetricsMetricsCollectionIncomingTraffic | null;
    /**
     * 
     * @type {VPSV1MetricsMetricsCollectionUptime}
     * @memberof VPSV1MetricsMetricsCollection
     */
    'uptime': VPSV1MetricsMetricsCollectionUptime | null;
}
/**
 * @type VPSV1MetricsMetricsCollectionCpuUsage
 * CPU usage in percentage, 0 - 100%
 * @export
 */
export type VPSV1MetricsMetricsCollectionCpuUsage = VPSV1MetricsMetricsResource;

/**
 * @type VPSV1MetricsMetricsCollectionDiskSpace
 * Disk space usage in bytes
 * @export
 */
export type VPSV1MetricsMetricsCollectionDiskSpace = VPSV1MetricsMetricsResource;

/**
 * @type VPSV1MetricsMetricsCollectionIncomingTraffic
 * Incoming traffic in bytes
 * @export
 */
export type VPSV1MetricsMetricsCollectionIncomingTraffic = VPSV1MetricsMetricsResource;

/**
 * @type VPSV1MetricsMetricsCollectionOutgoingTraffic
 * Outgoing traffic in bytes
 * @export
 */
export type VPSV1MetricsMetricsCollectionOutgoingTraffic = VPSV1MetricsMetricsResource;

/**
 * @type VPSV1MetricsMetricsCollectionRamUsage
 * RAM usage in bytes
 * @export
 */
export type VPSV1MetricsMetricsCollectionRamUsage = VPSV1MetricsMetricsResource;

/**
 * @type VPSV1MetricsMetricsCollectionUptime
 * Uptime in milliseconds
 * @export
 */
export type VPSV1MetricsMetricsCollectionUptime = VPSV1MetricsMetricsResource;

/**
 * 
 * @export
 * @interface VPSV1MetricsMetricsResource
 */
export interface VPSV1MetricsMetricsResource {
    /**
     * Measurement unit
     * @type {string}
     * @memberof VPSV1MetricsMetricsResource
     */
    'unit': string;
    /**
     * Object, containing UNIX timestamps as a key and measurement as a value.
     * @type {object}
     * @memberof VPSV1MetricsMetricsResource
     */
    'usage': object;
}
/**
 * 
 * @export
 * @interface VPSV1PostInstallScriptPostInstallScriptResource
 */
export interface VPSV1PostInstallScriptPostInstallScriptResource {
    /**
     * Post-install script ID
     * @type {number}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'id': number;
    /**
     * Name of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'name': string;
    /**
     * Content of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1PostInstallScriptPostInstallScriptResource
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1PostInstallScriptStoreRequest
 */
export interface VPSV1PostInstallScriptStoreRequest {
    /**
     * Name of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptStoreRequest
     */
    'name': string;
    /**
     * Content of the script
     * @type {string}
     * @memberof VPSV1PostInstallScriptStoreRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface VPSV1PublicKeyAttachRequest
 */
export interface VPSV1PublicKeyAttachRequest {
    /**
     * Public Key IDs to attach
     * @type {Array<number>}
     * @memberof VPSV1PublicKeyAttachRequest
     */
    'ids': Array<number>;
}
/**
 * 
 * @export
 * @interface VPSV1PublicKeyPublicKeyResource
 */
export interface VPSV1PublicKeyPublicKeyResource {
    /**
     * Public key ID
     * @type {number}
     * @memberof VPSV1PublicKeyPublicKeyResource
     */
    'id': number;
    /**
     * Public key name
     * @type {string}
     * @memberof VPSV1PublicKeyPublicKeyResource
     */
    'name': string;
    /**
     * Public key content
     * @type {string}
     * @memberof VPSV1PublicKeyPublicKeyResource
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface VPSV1PublicKeyStoreRequest
 */
export interface VPSV1PublicKeyStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1PublicKeyStoreRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1PublicKeyStoreRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface VPSV1SnapshotSnapshotResource
 */
export interface VPSV1SnapshotSnapshotResource {
    /**
     * Snapshot ID
     * @type {number}
     * @memberof VPSV1SnapshotSnapshotResource
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VPSV1SnapshotSnapshotResource
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1SnapshotSnapshotResource
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface VPSV1TemplateTemplateResource
 */
export interface VPSV1TemplateTemplateResource {
    /**
     * Template ID
     * @type {number}
     * @memberof VPSV1TemplateTemplateResource
     */
    'id': number;
    /**
     * Template name
     * @type {string}
     * @memberof VPSV1TemplateTemplateResource
     */
    'name': string;
    /**
     * Template description
     * @type {string}
     * @memberof VPSV1TemplateTemplateResource
     */
    'description': string;
    /**
     * Link to official OS documentation
     * @type {string}
     * @memberof VPSV1TemplateTemplateResource
     */
    'documentation': string | null;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineHostnameUpdateRequest
 */
export interface VPSV1VirtualMachineHostnameUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineHostnameUpdateRequest
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineMetricGetRequest
 */
export interface VPSV1VirtualMachineMetricGetRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineMetricGetRequest
     */
    'date_from': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineMetricGetRequest
     */
    'date_to': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineNameserversUpdateRequest
 */
export interface VPSV1VirtualMachineNameserversUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineNameserversUpdateRequest
     */
    'ns1': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineNameserversUpdateRequest
     */
    'ns2': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachinePanelPasswordUpdateRequest
 */
export interface VPSV1VirtualMachinePanelPasswordUpdateRequest {
    /**
     * Panel password for the virtual machine
     * @type {string}
     * @memberof VPSV1VirtualMachinePanelPasswordUpdateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachinePurchaseRequest
 */
export interface VPSV1VirtualMachinePurchaseRequest {
    /**
     * Catalog price item ID
     * @type {string}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'item_id': string;
    /**
     * Payment method ID, default will be used if not provided
     * @type {number}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'payment_method_id': number;
    /**
     * 
     * @type {VPSV1VirtualMachineSetupRequest}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'setup': VPSV1VirtualMachineSetupRequest;
    /**
     * Discount coupon codes
     * @type {Array<any>}
     * @memberof VPSV1VirtualMachinePurchaseRequest
     */
    'coupons': Array<any>;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineRecoveryStartRequest
 */
export interface VPSV1VirtualMachineRecoveryStartRequest {
    /**
     * Temporary root password for recovery mode
     * @type {string}
     * @memberof VPSV1VirtualMachineRecoveryStartRequest
     */
    'root_password': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineRecreateRequest
 */
export interface VPSV1VirtualMachineRecreateRequest {
    /**
     * Template ID
     * @type {number}
     * @memberof VPSV1VirtualMachineRecreateRequest
     */
    'template_id': number;
    /**
     * Password for the virtual machine. If not provided, random password will be generated. Password will not be shown in the response.
     * @type {string}
     * @memberof VPSV1VirtualMachineRecreateRequest
     */
    'password': string;
    /**
     * Post-install script ID
     * @type {number}
     * @memberof VPSV1VirtualMachineRecreateRequest
     */
    'post_install_script_id': number;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineRootPasswordUpdateRequest
 */
export interface VPSV1VirtualMachineRootPasswordUpdateRequest {
    /**
     * Root password for the virtual machine
     * @type {string}
     * @memberof VPSV1VirtualMachineRootPasswordUpdateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineSetupRequest
 */
export interface VPSV1VirtualMachineSetupRequest {
    /**
     * Template ID
     * @type {number}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'template_id': number;
    /**
     * Data center ID
     * @type {number}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'data_center_id': number;
    /**
     * Post-install script ID
     * @type {number}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'post_install_script_id': number;
    /**
     * Password for the virtual machine. If not provided, random password will be generated. Password will not be shown in the response.
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'password': string;
    /**
     * Override default hostname of the virtual machine
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'hostname': string;
    /**
     * Install Monarx malware scanner (if supported)
     * @type {boolean}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'install_monarx': boolean;
    /**
     * Enable weekly backup schedule
     * @type {boolean}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'enable_backups': boolean;
    /**
     * Name server 1
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'ns1': string;
    /**
     * Name server 2
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'ns2': string;
    /**
     * 
     * @type {VPSV1VirtualMachineSetupRequestPublicKey}
     * @memberof VPSV1VirtualMachineSetupRequest
     */
    'public_key': VPSV1VirtualMachineSetupRequestPublicKey;
}
/**
 * Use SSH key
 * @export
 * @interface VPSV1VirtualMachineSetupRequestPublicKey
 */
export interface VPSV1VirtualMachineSetupRequestPublicKey {
    /**
     * Name of the SSH key
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequestPublicKey
     */
    'name': string;
    /**
     * Contents of the SSH key
     * @type {string}
     * @memberof VPSV1VirtualMachineSetupRequestPublicKey
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface VPSV1VirtualMachineVirtualMachineResource
 */
export interface VPSV1VirtualMachineVirtualMachineResource {
    /**
     * Virtual machine ID
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'id': number;
    /**
     * Active firewall ID, `null` if disabled
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'firewall_group_id': number | null;
    /**
     * Subscription ID
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'subscription_id': string | null;
    /**
     * VPS plan name
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'plan': string | null;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'state': VPSV1VirtualMachineVirtualMachineResourceStateEnum;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'actions_lock': VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum;
    /**
     * CPUs count assigned to virtual machine
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'cpus': number;
    /**
     * Memory available to virtual machine (in megabytes)
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'memory': number;
    /**
     * Virtual machine disk size (in megabytes)
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'disk': number;
    /**
     * Monthly internet traffic available to virtual machine (in megabytes)
     * @type {number}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'bandwidth': number;
    /**
     * Primary DNS resolver
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ns1': string | null;
    /**
     * Secondary DNS resolver
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ns2': string | null;
    /**
     * 
     * @type {VPSV1VirtualMachineVirtualMachineResourceIpv4}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ipv4': VPSV1VirtualMachineVirtualMachineResourceIpv4 | null;
    /**
     * 
     * @type {VPSV1VirtualMachineVirtualMachineResourceIpv6}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'ipv6': VPSV1VirtualMachineVirtualMachineResourceIpv6 | null;
    /**
     * 
     * @type {VPSV1VirtualMachineVirtualMachineResourceTemplate}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'template': VPSV1VirtualMachineVirtualMachineResourceTemplate | null;
    /**
     * 
     * @type {string}
     * @memberof VPSV1VirtualMachineVirtualMachineResource
     */
    'created_at': string;
}

export const VPSV1VirtualMachineVirtualMachineResourceStateEnum = {
    Running: 'running',
    Starting: 'starting',
    Stopping: 'stopping',
    Stopped: 'stopped',
    Creating: 'creating',
    Initial: 'initial',
    Error: 'error',
    Suspending: 'suspending',
    Unsuspending: 'unsuspending',
    Suspended: 'suspended',
    Destroying: 'destroying',
    Destroyed: 'destroyed',
    Recreating: 'recreating',
    Restoring: 'restoring',
    Recovery: 'recovery',
    StoppingRecovery: 'stopping_recovery'
} as const;

export type VPSV1VirtualMachineVirtualMachineResourceStateEnum = typeof VPSV1VirtualMachineVirtualMachineResourceStateEnum[keyof typeof VPSV1VirtualMachineVirtualMachineResourceStateEnum];
export const VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum = {
    Unlocked: 'unlocked',
    Locked: 'locked'
} as const;

export type VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum = typeof VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum[keyof typeof VPSV1VirtualMachineVirtualMachineResourceActionsLockEnum];

/**
 * @type VPSV1VirtualMachineVirtualMachineResourceIpv4
 * IPv4 address of virtual machine
 * @export
 */
export type VPSV1VirtualMachineVirtualMachineResourceIpv4 = Array<VPSV1IPAddressIPAddressResource>;

/**
 * @type VPSV1VirtualMachineVirtualMachineResourceIpv6
 * IPv6 address of virtual machine, `null` if not assigned
 * @export
 */
export type VPSV1VirtualMachineVirtualMachineResourceIpv6 = Array<VPSV1IPAddressIPAddressResource>;

/**
 * @type VPSV1VirtualMachineVirtualMachineResourceTemplate
 * OS template installed in virtual machine
 * @export
 */
export type VPSV1VirtualMachineVirtualMachineResourceTemplate = VPSV1TemplateTemplateResource;


/**
 * BillingCatalogApi - axios parameter creator
 * @export
 */
export const BillingCatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves a list of catalog items available for order.   Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.
         * @summary Get catalog item list
         * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
         * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogItemListV1: async (category?: GetCatalogItemListV1CategoryEnum, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/v1/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingCatalogApi - functional programming interface
 * @export
 */
export const BillingCatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingCatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves a list of catalog items available for order.   Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.
         * @summary Get catalog item list
         * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
         * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogItemListV1(category?: GetCatalogItemListV1CategoryEnum, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingV1CatalogCatalogItemResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogItemListV1(category, name, options);
            const localVarOperationServerBasePath = operationServerMap['BillingCatalogApi.getCatalogItemListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingCatalogApi - factory interface
 * @export
 */
export const BillingCatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingCatalogApiFp(configuration)
    return {
        /**
         * This endpoint retrieves a list of catalog items available for order.   Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.
         * @summary Get catalog item list
         * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
         * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogItemListV1(category?: GetCatalogItemListV1CategoryEnum, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BillingV1CatalogCatalogItemResource>> {
            return localVarFp.getCatalogItemListV1(category, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingCatalogApi - object-oriented interface
 * @export
 * @class BillingCatalogApi
 * @extends {BaseAPI}
 */
export class BillingCatalogApi extends BaseAPI {
    /**
     * This endpoint retrieves a list of catalog items available for order.   Prices in catalog items is displayed as cents (without floating point), e.g: float `17.99` is displayed as integer `1799`.
     * @summary Get catalog item list
     * @param {GetCatalogItemListV1CategoryEnum} [category] Filter catalog items by category
     * @param {string} [name] Filter catalog items by name. Use &#x60;*&#x60; for wildcard search, e.g. &#x60;.COM*&#x60; to find .com domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingCatalogApi
     */
    public getCatalogItemListV1(category?: GetCatalogItemListV1CategoryEnum, name?: string, options?: RawAxiosRequestConfig) {
        return BillingCatalogApiFp(this.configuration).getCatalogItemListV1(category, name, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCatalogItemListV1CategoryEnum = {
    Domain: 'DOMAIN',
    Vps: 'VPS'
} as const;
export type GetCatalogItemListV1CategoryEnum = typeof GetCatalogItemListV1CategoryEnum[keyof typeof GetCatalogItemListV1CategoryEnum];


/**
 * BillingOrdersApi - axios parameter creator
 * @export
 */
export const BillingOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
         * @summary Create new service order
         * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createNewServiceOrderV1: async (billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billingV1OrderStoreRequest' is not null or undefined
            assertParamExists('createNewServiceOrderV1', 'billingV1OrderStoreRequest', billingV1OrderStoreRequest)
            const localVarPath = `/api/billing/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingV1OrderStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingOrdersApi - functional programming interface
 * @export
 */
export const BillingOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
         * @summary Create new service order
         * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createNewServiceOrderV1(billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingV1OrderOrderResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewServiceOrderV1(billingV1OrderStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['BillingOrdersApi.createNewServiceOrderV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingOrdersApi - factory interface
 * @export
 */
export const BillingOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingOrdersApiFp(configuration)
    return {
        /**
         * This endpoint creates a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
         * @summary Create new service order
         * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createNewServiceOrderV1(billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingV1OrderOrderResource> {
            return localVarFp.createNewServiceOrderV1(billingV1OrderStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingOrdersApi - object-oriented interface
 * @export
 * @class BillingOrdersApi
 * @extends {BaseAPI}
 */
export class BillingOrdersApi extends BaseAPI {
    /**
     * This endpoint creates a new service order.   **DEPRECATED**  To purchase a domain, use [`POST /api/domains/v1/portfolio`](/#tag/domains-portfolio/POST/api/domains/v1/portfolio) instead.  To purchase a VPS, use [`POST /api/vps/v1/virtual-machines`](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines) instead.   To place order, you need to provide payment method ID and list of price items from the catalog endpoint together with quantity. Coupons also can be provided during order creation.  Orders created using this endpoint will be set for automatic renewal.  Some `credit_card` payments might need additional verification, rendering purchase unprocessed. We recommend use other payment methods than `credit_card` if you encounter this issue.
     * @summary Create new service order
     * @param {BillingV1OrderStoreRequest} billingV1OrderStoreRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof BillingOrdersApi
     */
    public createNewServiceOrderV1(billingV1OrderStoreRequest: BillingV1OrderStoreRequest, options?: RawAxiosRequestConfig) {
        return BillingOrdersApiFp(this.configuration).createNewServiceOrderV1(billingV1OrderStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingPaymentMethodsApi - axios parameter creator
 * @export
 */
export const BillingPaymentMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint deletes a payment method from your account.
         * @summary Delete payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodV1: async (paymentMethodId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('deletePaymentMethodV1', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/api/billing/v1/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).
         * @summary Get payment method list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/v1/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets default payment method for your account.
         * @summary Set default payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodV1: async (paymentMethodId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('setDefaultPaymentMethodV1', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/api/billing/v1/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingPaymentMethodsApi - functional programming interface
 * @export
 */
export const BillingPaymentMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingPaymentMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint deletes a payment method from your account.
         * @summary Delete payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentMethodV1(paymentMethodId, options);
            const localVarOperationServerBasePath = operationServerMap['BillingPaymentMethodsApi.deletePaymentMethodV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).
         * @summary Get payment method list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingV1PaymentMethodPaymentMethodResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodListV1(options);
            const localVarOperationServerBasePath = operationServerMap['BillingPaymentMethodsApi.getPaymentMethodListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sets default payment method for your account.
         * @summary Set default payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethodV1(paymentMethodId, options);
            const localVarOperationServerBasePath = operationServerMap['BillingPaymentMethodsApi.setDefaultPaymentMethodV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingPaymentMethodsApi - factory interface
 * @export
 */
export const BillingPaymentMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingPaymentMethodsApiFp(configuration)
    return {
        /**
         * This endpoint deletes a payment method from your account.
         * @summary Delete payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deletePaymentMethodV1(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).
         * @summary Get payment method list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<BillingV1PaymentMethodPaymentMethodResource>> {
            return localVarFp.getPaymentMethodListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets default payment method for your account.
         * @summary Set default payment method
         * @param {number} paymentMethodId Payment method ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.setDefaultPaymentMethodV1(paymentMethodId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingPaymentMethodsApi - object-oriented interface
 * @export
 * @class BillingPaymentMethodsApi
 * @extends {BaseAPI}
 */
export class BillingPaymentMethodsApi extends BaseAPI {
    /**
     * This endpoint deletes a payment method from your account.
     * @summary Delete payment method
     * @param {number} paymentMethodId Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPaymentMethodsApi
     */
    public deletePaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig) {
        return BillingPaymentMethodsApiFp(this.configuration).deletePaymentMethodV1(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of available payment methods that can be used for placing new orders.  If you want to add new payment method, please use [hPanel](https://hpanel.hostinger.com/billing/payment-methods).
     * @summary Get payment method list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPaymentMethodsApi
     */
    public getPaymentMethodListV1(options?: RawAxiosRequestConfig) {
        return BillingPaymentMethodsApiFp(this.configuration).getPaymentMethodListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets default payment method for your account.
     * @summary Set default payment method
     * @param {number} paymentMethodId Payment method ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPaymentMethodsApi
     */
    public setDefaultPaymentMethodV1(paymentMethodId: number, options?: RawAxiosRequestConfig) {
        return BillingPaymentMethodsApiFp(this.configuration).setDefaultPaymentMethodV1(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingSubscriptionsApi - axios parameter creator
 * @export
 */
export const BillingSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint cancels a subscription and stops any further billing.
         * @summary Cancel subscription
         * @param {string} subscriptionId Subscription ID
         * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionV1: async (subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('cancelSubscriptionV1', 'subscriptionId', subscriptionId)
            // verify required parameter 'billingV1SubscriptionCancelRequest' is not null or undefined
            assertParamExists('cancelSubscriptionV1', 'billingV1SubscriptionCancelRequest', billingV1SubscriptionCancelRequest)
            const localVarPath = `/api/billing/v1/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingV1SubscriptionCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of all subscriptions associated with your account.
         * @summary Get subscription list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/billing/v1/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingSubscriptionsApi - functional programming interface
 * @export
 */
export const BillingSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint cancels a subscription and stops any further billing.
         * @summary Cancel subscription
         * @param {string} subscriptionId Subscription ID
         * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscriptionV1(subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscriptionV1(subscriptionId, billingV1SubscriptionCancelRequest, options);
            const localVarOperationServerBasePath = operationServerMap['BillingSubscriptionsApi.cancelSubscriptionV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of all subscriptions associated with your account.
         * @summary Get subscription list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BillingV1SubscriptionSubscriptionResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionListV1(options);
            const localVarOperationServerBasePath = operationServerMap['BillingSubscriptionsApi.getSubscriptionListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingSubscriptionsApi - factory interface
 * @export
 */
export const BillingSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingSubscriptionsApiFp(configuration)
    return {
        /**
         * This endpoint cancels a subscription and stops any further billing.
         * @summary Cancel subscription
         * @param {string} subscriptionId Subscription ID
         * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionV1(subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.cancelSubscriptionV1(subscriptionId, billingV1SubscriptionCancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of all subscriptions associated with your account.
         * @summary Get subscription list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<BillingV1SubscriptionSubscriptionResource>> {
            return localVarFp.getSubscriptionListV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingSubscriptionsApi - object-oriented interface
 * @export
 * @class BillingSubscriptionsApi
 * @extends {BaseAPI}
 */
export class BillingSubscriptionsApi extends BaseAPI {
    /**
     * This endpoint cancels a subscription and stops any further billing.
     * @summary Cancel subscription
     * @param {string} subscriptionId Subscription ID
     * @param {BillingV1SubscriptionCancelRequest} billingV1SubscriptionCancelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingSubscriptionsApi
     */
    public cancelSubscriptionV1(subscriptionId: string, billingV1SubscriptionCancelRequest: BillingV1SubscriptionCancelRequest, options?: RawAxiosRequestConfig) {
        return BillingSubscriptionsApiFp(this.configuration).cancelSubscriptionV1(subscriptionId, billingV1SubscriptionCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of all subscriptions associated with your account.
     * @summary Get subscription list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingSubscriptionsApi
     */
    public getSubscriptionListV1(options?: RawAxiosRequestConfig) {
        return BillingSubscriptionsApiFp(this.configuration).getSubscriptionListV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DNSSnapshotApi - axios parameter creator
 * @export
 */
export const DNSSnapshotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves list of DNS snapshots.
         * @summary Get snapshot list
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotListV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getSnapshotListV1', 'domain', domain)
            const localVarPath = `/api/dns/v1/snapshots/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves particular DNS snapshot with the contents of DNS zone records.
         * @summary Get snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotV1: async (domain: string, snapshotId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getSnapshotV1', 'domain', domain)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('getSnapshotV1', 'snapshotId', snapshotId)
            const localVarPath = `/api/dns/v1/snapshots/{domain}/{snapshotId}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint restores DNS zone to the selected snapshot.
         * @summary Restore snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshotV1: async (domain: string, snapshotId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('restoreSnapshotV1', 'domain', domain)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('restoreSnapshotV1', 'snapshotId', snapshotId)
            const localVarPath = `/api/dns/v1/snapshots/{domain}/{snapshotId}/restore`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DNSSnapshotApi - functional programming interface
 * @export
 */
export const DNSSnapshotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DNSSnapshotApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves list of DNS snapshots.
         * @summary Get snapshot list
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotListV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DNSV1SnapshotSnapshotResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotListV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DNSSnapshotApi.getSnapshotListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves particular DNS snapshot with the contents of DNS zone records.
         * @summary Get snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSV1SnapshotSnapshotWithContentResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotV1(domain, snapshotId, options);
            const localVarOperationServerBasePath = operationServerMap['DNSSnapshotApi.getSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint restores DNS zone to the selected snapshot.
         * @summary Restore snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreSnapshotV1(domain, snapshotId, options);
            const localVarOperationServerBasePath = operationServerMap['DNSSnapshotApi.restoreSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DNSSnapshotApi - factory interface
 * @export
 */
export const DNSSnapshotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DNSSnapshotApiFp(configuration)
    return {
        /**
         * This endpoint retrieves list of DNS snapshots.
         * @summary Get snapshot list
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotListV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DNSV1SnapshotSnapshotResource>> {
            return localVarFp.getSnapshotListV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves particular DNS snapshot with the contents of DNS zone records.
         * @summary Get snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): AxiosPromise<DNSV1SnapshotSnapshotWithContentResource> {
            return localVarFp.getSnapshotV1(domain, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint restores DNS zone to the selected snapshot.
         * @summary Restore snapshot
         * @param {string} domain Domain name
         * @param {number} snapshotId Snapshot ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.restoreSnapshotV1(domain, snapshotId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DNSSnapshotApi - object-oriented interface
 * @export
 * @class DNSSnapshotApi
 * @extends {BaseAPI}
 */
export class DNSSnapshotApi extends BaseAPI {
    /**
     * This endpoint retrieves list of DNS snapshots.
     * @summary Get snapshot list
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSSnapshotApi
     */
    public getSnapshotListV1(domain: string, options?: RawAxiosRequestConfig) {
        return DNSSnapshotApiFp(this.configuration).getSnapshotListV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves particular DNS snapshot with the contents of DNS zone records.
     * @summary Get snapshot
     * @param {string} domain Domain name
     * @param {number} snapshotId Snapshot ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSSnapshotApi
     */
    public getSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig) {
        return DNSSnapshotApiFp(this.configuration).getSnapshotV1(domain, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint restores DNS zone to the selected snapshot.
     * @summary Restore snapshot
     * @param {string} domain Domain name
     * @param {number} snapshotId Snapshot ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSSnapshotApi
     */
    public restoreSnapshotV1(domain: string, snapshotId: number, options?: RawAxiosRequestConfig) {
        return DNSSnapshotApiFp(this.configuration).restoreSnapshotV1(domain, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DNSZoneApi - axios parameter creator
 * @export
 */
export const DNSZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint deletes DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.
         * @summary Delete zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZoneRecordsV1: async (domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('deleteZoneRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneDestroyRequest' is not null or undefined
            assertParamExists('deleteZoneRecordsV1', 'dNSV1ZoneDestroyRequest', dNSV1ZoneDestroyRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneDestroyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves DNS zone records for a specific domain.
         * @summary Get records
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordsV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getRecordsV1', 'domain', domain)
            const localVarPath = `/api/dns/v1/zones/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint resets DNS zone to the default records.
         * @summary Reset zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetZoneRecordsV1: async (domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('resetZoneRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneResetRequest' is not null or undefined
            assertParamExists('resetZoneRecordsV1', 'dNSV1ZoneResetRequest', dNSV1ZoneResetRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}/reset`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates DNS records for the selected domain.   Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.
         * @summary Update zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZoneRecordsV1: async (domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('updateZoneRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneUpdateRequest' is not null or undefined
            assertParamExists('updateZoneRecordsV1', 'dNSV1ZoneUpdateRequest', dNSV1ZoneUpdateRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint used to validate DNS records prior update for the selected domain.   If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.
         * @summary Validate zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateZoneRecordsV1: async (domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('validateZoneRecordsV1', 'domain', domain)
            // verify required parameter 'dNSV1ZoneUpdateRequest' is not null or undefined
            assertParamExists('validateZoneRecordsV1', 'dNSV1ZoneUpdateRequest', dNSV1ZoneUpdateRequest)
            const localVarPath = `/api/dns/v1/zones/{domain}/validate`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSV1ZoneUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DNSZoneApi - functional programming interface
 * @export
 */
export const DNSZoneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DNSZoneApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint deletes DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.
         * @summary Delete zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteZoneRecordsV1(domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteZoneRecordsV1(domain, dNSV1ZoneDestroyRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.deleteZoneRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves DNS zone records for a specific domain.
         * @summary Get records
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordsV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DNSV1ZoneRecordResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordsV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.getRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint resets DNS zone to the default records.
         * @summary Reset zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetZoneRecordsV1(domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetZoneRecordsV1(domain, dNSV1ZoneResetRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.resetZoneRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint updates DNS records for the selected domain.   Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.
         * @summary Update zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateZoneRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateZoneRecordsV1(domain, dNSV1ZoneUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.updateZoneRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint used to validate DNS records prior update for the selected domain.   If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.
         * @summary Validate zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateZoneRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateZoneRecordsV1(domain, dNSV1ZoneUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DNSZoneApi.validateZoneRecordsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DNSZoneApi - factory interface
 * @export
 */
export const DNSZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DNSZoneApiFp(configuration)
    return {
        /**
         * This endpoint deletes DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.
         * @summary Delete zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZoneRecordsV1(domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteZoneRecordsV1(domain, dNSV1ZoneDestroyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves DNS zone records for a specific domain.
         * @summary Get records
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordsV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DNSV1ZoneRecordResource>> {
            return localVarFp.getRecordsV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint resets DNS zone to the default records.
         * @summary Reset zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetZoneRecordsV1(domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.resetZoneRecordsV1(domain, dNSV1ZoneResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates DNS records for the selected domain.   Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.
         * @summary Update zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZoneRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.updateZoneRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint used to validate DNS records prior update for the selected domain.   If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.
         * @summary Validate zone records
         * @param {string} domain Domain name
         * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateZoneRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.validateZoneRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DNSZoneApi - object-oriented interface
 * @export
 * @class DNSZoneApi
 * @extends {BaseAPI}
 */
export class DNSZoneApi extends BaseAPI {
    /**
     * This endpoint deletes DNS records for the selected domain.  To filter which records to delete, add the `name` of the record and `type` to the filter.  Multiple filters can be provided with single request.  If you have multiple records with the same name and type, and you want to delete only part of them, refer to the `Update zone records` endpoint.
     * @summary Delete zone records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneDestroyRequest} dNSV1ZoneDestroyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public deleteZoneRecordsV1(domain: string, dNSV1ZoneDestroyRequest: DNSV1ZoneDestroyRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).deleteZoneRecordsV1(domain, dNSV1ZoneDestroyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves DNS zone records for a specific domain.
     * @summary Get records
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public getRecordsV1(domain: string, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).getRecordsV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint resets DNS zone to the default records.
     * @summary Reset zone records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneResetRequest} dNSV1ZoneResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public resetZoneRecordsV1(domain: string, dNSV1ZoneResetRequest: DNSV1ZoneResetRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).resetZoneRecordsV1(domain, dNSV1ZoneResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates DNS records for the selected domain.   Using `overwrite = true` will replace existing records with the provided ones.  Otherwise existing records will be updated and new records will be added.
     * @summary Update zone records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public updateZoneRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).updateZoneRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint used to validate DNS records prior update for the selected domain.   If the validation is successful, the response will contain `200 Success` code. If there is validation error, the response will fail with `422 Validation error` code.
     * @summary Validate zone records
     * @param {string} domain Domain name
     * @param {DNSV1ZoneUpdateRequest} dNSV1ZoneUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSZoneApi
     */
    public validateZoneRecordsV1(domain: string, dNSV1ZoneUpdateRequest: DNSV1ZoneUpdateRequest, options?: RawAxiosRequestConfig) {
        return DNSZoneApiFp(this.configuration).validateZoneRecordsV1(domain, dNSV1ZoneUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsAvailabilityApi - axios parameter creator
 * @export
 */
export const DomainsAvailabilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint checks the availability of a domain name. Multiple TLDs can be checked at once. If you want to get alternative domains with response, provide only one TLD in the request and set `with_alternatives` to `true`. TLDs should be provided without the leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.
         * @summary Check domain availability
         * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailabilityV1: async (domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1AvailabilityAvailabilityRequest' is not null or undefined
            assertParamExists('checkDomainAvailabilityV1', 'domainsV1AvailabilityAvailabilityRequest', domainsV1AvailabilityAvailabilityRequest)
            const localVarPath = `/api/domains/v1/availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1AvailabilityAvailabilityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsAvailabilityApi - functional programming interface
 * @export
 */
export const DomainsAvailabilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsAvailabilityApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint checks the availability of a domain name. Multiple TLDs can be checked at once. If you want to get alternative domains with response, provide only one TLD in the request and set `with_alternatives` to `true`. TLDs should be provided without the leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.
         * @summary Check domain availability
         * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainsV1AvailabilityAvailabilityResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsAvailabilityApi.checkDomainAvailabilityV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsAvailabilityApi - factory interface
 * @export
 */
export const DomainsAvailabilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsAvailabilityApiFp(configuration)
    return {
        /**
         * This endpoint checks the availability of a domain name. Multiple TLDs can be checked at once. If you want to get alternative domains with response, provide only one TLD in the request and set `with_alternatives` to `true`. TLDs should be provided without the leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.
         * @summary Check domain availability
         * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DomainsV1AvailabilityAvailabilityResource>> {
            return localVarFp.checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsAvailabilityApi - object-oriented interface
 * @export
 * @class DomainsAvailabilityApi
 * @extends {BaseAPI}
 */
export class DomainsAvailabilityApi extends BaseAPI {
    /**
     * This endpoint checks the availability of a domain name. Multiple TLDs can be checked at once. If you want to get alternative domains with response, provide only one TLD in the request and set `with_alternatives` to `true`. TLDs should be provided without the leading dot (e.g. `com`, `net`, `org`).  Endpoint has rate limit of 10 requests per minute.
     * @summary Check domain availability
     * @param {DomainsV1AvailabilityAvailabilityRequest} domainsV1AvailabilityAvailabilityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsAvailabilityApi
     */
    public checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest: DomainsV1AvailabilityAvailabilityRequest, options?: RawAxiosRequestConfig) {
        return DomainsAvailabilityApiFp(this.configuration).checkDomainAvailabilityV1(domainsV1AvailabilityAvailabilityRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsForwardingApi - axios parameter creator
 * @export
 */
export const DomainsForwardingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates domain forwarding data.
         * @summary Create forwarding data
         * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForwardingDataV1: async (domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1ForwardingStoreRequest' is not null or undefined
            assertParamExists('createForwardingDataV1', 'domainsV1ForwardingStoreRequest', domainsV1ForwardingStoreRequest)
            const localVarPath = `/api/domains/v1/forwarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1ForwardingStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes domain forwarding data.
         * @summary Delete forwarding data
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForwardingDataV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('deleteForwardingDataV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/forwarding/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves domain forwarding data.
         * @summary Get forwarding data
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForwardingDataV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getForwardingDataV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/forwarding/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsForwardingApi - functional programming interface
 * @export
 */
export const DomainsForwardingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsForwardingApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates domain forwarding data.
         * @summary Create forwarding data
         * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForwardingDataV1(domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1ForwardingForwardingResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForwardingDataV1(domainsV1ForwardingStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsForwardingApi.createForwardingDataV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes domain forwarding data.
         * @summary Delete forwarding data
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteForwardingDataV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteForwardingDataV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsForwardingApi.deleteForwardingDataV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves domain forwarding data.
         * @summary Get forwarding data
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForwardingDataV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1ForwardingForwardingResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForwardingDataV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsForwardingApi.getForwardingDataV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsForwardingApi - factory interface
 * @export
 */
export const DomainsForwardingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsForwardingApiFp(configuration)
    return {
        /**
         * This endpoint creates domain forwarding data.
         * @summary Create forwarding data
         * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForwardingDataV1(domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1ForwardingForwardingResource> {
            return localVarFp.createForwardingDataV1(domainsV1ForwardingStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes domain forwarding data.
         * @summary Delete forwarding data
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForwardingDataV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteForwardingDataV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves domain forwarding data.
         * @summary Get forwarding data
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForwardingDataV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1ForwardingForwardingResource> {
            return localVarFp.getForwardingDataV1(domain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsForwardingApi - object-oriented interface
 * @export
 * @class DomainsForwardingApi
 * @extends {BaseAPI}
 */
export class DomainsForwardingApi extends BaseAPI {
    /**
     * This endpoint creates domain forwarding data.
     * @summary Create forwarding data
     * @param {DomainsV1ForwardingStoreRequest} domainsV1ForwardingStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsForwardingApi
     */
    public createForwardingDataV1(domainsV1ForwardingStoreRequest: DomainsV1ForwardingStoreRequest, options?: RawAxiosRequestConfig) {
        return DomainsForwardingApiFp(this.configuration).createForwardingDataV1(domainsV1ForwardingStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes domain forwarding data.
     * @summary Delete forwarding data
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsForwardingApi
     */
    public deleteForwardingDataV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsForwardingApiFp(this.configuration).deleteForwardingDataV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves domain forwarding data.
     * @summary Get forwarding data
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsForwardingApi
     */
    public getForwardingDataV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsForwardingApiFp(this.configuration).getForwardingDataV1(domain, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsPortfolioApi - axios parameter creator
 * @export
 */
export const DomainsPortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint disables domain lock for the domain. Domain lock needs to be disabled  before transferring the domain to another registrar.
         * @summary Disable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableDomainLockV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('disableDomainLockV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/domain-lock`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint disables privacy protection for the domain. When privacy protection is disabled, the domain owner\'s personal information is visible in the public WHOIS database.
         * @summary Disable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePrivacyProtectionV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('disablePrivacyProtectionV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/privacy-protection`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables domain lock for the domain. When domain lock is enabled,  the domain cannot be transferred to another registrar without first disabling the lock.
         * @summary Enable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableDomainLockV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('enableDomainLockV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/domain-lock`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables privacy protection for the domain. When privacy protection is enabled, the domain owner\'s personal information is hidden from the public WHOIS database.
         * @summary Enable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePrivacyProtectionV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('enablePrivacyProtectionV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/privacy-protection`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of all domains associated with your account.
         * @summary Get domain list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/domains/v1/portfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves details for specified domain.
         * @summary Get domain
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainV1: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDomainV1', 'domain', domain)
            const localVarPath = `/api/domains/v1/portfolio/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to buy (purchase) and register a new domain name.   If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check the domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, the default contact information for that TLD (Top-Level Domain) will be used.  Before making a request, ensure that WHOIS information for the desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing the purchase. The required additional details vary by TLD.
         * @summary Purchase new domain
         * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewDomainV1: async (domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1PortfolioPurchaseRequest' is not null or undefined
            assertParamExists('purchaseNewDomainV1', 'domainsV1PortfolioPurchaseRequest', domainsV1PortfolioPurchaseRequest)
            const localVarPath = `/api/domains/v1/portfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1PortfolioPurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets the nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable. 
         * @summary Update nameservers
         * @param {string} domain Domain name
         * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNameserversV1: async (domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('updateNameserversV1', 'domain', domain)
            // verify required parameter 'domainsV1PortfolioUpdateNameserversRequest' is not null or undefined
            assertParamExists('updateNameserversV1', 'domainsV1PortfolioUpdateNameserversRequest', domainsV1PortfolioUpdateNameserversRequest)
            const localVarPath = `/api/domains/v1/portfolio/{domain}/nameservers`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1PortfolioUpdateNameserversRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsPortfolioApi - functional programming interface
 * @export
 */
export const DomainsPortfolioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsPortfolioApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint disables domain lock for the domain. Domain lock needs to be disabled  before transferring the domain to another registrar.
         * @summary Disable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableDomainLockV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.disableDomainLockV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint disables privacy protection for the domain. When privacy protection is disabled, the domain owner\'s personal information is visible in the public WHOIS database.
         * @summary Disable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disablePrivacyProtectionV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.disablePrivacyProtectionV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint enables domain lock for the domain. When domain lock is enabled,  the domain cannot be transferred to another registrar without first disabling the lock.
         * @summary Enable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableDomainLockV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.enableDomainLockV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint enables privacy protection for the domain. When privacy protection is enabled, the domain owner\'s personal information is hidden from the public WHOIS database.
         * @summary Enable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enablePrivacyProtectionV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.enablePrivacyProtectionV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of all domains associated with your account.
         * @summary Get domain list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainsV1DomainDomainResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainListV1(options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.getDomainListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves details for specified domain.
         * @summary Get domain
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainV1(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1DomainDomainExtendedResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainV1(domain, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.getDomainV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to buy (purchase) and register a new domain name.   If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check the domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, the default contact information for that TLD (Top-Level Domain) will be used.  Before making a request, ensure that WHOIS information for the desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing the purchase. The required additional details vary by TLD.
         * @summary Purchase new domain
         * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingV1OrderOrderResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.purchaseNewDomainV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sets the nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable. 
         * @summary Update nameservers
         * @param {string} domain Domain name
         * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNameserversV1(domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNameserversV1(domain, domainsV1PortfolioUpdateNameserversRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsPortfolioApi.updateNameserversV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsPortfolioApi - factory interface
 * @export
 */
export const DomainsPortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsPortfolioApiFp(configuration)
    return {
        /**
         * This endpoint disables domain lock for the domain. Domain lock needs to be disabled  before transferring the domain to another registrar.
         * @summary Disable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.disableDomainLockV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint disables privacy protection for the domain. When privacy protection is disabled, the domain owner\'s personal information is visible in the public WHOIS database.
         * @summary Disable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.disablePrivacyProtectionV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables domain lock for the domain. When domain lock is enabled,  the domain cannot be transferred to another registrar without first disabling the lock.
         * @summary Enable domain lock
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableDomainLockV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.enableDomainLockV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables privacy protection for the domain. When privacy protection is enabled, the domain owner\'s personal information is hidden from the public WHOIS database.
         * @summary Enable privacy protection
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.enablePrivacyProtectionV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of all domains associated with your account.
         * @summary Get domain list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<DomainsV1DomainDomainResource>> {
            return localVarFp.getDomainListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves details for specified domain.
         * @summary Get domain
         * @param {string} domain Domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainV1(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1DomainDomainExtendedResource> {
            return localVarFp.getDomainV1(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to buy (purchase) and register a new domain name.   If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check the domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, the default contact information for that TLD (Top-Level Domain) will be used.  Before making a request, ensure that WHOIS information for the desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing the purchase. The required additional details vary by TLD.
         * @summary Purchase new domain
         * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingV1OrderOrderResource> {
            return localVarFp.purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets the nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable. 
         * @summary Update nameservers
         * @param {string} domain Domain name
         * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNameserversV1(domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.updateNameserversV1(domain, domainsV1PortfolioUpdateNameserversRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsPortfolioApi - object-oriented interface
 * @export
 * @class DomainsPortfolioApi
 * @extends {BaseAPI}
 */
export class DomainsPortfolioApi extends BaseAPI {
    /**
     * This endpoint disables domain lock for the domain. Domain lock needs to be disabled  before transferring the domain to another registrar.
     * @summary Disable domain lock
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public disableDomainLockV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).disableDomainLockV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint disables privacy protection for the domain. When privacy protection is disabled, the domain owner\'s personal information is visible in the public WHOIS database.
     * @summary Disable privacy protection
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public disablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).disablePrivacyProtectionV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables domain lock for the domain. When domain lock is enabled,  the domain cannot be transferred to another registrar without first disabling the lock.
     * @summary Enable domain lock
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public enableDomainLockV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).enableDomainLockV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables privacy protection for the domain. When privacy protection is enabled, the domain owner\'s personal information is hidden from the public WHOIS database.
     * @summary Enable privacy protection
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public enablePrivacyProtectionV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).enablePrivacyProtectionV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of all domains associated with your account.
     * @summary Get domain list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public getDomainListV1(options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).getDomainListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves details for specified domain.
     * @summary Get domain
     * @param {string} domain Domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public getDomainV1(domain: string, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).getDomainV1(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to buy (purchase) and register a new domain name.   If registration fails, login to [hPanel](https://hpanel.hostinger.com/) and check the domain registration status.  If no payment method is provided, your default payment method will be used automatically.  If no WHOIS information is provided, the default contact information for that TLD (Top-Level Domain) will be used.  Before making a request, ensure that WHOIS information for the desired TLD exists in your account.  Some TLDs require `additional_details` to be provided and these will be validated before completing the purchase. The required additional details vary by TLD.
     * @summary Purchase new domain
     * @param {DomainsV1PortfolioPurchaseRequest} domainsV1PortfolioPurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest: DomainsV1PortfolioPurchaseRequest, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).purchaseNewDomainV1(domainsV1PortfolioPurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets the nameservers for a specified domain.  Be aware, that improper nameserver configuration can lead to the domain being unresolvable or unavailable. 
     * @summary Update nameservers
     * @param {string} domain Domain name
     * @param {DomainsV1PortfolioUpdateNameserversRequest} domainsV1PortfolioUpdateNameserversRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsPortfolioApi
     */
    public updateNameserversV1(domain: string, domainsV1PortfolioUpdateNameserversRequest: DomainsV1PortfolioUpdateNameserversRequest, options?: RawAxiosRequestConfig) {
        return DomainsPortfolioApiFp(this.configuration).updateNameserversV1(domain, domainsV1PortfolioUpdateNameserversRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsWHOISApi - axios parameter creator
 * @export
 */
export const DomainsWHOISApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates WHOIS contact profile.
         * @summary Create WHOIS profile
         * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWHOISProfileV1: async (domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainsV1WHOISStoreRequest' is not null or undefined
            assertParamExists('createWHOISProfileV1', 'domainsV1WHOISStoreRequest', domainsV1WHOISStoreRequest)
            const localVarPath = `/api/domains/v1/whois`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainsV1WHOISStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes WHOIS contact profile.
         * @summary Delete WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWHOISProfileV1: async (whoisId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whoisId' is not null or undefined
            assertParamExists('deleteWHOISProfileV1', 'whoisId', whoisId)
            const localVarPath = `/api/domains/v1/whois/{whoisId}`
                .replace(`{${"whoisId"}}`, encodeURIComponent(String(whoisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of WHOIS contact profiles.
         * @summary Get WHOIS profile list
         * @param {string} [tld] Filter by TLD (without leading dot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileListV1: async (tld?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/domains/v1/whois`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tld !== undefined) {
                localVarQueryParameter['tld'] = tld;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a domain list where provided WHOIS contact profile is used.
         * @summary Get WHOIS profile usage
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileUsageV1: async (whoisId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whoisId' is not null or undefined
            assertParamExists('getWHOISProfileUsageV1', 'whoisId', whoisId)
            const localVarPath = `/api/domains/v1/whois/{whoisId}/usage`
                .replace(`{${"whoisId"}}`, encodeURIComponent(String(whoisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a WHOIS contact profile.
         * @summary Get WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileV1: async (whoisId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'whoisId' is not null or undefined
            assertParamExists('getWHOISProfileV1', 'whoisId', whoisId)
            const localVarPath = `/api/domains/v1/whois/{whoisId}`
                .replace(`{${"whoisId"}}`, encodeURIComponent(String(whoisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsWHOISApi - functional programming interface
 * @export
 */
export const DomainsWHOISApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsWHOISApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates WHOIS contact profile.
         * @summary Create WHOIS profile
         * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWHOISProfileV1(domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1WHOISProfileResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWHOISProfileV1(domainsV1WHOISStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.createWHOISProfileV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes WHOIS contact profile.
         * @summary Delete WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWHOISProfileV1(whoisId, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.deleteWHOISProfileV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of WHOIS contact profiles.
         * @summary Get WHOIS profile list
         * @param {string} [tld] Filter by TLD (without leading dot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWHOISProfileListV1(tld?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainsV1WHOISProfileResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWHOISProfileListV1(tld, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.getWHOISProfileListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a domain list where provided WHOIS contact profile is used.
         * @summary Get WHOIS profile usage
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWHOISProfileUsageV1(whoisId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWHOISProfileUsageV1(whoisId, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.getWHOISProfileUsageV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a WHOIS contact profile.
         * @summary Get WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsV1WHOISProfileResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWHOISProfileV1(whoisId, options);
            const localVarOperationServerBasePath = operationServerMap['DomainsWHOISApi.getWHOISProfileV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsWHOISApi - factory interface
 * @export
 */
export const DomainsWHOISApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsWHOISApiFp(configuration)
    return {
        /**
         * This endpoint creates WHOIS contact profile.
         * @summary Create WHOIS profile
         * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWHOISProfileV1(domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1WHOISProfileResource> {
            return localVarFp.createWHOISProfileV1(domainsV1WHOISStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes WHOIS contact profile.
         * @summary Delete WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteWHOISProfileV1(whoisId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of WHOIS contact profiles.
         * @summary Get WHOIS profile list
         * @param {string} [tld] Filter by TLD (without leading dot)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileListV1(tld?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DomainsV1WHOISProfileResource>> {
            return localVarFp.getWHOISProfileListV1(tld, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a domain list where provided WHOIS contact profile is used.
         * @summary Get WHOIS profile usage
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileUsageV1(whoisId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getWHOISProfileUsageV1(whoisId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a WHOIS contact profile.
         * @summary Get WHOIS profile
         * @param {number} whoisId WHOIS ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig): AxiosPromise<DomainsV1WHOISProfileResource> {
            return localVarFp.getWHOISProfileV1(whoisId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsWHOISApi - object-oriented interface
 * @export
 * @class DomainsWHOISApi
 * @extends {BaseAPI}
 */
export class DomainsWHOISApi extends BaseAPI {
    /**
     * This endpoint creates WHOIS contact profile.
     * @summary Create WHOIS profile
     * @param {DomainsV1WHOISStoreRequest} domainsV1WHOISStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public createWHOISProfileV1(domainsV1WHOISStoreRequest: DomainsV1WHOISStoreRequest, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).createWHOISProfileV1(domainsV1WHOISStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes WHOIS contact profile.
     * @summary Delete WHOIS profile
     * @param {number} whoisId WHOIS ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public deleteWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).deleteWHOISProfileV1(whoisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of WHOIS contact profiles.
     * @summary Get WHOIS profile list
     * @param {string} [tld] Filter by TLD (without leading dot)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public getWHOISProfileListV1(tld?: string, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).getWHOISProfileListV1(tld, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a domain list where provided WHOIS contact profile is used.
     * @summary Get WHOIS profile usage
     * @param {number} whoisId WHOIS ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public getWHOISProfileUsageV1(whoisId: number, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).getWHOISProfileUsageV1(whoisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a WHOIS contact profile.
     * @summary Get WHOIS profile
     * @param {number} whoisId WHOIS ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsWHOISApi
     */
    public getWHOISProfileV1(whoisId: number, options?: RawAxiosRequestConfig) {
        return DomainsWHOISApiFp(this.configuration).getWHOISProfileV1(whoisId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSActionsApi - axios parameter creator
 * @export
 */
export const VPSActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves a list of actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.
         * @summary Get action list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionListV1: async (virtualMachineId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getActionListV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/actions`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves details of a specific action performed on a specified virtual machine.   This endpoint allows you to view detailed information about a particular action, including the action name, timestamp, and status.
         * @summary Get action
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} actionId Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1: async (virtualMachineId: number, actionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getActionV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('getActionV1', 'actionId', actionId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/actions/{actionId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSActionsApi - functional programming interface
 * @export
 */
export const VPSActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves a list of actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.
         * @summary Get action list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionListV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetActionListV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionListV1(virtualMachineId, page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSActionsApi.getActionListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves details of a specific action performed on a specified virtual machine.   This endpoint allows you to view detailed information about a particular action, including the action name, timestamp, and status.
         * @summary Get action
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} actionId Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionV1(virtualMachineId: number, actionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionV1(virtualMachineId, actionId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSActionsApi.getActionV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSActionsApi - factory interface
 * @export
 */
export const VPSActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSActionsApiFp(configuration)
    return {
        /**
         * This endpoint retrieves a list of actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.
         * @summary Get action list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionListV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetActionListV1200Response> {
            return localVarFp.getActionListV1(virtualMachineId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves details of a specific action performed on a specified virtual machine.   This endpoint allows you to view detailed information about a particular action, including the action name, timestamp, and status.
         * @summary Get action
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} actionId Action ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionV1(virtualMachineId: number, actionId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.getActionV1(virtualMachineId, actionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSActionsApi - object-oriented interface
 * @export
 * @class VPSActionsApi
 * @extends {BaseAPI}
 */
export class VPSActionsApi extends BaseAPI {
    /**
     * This endpoint retrieves a list of actions performed on a specified virtual machine.  Actions are operations or events that have been executed on the virtual machine, such as starting, stopping, or modifying  the machine. This endpoint allows you to view the history of these actions, providing details about each action,  such as the action name, timestamp, and status.
     * @summary Get action list
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSActionsApi
     */
    public getActionListV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig) {
        return VPSActionsApiFp(this.configuration).getActionListV1(virtualMachineId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves details of a specific action performed on a specified virtual machine.   This endpoint allows you to view detailed information about a particular action, including the action name, timestamp, and status.
     * @summary Get action
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} actionId Action ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSActionsApi
     */
    public getActionV1(virtualMachineId: number, actionId: number, options?: RawAxiosRequestConfig) {
        return VPSActionsApiFp(this.configuration).getActionV1(virtualMachineId, actionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSBackupsApi - axios parameter creator
 * @export
 */
export const VPSBackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint deletes a specified backup for a virtual machine.
         * @summary Delete backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupV1: async (virtualMachineId: number, backupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deleteBackupV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('deleteBackupV1', 'backupId', backupId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/backups/{backupId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of backups for a specified virtual machine.
         * @summary Get backup list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupListV1: async (virtualMachineId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getBackupListV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/backups`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint restores a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**
         * @summary Restore backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBackupV1: async (virtualMachineId: number, backupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('restoreBackupV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('restoreBackupV1', 'backupId', backupId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/backups/{backupId}/restore`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSBackupsApi - functional programming interface
 * @export
 */
export const VPSBackupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSBackupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint deletes a specified backup for a virtual machine.
         * @summary Delete backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackupV1(virtualMachineId, backupId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSBackupsApi.deleteBackupV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of backups for a specified virtual machine.
         * @summary Get backup list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupListV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetBackupListV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupListV1(virtualMachineId, page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSBackupsApi.getBackupListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint restores a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**
         * @summary Restore backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreBackupV1(virtualMachineId, backupId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSBackupsApi.restoreBackupV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSBackupsApi - factory interface
 * @export
 */
export const VPSBackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSBackupsApiFp(configuration)
    return {
        /**
         * This endpoint deletes a specified backup for a virtual machine.
         * @summary Delete backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteBackupV1(virtualMachineId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of backups for a specified virtual machine.
         * @summary Get backup list
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupListV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetBackupListV1200Response> {
            return localVarFp.getBackupListV1(virtualMachineId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint restores a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**
         * @summary Restore backup
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} backupId Backup ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.restoreBackupV1(virtualMachineId, backupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSBackupsApi - object-oriented interface
 * @export
 * @class VPSBackupsApi
 * @extends {BaseAPI}
 */
export class VPSBackupsApi extends BaseAPI {
    /**
     * This endpoint deletes a specified backup for a virtual machine.
     * @summary Delete backup
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} backupId Backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSBackupsApi
     */
    public deleteBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig) {
        return VPSBackupsApiFp(this.configuration).deleteBackupV1(virtualMachineId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of backups for a specified virtual machine.
     * @summary Get backup list
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSBackupsApi
     */
    public getBackupListV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig) {
        return VPSBackupsApiFp(this.configuration).getBackupListV1(virtualMachineId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint restores a backup for a specified virtual machine.  The system will then initiate the restore process, which may take some time depending on the size of the backup.  **All data on the virtual machine will be overwritten with the data from the backup.**
     * @summary Restore backup
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} backupId Backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSBackupsApi
     */
    public restoreBackupV1(virtualMachineId: number, backupId: number, options?: RawAxiosRequestConfig) {
        return VPSBackupsApiFp(this.configuration).restoreBackupV1(virtualMachineId, backupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSDataCentersApi - axios parameter creator
 * @export
 */
export const VPSDataCentersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves a list of all data centers available.
         * @summary Get data centers list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCentersListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/data-centers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSDataCentersApi - functional programming interface
 * @export
 */
export const VPSDataCentersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSDataCentersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves a list of all data centers available.
         * @summary Get data centers list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataCentersListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1DataCenterDataCenterResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataCentersListV1(options);
            const localVarOperationServerBasePath = operationServerMap['VPSDataCentersApi.getDataCentersListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSDataCentersApi - factory interface
 * @export
 */
export const VPSDataCentersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSDataCentersApiFp(configuration)
    return {
        /**
         * This endpoint retrieves a list of all data centers available.
         * @summary Get data centers list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCentersListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1DataCenterDataCenterResource>> {
            return localVarFp.getDataCentersListV1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSDataCentersApi - object-oriented interface
 * @export
 * @class VPSDataCentersApi
 * @extends {BaseAPI}
 */
export class VPSDataCentersApi extends BaseAPI {
    /**
     * This endpoint retrieves a list of all data centers available.
     * @summary Get data centers list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSDataCentersApi
     */
    public getDataCentersListV1(options?: RawAxiosRequestConfig) {
        return VPSDataCentersApiFp(this.configuration).getDataCentersListV1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSFirewallApi - axios parameter creator
 * @export
 */
export const VPSFirewallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint activates a firewall for a specified virtual machine.   Only one firewall can be active for a virtual machine at a time.
         * @summary Activate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateFirewallV1: async (firewallId: number, virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('activateFirewallV1', 'firewallId', firewallId)
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('activateFirewallV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/activate/{virtualMachineId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates new firewall rule from a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Create firewall rule
         * @param {number} firewallId Firewall ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleV1: async (firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('createFirewallRuleV1', 'firewallId', firewallId)
            // verify required parameter 'vPSV1FirewallRulesStoreRequest' is not null or undefined
            assertParamExists('createFirewallRuleV1', 'vPSV1FirewallRulesStoreRequest', vPSV1FirewallRulesStoreRequest)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/rules`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1FirewallRulesStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates a new firewall.
         * @summary Create new firewall
         * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFirewallV1: async (vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1FirewallStoreRequest' is not null or undefined
            assertParamExists('createNewFirewallV1', 'vPSV1FirewallStoreRequest', vPSV1FirewallStoreRequest)
            const localVarPath = `/api/vps/v1/firewall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1FirewallStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deactivates a firewall for a specified virtual machine.
         * @summary Deactivate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFirewallV1: async (firewallId: number, virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('deactivateFirewallV1', 'firewallId', firewallId)
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deactivateFirewallV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/deactivate/{virtualMachineId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Delete firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleV1: async (firewallId: number, ruleId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('deleteFirewallRuleV1', 'firewallId', firewallId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('deleteFirewallRuleV1', 'ruleId', ruleId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/rules/{ruleId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a specified firewall.   Any virtual machine that has this firewall activated will automatically have it deactivated.
         * @summary Delete firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallV1: async (firewallId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('deleteFirewallV1', 'firewallId', firewallId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of all firewalls available.
         * @summary Get firewall list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallListV1: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/firewall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves firewall by its ID and rules associated with it.
         * @summary Get firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallV1: async (firewallId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('getFirewallV1', 'firewallId', firewallId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint syncs a firewall for a specified virtual machine.  Firewall can loose sync with virtual machine if the firewall has new rules added, removed or updated.
         * @summary Sync firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFirewallV1: async (firewallId: number, virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('syncFirewallV1', 'firewallId', firewallId)
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('syncFirewallV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/sync/{virtualMachineId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Update firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleV1: async (firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('updateFirewallRuleV1', 'firewallId', firewallId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('updateFirewallRuleV1', 'ruleId', ruleId)
            // verify required parameter 'vPSV1FirewallRulesStoreRequest' is not null or undefined
            assertParamExists('updateFirewallRuleV1', 'vPSV1FirewallRulesStoreRequest', vPSV1FirewallRulesStoreRequest)
            const localVarPath = `/api/vps/v1/firewall/{firewallId}/rules/{ruleId}`
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1FirewallRulesStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSFirewallApi - functional programming interface
 * @export
 */
export const VPSFirewallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSFirewallApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint activates a firewall for a specified virtual machine.   Only one firewall can be active for a virtual machine at a time.
         * @summary Activate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateFirewallV1(firewallId, virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.activateFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint creates new firewall rule from a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Create firewall rule
         * @param {number} firewallId Firewall ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFirewallRuleV1(firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallRuleResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFirewallRuleV1(firewallId, vPSV1FirewallRulesStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.createFirewallRuleV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint creates a new firewall.
         * @summary Create new firewall
         * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewFirewallV1(vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewFirewallV1(vPSV1FirewallStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.createNewFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deactivates a firewall for a specified virtual machine.
         * @summary Deactivate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateFirewallV1(firewallId, virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.deactivateFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Delete firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallRuleV1(firewallId: number, ruleId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallRuleV1(firewallId, ruleId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.deleteFirewallRuleV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes a specified firewall.   Any virtual machine that has this firewall activated will automatically have it deactivated.
         * @summary Delete firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFirewallV1(firewallId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFirewallV1(firewallId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.deleteFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of all firewalls available.
         * @summary Get firewall list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallListV1(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetFirewallListV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallListV1(page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.getFirewallListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves firewall by its ID and rules associated with it.
         * @summary Get firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirewallV1(firewallId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirewallV1(firewallId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.getFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint syncs a firewall for a specified virtual machine.  Firewall can loose sync with virtual machine if the firewall has new rules added, removed or updated.
         * @summary Sync firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncFirewallV1(firewallId, virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.syncFirewallV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint updates a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Update firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFirewallRuleV1(firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1FirewallFirewallRuleResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFirewallRuleV1(firewallId, ruleId, vPSV1FirewallRulesStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSFirewallApi.updateFirewallRuleV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSFirewallApi - factory interface
 * @export
 */
export const VPSFirewallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSFirewallApiFp(configuration)
    return {
        /**
         * This endpoint activates a firewall for a specified virtual machine.   Only one firewall can be active for a virtual machine at a time.
         * @summary Activate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.activateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates new firewall rule from a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Create firewall rule
         * @param {number} firewallId Firewall ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFirewallRuleV1(firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallRuleResource> {
            return localVarFp.createFirewallRuleV1(firewallId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates a new firewall.
         * @summary Create new firewall
         * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFirewallV1(vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallResource> {
            return localVarFp.createNewFirewallV1(vPSV1FirewallStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deactivates a firewall for a specified virtual machine.
         * @summary Deactivate firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.deactivateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Delete firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallRuleV1(firewallId: number, ruleId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteFirewallRuleV1(firewallId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a specified firewall.   Any virtual machine that has this firewall activated will automatically have it deactivated.
         * @summary Delete firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFirewallV1(firewallId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteFirewallV1(firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of all firewalls available.
         * @summary Get firewall list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallListV1(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetFirewallListV1200Response> {
            return localVarFp.getFirewallListV1(page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves firewall by its ID and rules associated with it.
         * @summary Get firewall
         * @param {number} firewallId Firewall ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirewallV1(firewallId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallResource> {
            return localVarFp.getFirewallV1(firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint syncs a firewall for a specified virtual machine.  Firewall can loose sync with virtual machine if the firewall has new rules added, removed or updated.
         * @summary Sync firewall
         * @param {number} firewallId Firewall ID
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.syncFirewallV1(firewallId, virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
         * @summary Update firewall rule
         * @param {number} firewallId Firewall ID
         * @param {number} ruleId Firewall Rule ID
         * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFirewallRuleV1(firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1FirewallFirewallRuleResource> {
            return localVarFp.updateFirewallRuleV1(firewallId, ruleId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSFirewallApi - object-oriented interface
 * @export
 * @class VPSFirewallApi
 * @extends {BaseAPI}
 */
export class VPSFirewallApi extends BaseAPI {
    /**
     * This endpoint activates a firewall for a specified virtual machine.   Only one firewall can be active for a virtual machine at a time.
     * @summary Activate firewall
     * @param {number} firewallId Firewall ID
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public activateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).activateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates new firewall rule from a specified firewall.  By default, the firewall drops all incoming traffic, which means you must add accept rules for all ports you want to use.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
     * @summary Create firewall rule
     * @param {number} firewallId Firewall ID
     * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public createFirewallRuleV1(firewallId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).createFirewallRuleV1(firewallId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates a new firewall.
     * @summary Create new firewall
     * @param {VPSV1FirewallStoreRequest} vPSV1FirewallStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public createNewFirewallV1(vPSV1FirewallStoreRequest: VPSV1FirewallStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).createNewFirewallV1(vPSV1FirewallStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deactivates a firewall for a specified virtual machine.
     * @summary Deactivate firewall
     * @param {number} firewallId Firewall ID
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public deactivateFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).deactivateFirewallV1(firewallId, virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
     * @summary Delete firewall rule
     * @param {number} firewallId Firewall ID
     * @param {number} ruleId Firewall Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public deleteFirewallRuleV1(firewallId: number, ruleId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).deleteFirewallRuleV1(firewallId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a specified firewall.   Any virtual machine that has this firewall activated will automatically have it deactivated.
     * @summary Delete firewall
     * @param {number} firewallId Firewall ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public deleteFirewallV1(firewallId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).deleteFirewallV1(firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of all firewalls available.
     * @summary Get firewall list
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public getFirewallListV1(page?: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).getFirewallListV1(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves firewall by its ID and rules associated with it.
     * @summary Get firewall
     * @param {number} firewallId Firewall ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public getFirewallV1(firewallId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).getFirewallV1(firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint syncs a firewall for a specified virtual machine.  Firewall can loose sync with virtual machine if the firewall has new rules added, removed or updated.
     * @summary Sync firewall
     * @param {number} firewallId Firewall ID
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public syncFirewallV1(firewallId: number, virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).syncFirewallV1(firewallId, virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates a specific firewall rule from a specified firewall.  Any virtual machine that has this firewall activated will loose sync with the firewall and will have to be synced again manually.
     * @summary Update firewall rule
     * @param {number} firewallId Firewall ID
     * @param {number} ruleId Firewall Rule ID
     * @param {VPSV1FirewallRulesStoreRequest} vPSV1FirewallRulesStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSFirewallApi
     */
    public updateFirewallRuleV1(firewallId: number, ruleId: number, vPSV1FirewallRulesStoreRequest: VPSV1FirewallRulesStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSFirewallApiFp(this.configuration).updateFirewallRuleV1(firewallId, ruleId, vPSV1FirewallRulesStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSMalwareScannerApi - axios parameter creator
 * @export
 */
export const VPSMalwareScannerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves the scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine. The scan metrics provide detailed information about the malware scans performed by Monarx, including the number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring the security status of the  virtual machine and assessing the effectiveness of the malware scanner.
         * @summary Get scan metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanMetricsV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getScanMetricsV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/monarx`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint installs the Monarx malware scanner on a specified virtual machine.   [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.
         * @summary Install Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installMonarxV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('installMonarxV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/monarx`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint uninstalls the Monarx malware scanner on a specified virtual machine. If Monarx is not installed, the request will still be processed without any effect.
         * @summary Uninstall Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallMonarxV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('uninstallMonarxV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/monarx`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSMalwareScannerApi - functional programming interface
 * @export
 */
export const VPSMalwareScannerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSMalwareScannerApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves the scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine. The scan metrics provide detailed information about the malware scans performed by Monarx, including the number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring the security status of the  virtual machine and assessing the effectiveness of the malware scanner.
         * @summary Get scan metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanMetricsV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1MalwareMetricsResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanMetricsV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSMalwareScannerApi.getScanMetricsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint installs the Monarx malware scanner on a specified virtual machine.   [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.
         * @summary Install Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installMonarxV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSMalwareScannerApi.installMonarxV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint uninstalls the Monarx malware scanner on a specified virtual machine. If Monarx is not installed, the request will still be processed without any effect.
         * @summary Uninstall Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallMonarxV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSMalwareScannerApi.uninstallMonarxV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSMalwareScannerApi - factory interface
 * @export
 */
export const VPSMalwareScannerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSMalwareScannerApiFp(configuration)
    return {
        /**
         * This endpoint retrieves the scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine. The scan metrics provide detailed information about the malware scans performed by Monarx, including the number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring the security status of the  virtual machine and assessing the effectiveness of the malware scanner.
         * @summary Get scan metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanMetricsV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1MalwareMetricsResource> {
            return localVarFp.getScanMetricsV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint installs the Monarx malware scanner on a specified virtual machine.   [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.
         * @summary Install Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.installMonarxV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint uninstalls the Monarx malware scanner on a specified virtual machine. If Monarx is not installed, the request will still be processed without any effect.
         * @summary Uninstall Monarx
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.uninstallMonarxV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSMalwareScannerApi - object-oriented interface
 * @export
 * @class VPSMalwareScannerApi
 * @extends {BaseAPI}
 */
export class VPSMalwareScannerApi extends BaseAPI {
    /**
     * This endpoint retrieves the scan metrics for the [Monarx](https://www.monarx.com/) malware scanner installed on a specified virtual machine. The scan metrics provide detailed information about the malware scans performed by Monarx, including the number of scans,  detected threats, and other relevant statistics. This information is useful for monitoring the security status of the  virtual machine and assessing the effectiveness of the malware scanner.
     * @summary Get scan metrics
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSMalwareScannerApi
     */
    public getScanMetricsV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSMalwareScannerApiFp(this.configuration).getScanMetricsV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint installs the Monarx malware scanner on a specified virtual machine.   [Monarx](https://www.monarx.com/) is a security tool designed to detect and prevent malware infections on virtual machines.  By installing Monarx, users can enhance the security of their virtual machines, ensuring that they are protected against malicious software.
     * @summary Install Monarx
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSMalwareScannerApi
     */
    public installMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSMalwareScannerApiFp(this.configuration).installMonarxV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint uninstalls the Monarx malware scanner on a specified virtual machine. If Monarx is not installed, the request will still be processed without any effect.
     * @summary Uninstall Monarx
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSMalwareScannerApi
     */
    public uninstallMonarxV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSMalwareScannerApiFp(this.configuration).uninstallMonarxV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSOSTemplatesApi - axios parameter creator
 * @export
 */
export const VPSOSTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves a list of available OS templates for virtual machines.
         * @summary Get template list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves details of a specific OS template for virtual machines.
         * @summary Get template
         * @param {number} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateV1: async (templateId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getTemplateV1', 'templateId', templateId)
            const localVarPath = `/api/vps/v1/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSOSTemplatesApi - functional programming interface
 * @export
 */
export const VPSOSTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSOSTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves a list of available OS templates for virtual machines.
         * @summary Get template list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1TemplateTemplateResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateListV1(options);
            const localVarOperationServerBasePath = operationServerMap['VPSOSTemplatesApi.getTemplateListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves details of a specific OS template for virtual machines.
         * @summary Get template
         * @param {number} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateV1(templateId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1TemplateTemplateResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateV1(templateId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSOSTemplatesApi.getTemplateV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSOSTemplatesApi - factory interface
 * @export
 */
export const VPSOSTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSOSTemplatesApiFp(configuration)
    return {
        /**
         * This endpoint retrieves a list of available OS templates for virtual machines.
         * @summary Get template list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1TemplateTemplateResource>> {
            return localVarFp.getTemplateListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves details of a specific OS template for virtual machines.
         * @summary Get template
         * @param {number} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateV1(templateId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1TemplateTemplateResource> {
            return localVarFp.getTemplateV1(templateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSOSTemplatesApi - object-oriented interface
 * @export
 * @class VPSOSTemplatesApi
 * @extends {BaseAPI}
 */
export class VPSOSTemplatesApi extends BaseAPI {
    /**
     * This endpoint retrieves a list of available OS templates for virtual machines.
     * @summary Get template list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSOSTemplatesApi
     */
    public getTemplateListV1(options?: RawAxiosRequestConfig) {
        return VPSOSTemplatesApiFp(this.configuration).getTemplateListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves details of a specific OS template for virtual machines.
     * @summary Get template
     * @param {number} templateId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSOSTemplatesApi
     */
    public getTemplateV1(templateId: number, options?: RawAxiosRequestConfig) {
        return VPSOSTemplatesApiFp(this.configuration).getTemplateV1(templateId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSPTRRecordsApi - axios parameter creator
 * @export
 */
export const VPSPTRRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates or updates a PTR (Pointer) record for a specified virtual machine.
         * @summary Create PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPTRRecordV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('createPTRRecordV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/ptr`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a PTR (Pointer) record for a specified virtual machine.   Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.
         * @summary Delete PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePTRRecordV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deletePTRRecordV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/ptr`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSPTRRecordsApi - functional programming interface
 * @export
 */
export const VPSPTRRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSPTRRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates or updates a PTR (Pointer) record for a specified virtual machine.
         * @summary Create PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPTRRecordV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPTRRecordV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPTRRecordsApi.createPTRRecordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes a PTR (Pointer) record for a specified virtual machine.   Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.
         * @summary Delete PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePTRRecordV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePTRRecordV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPTRRecordsApi.deletePTRRecordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSPTRRecordsApi - factory interface
 * @export
 */
export const VPSPTRRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSPTRRecordsApiFp(configuration)
    return {
        /**
         * This endpoint creates or updates a PTR (Pointer) record for a specified virtual machine.
         * @summary Create PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPTRRecordV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.createPTRRecordV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a PTR (Pointer) record for a specified virtual machine.   Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.
         * @summary Delete PTR record
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePTRRecordV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.deletePTRRecordV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSPTRRecordsApi - object-oriented interface
 * @export
 * @class VPSPTRRecordsApi
 * @extends {BaseAPI}
 */
export class VPSPTRRecordsApi extends BaseAPI {
    /**
     * This endpoint creates or updates a PTR (Pointer) record for a specified virtual machine.
     * @summary Create PTR record
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPTRRecordsApi
     */
    public createPTRRecordV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSPTRRecordsApiFp(this.configuration).createPTRRecordV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a PTR (Pointer) record for a specified virtual machine.   Once deleted, reverse DNS lookups to the virtual machine\'s IP address will no longer return the previously configured hostname.
     * @summary Delete PTR record
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPTRRecordsApi
     */
    public deletePTRRecordV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSPTRRecordsApiFp(this.configuration).deletePTRRecordV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSPostInstallScriptsApi - axios parameter creator
 * @export
 */
export const VPSPostInstallScriptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to add a new post-install script to your account,  which can then be used run after the installation of a virtual machine instance.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB. 
         * @summary Create post-install script
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostInstallScriptV1: async (vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1PostInstallScriptStoreRequest' is not null or undefined
            assertParamExists('createPostInstallScriptV1', 'vPSV1PostInstallScriptStoreRequest', vPSV1PostInstallScriptStoreRequest)
            const localVarPath = `/api/vps/v1/post-install-scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PostInstallScriptStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a post-install script from your account. 
         * @summary Delete a post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPostInstallScriptV1: async (postInstallScriptId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postInstallScriptId' is not null or undefined
            assertParamExists('deleteAPostInstallScriptV1', 'postInstallScriptId', postInstallScriptId)
            const localVarPath = `/api/vps/v1/post-install-scripts/{postInstallScriptId}`
                .replace(`{${"postInstallScriptId"}}`, encodeURIComponent(String(postInstallScriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of post-install scripts associated with your account.
         * @summary Get post-install script list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptListV1: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/post-install-scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves post-install script by its ID.
         * @summary Get post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptV1: async (postInstallScriptId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postInstallScriptId' is not null or undefined
            assertParamExists('getPostInstallScriptV1', 'postInstallScriptId', postInstallScriptId)
            const localVarPath = `/api/vps/v1/post-install-scripts/{postInstallScriptId}`
                .replace(`{${"postInstallScriptId"}}`, encodeURIComponent(String(postInstallScriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates a specific post-install script.
         * @summary Update post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostInstallScriptV1: async (postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postInstallScriptId' is not null or undefined
            assertParamExists('updatePostInstallScriptV1', 'postInstallScriptId', postInstallScriptId)
            // verify required parameter 'vPSV1PostInstallScriptStoreRequest' is not null or undefined
            assertParamExists('updatePostInstallScriptV1', 'vPSV1PostInstallScriptStoreRequest', vPSV1PostInstallScriptStoreRequest)
            const localVarPath = `/api/vps/v1/post-install-scripts/{postInstallScriptId}`
                .replace(`{${"postInstallScriptId"}}`, encodeURIComponent(String(postInstallScriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PostInstallScriptStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSPostInstallScriptsApi - functional programming interface
 * @export
 */
export const VPSPostInstallScriptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSPostInstallScriptsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to add a new post-install script to your account,  which can then be used run after the installation of a virtual machine instance.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB. 
         * @summary Create post-install script
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.createPostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes a post-install script from your account. 
         * @summary Delete a post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAPostInstallScriptV1(postInstallScriptId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.deleteAPostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of post-install scripts associated with your account.
         * @summary Get post-install script list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostInstallScriptListV1(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetPostInstallScriptListV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostInstallScriptListV1(page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.getPostInstallScriptListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves post-install script by its ID.
         * @summary Get post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostInstallScriptV1(postInstallScriptId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.getPostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint updates a specific post-install script.
         * @summary Update post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePostInstallScriptV1(postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePostInstallScriptV1(postInstallScriptId, vPSV1PostInstallScriptStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPostInstallScriptsApi.updatePostInstallScriptV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSPostInstallScriptsApi - factory interface
 * @export
 */
export const VPSPostInstallScriptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSPostInstallScriptsApiFp(configuration)
    return {
        /**
         * This endpoint allows you to add a new post-install script to your account,  which can then be used run after the installation of a virtual machine instance.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB. 
         * @summary Create post-install script
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource> {
            return localVarFp.createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a post-install script from your account. 
         * @summary Delete a post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteAPostInstallScriptV1(postInstallScriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of post-install scripts associated with your account.
         * @summary Get post-install script list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptListV1(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetPostInstallScriptListV1200Response> {
            return localVarFp.getPostInstallScriptListV1(page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves post-install script by its ID.
         * @summary Get post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource> {
            return localVarFp.getPostInstallScriptV1(postInstallScriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates a specific post-install script.
         * @summary Update post-install script
         * @param {number} postInstallScriptId Post-install script ID
         * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostInstallScriptV1(postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PostInstallScriptPostInstallScriptResource> {
            return localVarFp.updatePostInstallScriptV1(postInstallScriptId, vPSV1PostInstallScriptStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSPostInstallScriptsApi - object-oriented interface
 * @export
 * @class VPSPostInstallScriptsApi
 * @extends {BaseAPI}
 */
export class VPSPostInstallScriptsApi extends BaseAPI {
    /**
     * This endpoint allows you to add a new post-install script to your account,  which can then be used run after the installation of a virtual machine instance.  The script contents will be saved to the file `/post_install` with executable attribute set and will be executed once virtual machine is installed. The output of the script will be redirected to `/post_install.log`. Maximum script size is 48KB. 
     * @summary Create post-install script
     * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).createPostInstallScriptV1(vPSV1PostInstallScriptStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a post-install script from your account. 
     * @summary Delete a post-install script
     * @param {number} postInstallScriptId Post-install script ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public deleteAPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).deleteAPostInstallScriptV1(postInstallScriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of post-install scripts associated with your account.
     * @summary Get post-install script list
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public getPostInstallScriptListV1(page?: number, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).getPostInstallScriptListV1(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves post-install script by its ID.
     * @summary Get post-install script
     * @param {number} postInstallScriptId Post-install script ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public getPostInstallScriptV1(postInstallScriptId: number, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).getPostInstallScriptV1(postInstallScriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates a specific post-install script.
     * @summary Update post-install script
     * @param {number} postInstallScriptId Post-install script ID
     * @param {VPSV1PostInstallScriptStoreRequest} vPSV1PostInstallScriptStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPostInstallScriptsApi
     */
    public updatePostInstallScriptV1(postInstallScriptId: number, vPSV1PostInstallScriptStoreRequest: VPSV1PostInstallScriptStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSPostInstallScriptsApiFp(this.configuration).updatePostInstallScriptV1(postInstallScriptId, vPSV1PostInstallScriptStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSPublicKeysApi - axios parameter creator
 * @export
 */
export const VPSPublicKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint attaches an existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.
         * @summary Attach public key
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicKeyV1: async (virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('attachPublicKeyV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1PublicKeyAttachRequest' is not null or undefined
            assertParamExists('attachPublicKeyV1', 'vPSV1PublicKeyAttachRequest', vPSV1PublicKeyAttachRequest)
            const localVarPath = `/api/vps/v1/public-keys/attach/{virtualMachineId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PublicKeyAttachRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to add a new public key to your account,  which can then be attached to virtual machine instances for secure access.
         * @summary Create new public key
         * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPublicKeyV1: async (vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1PublicKeyStoreRequest' is not null or undefined
            assertParamExists('createNewPublicKeyV1', 'vPSV1PublicKeyStoreRequest', vPSV1PublicKeyStoreRequest)
            const localVarPath = `/api/vps/v1/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1PublicKeyStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a public key from your account.   **Deleting public key from account does not remove it from virtual machine** 
         * @summary Delete a public key
         * @param {number} publicKeyId Public Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPublicKeyV1: async (publicKeyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKeyId' is not null or undefined
            assertParamExists('deleteAPublicKeyV1', 'publicKeyId', publicKeyId)
            const localVarPath = `/api/vps/v1/public-keys/{publicKeyId}`
                .replace(`{${"publicKeyId"}}`, encodeURIComponent(String(publicKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of public keys associated with your account.
         * @summary Get public key list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyListV1: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSPublicKeysApi - functional programming interface
 * @export
 */
export const VPSPublicKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSPublicKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint attaches an existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.
         * @summary Attach public key
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPublicKeyV1(virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPublicKeyV1(virtualMachineId, vPSV1PublicKeyAttachRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.attachPublicKeyV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to add a new public key to your account,  which can then be attached to virtual machine instances for secure access.
         * @summary Create new public key
         * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewPublicKeyV1(vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1PublicKeyPublicKeyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewPublicKeyV1(vPSV1PublicKeyStoreRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.createNewPublicKeyV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes a public key from your account.   **Deleting public key from account does not remove it from virtual machine** 
         * @summary Delete a public key
         * @param {number} publicKeyId Public Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAPublicKeyV1(publicKeyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessEmptyResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAPublicKeyV1(publicKeyId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.deleteAPublicKeyV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of public keys associated with your account.
         * @summary Get public key list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeyListV1(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetPublicKeyListV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeyListV1(page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSPublicKeysApi.getPublicKeyListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSPublicKeysApi - factory interface
 * @export
 */
export const VPSPublicKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSPublicKeysApiFp(configuration)
    return {
        /**
         * This endpoint attaches an existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.
         * @summary Attach public key
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPublicKeyV1(virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.attachPublicKeyV1(virtualMachineId, vPSV1PublicKeyAttachRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to add a new public key to your account,  which can then be attached to virtual machine instances for secure access.
         * @summary Create new public key
         * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPublicKeyV1(vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1PublicKeyPublicKeyResource> {
            return localVarFp.createNewPublicKeyV1(vPSV1PublicKeyStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a public key from your account.   **Deleting public key from account does not remove it from virtual machine** 
         * @summary Delete a public key
         * @param {number} publicKeyId Public Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPublicKeyV1(publicKeyId: number, options?: RawAxiosRequestConfig): AxiosPromise<CommonSuccessEmptyResource> {
            return localVarFp.deleteAPublicKeyV1(publicKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of public keys associated with your account.
         * @summary Get public key list
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyListV1(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetPublicKeyListV1200Response> {
            return localVarFp.getPublicKeyListV1(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSPublicKeysApi - object-oriented interface
 * @export
 * @class VPSPublicKeysApi
 * @extends {BaseAPI}
 */
export class VPSPublicKeysApi extends BaseAPI {
    /**
     * This endpoint attaches an existing public keys from your account to a specified virtual machine.  Multiple keys can be attached to a single virtual machine.
     * @summary Attach public key
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1PublicKeyAttachRequest} vPSV1PublicKeyAttachRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public attachPublicKeyV1(virtualMachineId: number, vPSV1PublicKeyAttachRequest: VPSV1PublicKeyAttachRequest, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).attachPublicKeyV1(virtualMachineId, vPSV1PublicKeyAttachRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to add a new public key to your account,  which can then be attached to virtual machine instances for secure access.
     * @summary Create new public key
     * @param {VPSV1PublicKeyStoreRequest} vPSV1PublicKeyStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public createNewPublicKeyV1(vPSV1PublicKeyStoreRequest: VPSV1PublicKeyStoreRequest, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).createNewPublicKeyV1(vPSV1PublicKeyStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a public key from your account.   **Deleting public key from account does not remove it from virtual machine** 
     * @summary Delete a public key
     * @param {number} publicKeyId Public Key ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public deleteAPublicKeyV1(publicKeyId: number, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).deleteAPublicKeyV1(publicKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of public keys associated with your account.
     * @summary Get public key list
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSPublicKeysApi
     */
    public getPublicKeyListV1(page?: number, options?: RawAxiosRequestConfig) {
        return VPSPublicKeysApiFp(this.configuration).getPublicKeyListV1(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSRecoveryApi - axios parameter creator
 * @export
 */
export const VPSRecoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint initiates the recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.
         * @summary Start recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecoveryModeV1: async (virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('startRecoveryModeV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineRecoveryStartRequest' is not null or undefined
            assertParamExists('startRecoveryModeV1', 'vPSV1VirtualMachineRecoveryStartRequest', vPSV1VirtualMachineRecoveryStartRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/recovery`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineRecoveryStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint stops the recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.
         * @summary Stop recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecoveryModeV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('stopRecoveryModeV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/recovery`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSRecoveryApi - functional programming interface
 * @export
 */
export const VPSRecoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSRecoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint initiates the recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.
         * @summary Start recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecoveryModeV1(virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecoveryModeV1(virtualMachineId, vPSV1VirtualMachineRecoveryStartRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSRecoveryApi.startRecoveryModeV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint stops the recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.
         * @summary Stop recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRecoveryModeV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRecoveryModeV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSRecoveryApi.stopRecoveryModeV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSRecoveryApi - factory interface
 * @export
 */
export const VPSRecoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSRecoveryApiFp(configuration)
    return {
        /**
         * This endpoint initiates the recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.
         * @summary Start recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecoveryModeV1(virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.startRecoveryModeV1(virtualMachineId, vPSV1VirtualMachineRecoveryStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint stops the recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.
         * @summary Stop recovery mode
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecoveryModeV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.stopRecoveryModeV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSRecoveryApi - object-oriented interface
 * @export
 * @class VPSRecoveryApi
 * @extends {BaseAPI}
 */
export class VPSRecoveryApi extends BaseAPI {
    /**
     * This endpoint initiates the recovery mode for a specified virtual machine.  Recovery mode is a special state that allows users to perform system rescue operations,  such as repairing file systems, recovering data, or troubleshooting issues that prevent the virtual machine  from booting normally.   Virtual machine will boot recovery disk image and original disk image will be mounted in `/mnt` directory.
     * @summary Start recovery mode
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineRecoveryStartRequest} vPSV1VirtualMachineRecoveryStartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSRecoveryApi
     */
    public startRecoveryModeV1(virtualMachineId: number, vPSV1VirtualMachineRecoveryStartRequest: VPSV1VirtualMachineRecoveryStartRequest, options?: RawAxiosRequestConfig) {
        return VPSRecoveryApiFp(this.configuration).startRecoveryModeV1(virtualMachineId, vPSV1VirtualMachineRecoveryStartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint stops the recovery mode for a specified virtual machine.  If virtual machine is not in recovery mode, this operation will fail.
     * @summary Stop recovery mode
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSRecoveryApi
     */
    public stopRecoveryModeV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSRecoveryApiFp(this.configuration).stopRecoveryModeV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSSnapshotsApi - axios parameter creator
 * @export
 */
export const VPSSnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**
         * @summary Create snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('createSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a snapshot of a specified virtual machine.
         * @summary Delete snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('deleteSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a snapshot for a specified virtual machine.
         * @summary Get snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint restores a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.
         * @summary Restore snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshotV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('restoreSnapshotV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/snapshot/restore`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSSnapshotsApi - functional programming interface
 * @export
 */
export const VPSSnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSSnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**
         * @summary Create snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.createSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint deletes a snapshot of a specified virtual machine.
         * @summary Delete snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.deleteSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a snapshot for a specified virtual machine.
         * @summary Get snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1SnapshotSnapshotResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.getSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint restores a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.
         * @summary Restore snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreSnapshotV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSSnapshotsApi.restoreSnapshotV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSSnapshotsApi - factory interface
 * @export
 */
export const VPSSnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSSnapshotsApiFp(configuration)
    return {
        /**
         * This endpoint creates a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**
         * @summary Create snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.createSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a snapshot of a specified virtual machine.
         * @summary Delete snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.deleteSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a snapshot for a specified virtual machine.
         * @summary Get snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1SnapshotSnapshotResource> {
            return localVarFp.getSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint restores a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.
         * @summary Restore snapshot
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.restoreSnapshotV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSSnapshotsApi - object-oriented interface
 * @export
 * @class VPSSnapshotsApi
 * @extends {BaseAPI}
 */
export class VPSSnapshotsApi extends BaseAPI {
    /**
     * This endpoint creates a snapshot of a specified virtual machine.  A snapshot captures the state and data of the virtual machine at a specific point in time,  allowing users to restore the virtual machine to that state if needed.  This operation is useful for backup purposes, system recovery,  and testing changes without affecting the current state of the virtual machine.  **Creating new snapshot will overwrite the existing snapshot!**
     * @summary Create snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public createSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).createSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a snapshot of a specified virtual machine.
     * @summary Delete snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public deleteSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).deleteSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a snapshot for a specified virtual machine.
     * @summary Get snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public getSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).getSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint restores a specified virtual machine to a previous state using a snapshot.  Restoring from a snapshot allows users to revert the virtual machine to that state, which is useful for system recovery, undoing changes, or testing.
     * @summary Restore snapshot
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSSnapshotsApi
     */
    public restoreSnapshotV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSSnapshotsApiFp(this.configuration).restoreSnapshotV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VPSVirtualMachineApi - axios parameter creator
 * @export
 */
export const VPSVirtualMachineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves a list of public keys attached to a specified virtual machine.
         * @summary Get attached public keys
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachedPublicKeysV1: async (virtualMachineId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getAttachedPublicKeysV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/public-keys`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves the historical metrics for a specified virtual machine. It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime
         * @summary Get metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} dateFrom 
         * @param {string} dateTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1: async (virtualMachineId: number, dateFrom: string, dateTo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getMetricsV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('getMetricsV1', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('getMetricsV1', 'dateTo', dateTo)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/metrics`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString() :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString() :
                    dateTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of all available virtual machines.
         * @summary Get virtual machine list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachineListV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vps/v1/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves detailed information about a specified virtual machine.
         * @summary Get virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachineV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('getVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to buy (purchase) and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.                        
         * @summary Purchase new virtual machine
         * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewVirtualMachineV1: async (vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vPSV1VirtualMachinePurchaseRequest' is not null or undefined
            assertParamExists('purchaseNewVirtualMachineV1', 'vPSV1VirtualMachinePurchaseRequest', vPSV1VirtualMachinePurchaseRequest)
            const localVarPath = `/api/vps/v1/virtual-machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachinePurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**
         * @summary Recreate virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateVirtualMachineV1: async (virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('recreateVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineRecreateRequest' is not null or undefined
            assertParamExists('recreateVirtualMachineV1', 'vPSV1VirtualMachineRecreateRequest', vPSV1VirtualMachineRecreateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/recreate`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineRecreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint resets the hostname and PTR record of a specified virtual machine to the default value.
         * @summary Reset hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetHostnameV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('resetHostnameV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/hostname`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint restarts a specified virtual machine. This is equivalent to fully stopping and starting the virtual machine. If the virtual machine was stopped, it will be started.
         * @summary Restart virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartVirtualMachineV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('restartVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/restart`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets the hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.
         * @summary Set hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHostnameV1: async (virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setHostnameV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineHostnameUpdateRequest' is not null or undefined
            assertParamExists('setHostnameV1', 'vPSV1VirtualMachineHostnameUpdateRequest', vPSV1VirtualMachineHostnameUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/hostname`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineHostnameUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets the nameservers for a specified virtual machine. Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.
         * @summary Set nameservers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNameserversV1: async (virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setNameserversV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineNameserversUpdateRequest' is not null or undefined
            assertParamExists('setNameserversV1', 'vPSV1VirtualMachineNameserversUpdateRequest', vPSV1VirtualMachineNameserversUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/nameservers`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineNameserversUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets the panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
         * @summary Set panel password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPanelPasswordV1: async (virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setPanelPasswordV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachinePanelPasswordUpdateRequest' is not null or undefined
            assertParamExists('setPanelPasswordV1', 'vPSV1VirtualMachinePanelPasswordUpdateRequest', vPSV1VirtualMachinePanelPasswordUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/panel-password`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachinePanelPasswordUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sets the root password for a specified virtual machine.  Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
         * @summary Set root password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRootPasswordV1: async (virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setRootPasswordV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineRootPasswordUpdateRequest' is not null or undefined
            assertParamExists('setRootPasswordV1', 'vPSV1VirtualMachineRootPasswordUpdateRequest', vPSV1VirtualMachineRootPasswordUpdateRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/root-password`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineRootPasswordUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will setup newly purchased virtual machine with `initial` state. 
         * @summary Setup new virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupNewVirtualMachineV1: async (virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('setupNewVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            // verify required parameter 'vPSV1VirtualMachineSetupRequest' is not null or undefined
            assertParamExists('setupNewVirtualMachineV1', 'vPSV1VirtualMachineSetupRequest', vPSV1VirtualMachineSetupRequest)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/setup`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vPSV1VirtualMachineSetupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint starts a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.
         * @summary Start virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startVirtualMachineV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('startVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/start`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint stops a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.
         * @summary Stop virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopVirtualMachineV1: async (virtualMachineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'virtualMachineId' is not null or undefined
            assertParamExists('stopVirtualMachineV1', 'virtualMachineId', virtualMachineId)
            const localVarPath = `/api/vps/v1/virtual-machines/{virtualMachineId}/stop`
                .replace(`{${"virtualMachineId"}}`, encodeURIComponent(String(virtualMachineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VPSVirtualMachineApi - functional programming interface
 * @export
 */
export const VPSVirtualMachineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VPSVirtualMachineApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves a list of public keys attached to a specified virtual machine.
         * @summary Get attached public keys
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachedPublicKeysV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSGetPublicKeyListV1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachedPublicKeysV1(virtualMachineId, page, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getAttachedPublicKeysV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves the historical metrics for a specified virtual machine. It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime
         * @summary Get metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} dateFrom 
         * @param {string} dateTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsV1(virtualMachineId: number, dateFrom: string, dateTo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1MetricsMetricsCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsV1(virtualMachineId, dateFrom, dateTo, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getMetricsV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of all available virtual machines.
         * @summary Get virtual machine list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualMachineListV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VPSV1VirtualMachineVirtualMachineResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualMachineListV1(options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getVirtualMachineListV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves detailed information about a specified virtual machine.
         * @summary Get virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1VirtualMachineVirtualMachineResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualMachineV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.getVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to buy (purchase) and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.                        
         * @summary Purchase new virtual machine
         * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingV1OrderOrderResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.purchaseNewVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**
         * @summary Recreate virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recreateVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recreateVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineRecreateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.recreateVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint resets the hostname and PTR record of a specified virtual machine to the default value.
         * @summary Reset hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetHostnameV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetHostnameV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.resetHostnameV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint restarts a specified virtual machine. This is equivalent to fully stopping and starting the virtual machine. If the virtual machine was stopped, it will be started.
         * @summary Restart virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartVirtualMachineV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.restartVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sets the hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.
         * @summary Set hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setHostnameV1(virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setHostnameV1(virtualMachineId, vPSV1VirtualMachineHostnameUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setHostnameV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sets the nameservers for a specified virtual machine. Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.
         * @summary Set nameservers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setNameserversV1(virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setNameserversV1(virtualMachineId, vPSV1VirtualMachineNameserversUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setNameserversV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sets the panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
         * @summary Set panel password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPanelPasswordV1(virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPanelPasswordV1(virtualMachineId, vPSV1VirtualMachinePanelPasswordUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setPanelPasswordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint sets the root password for a specified virtual machine.  Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
         * @summary Set root password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRootPasswordV1(virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRootPasswordV1(virtualMachineId, vPSV1VirtualMachineRootPasswordUpdateRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setRootPasswordV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will setup newly purchased virtual machine with `initial` state. 
         * @summary Setup new virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupNewVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1VirtualMachineVirtualMachineResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupNewVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineSetupRequest, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.setupNewVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint starts a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.
         * @summary Start virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startVirtualMachineV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.startVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint stops a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.
         * @summary Stop virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VPSV1ActionActionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopVirtualMachineV1(virtualMachineId, options);
            const localVarOperationServerBasePath = operationServerMap['VPSVirtualMachineApi.stopVirtualMachineV1']?.[0]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VPSVirtualMachineApi - factory interface
 * @export
 */
export const VPSVirtualMachineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VPSVirtualMachineApiFp(configuration)
    return {
        /**
         * This endpoint retrieves a list of public keys attached to a specified virtual machine.
         * @summary Get attached public keys
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachedPublicKeysV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSGetPublicKeyListV1200Response> {
            return localVarFp.getAttachedPublicKeysV1(virtualMachineId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves the historical metrics for a specified virtual machine. It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime
         * @summary Get metrics
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {string} dateFrom 
         * @param {string} dateTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsV1(virtualMachineId: number, dateFrom: string, dateTo: string, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1MetricsMetricsCollection> {
            return localVarFp.getMetricsV1(virtualMachineId, dateFrom, dateTo, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of all available virtual machines.
         * @summary Get virtual machine list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachineListV1(options?: RawAxiosRequestConfig): AxiosPromise<Array<VPSV1VirtualMachineVirtualMachineResource>> {
            return localVarFp.getVirtualMachineListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves detailed information about a specified virtual machine.
         * @summary Get virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1VirtualMachineVirtualMachineResource> {
            return localVarFp.getVirtualMachineV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to buy (purchase) and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.                        
         * @summary Purchase new virtual machine
         * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingV1OrderOrderResource> {
            return localVarFp.purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**
         * @summary Recreate virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recreateVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.recreateVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineRecreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint resets the hostname and PTR record of a specified virtual machine to the default value.
         * @summary Reset hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetHostnameV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.resetHostnameV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint restarts a specified virtual machine. This is equivalent to fully stopping and starting the virtual machine. If the virtual machine was stopped, it will be started.
         * @summary Restart virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.restartVirtualMachineV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets the hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.
         * @summary Set hostname
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHostnameV1(virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setHostnameV1(virtualMachineId, vPSV1VirtualMachineHostnameUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets the nameservers for a specified virtual machine. Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.
         * @summary Set nameservers
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNameserversV1(virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setNameserversV1(virtualMachineId, vPSV1VirtualMachineNameserversUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets the panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
         * @summary Set panel password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPanelPasswordV1(virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setPanelPasswordV1(virtualMachineId, vPSV1VirtualMachinePanelPasswordUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sets the root password for a specified virtual machine.  Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
         * @summary Set root password
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRootPasswordV1(virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.setRootPasswordV1(virtualMachineId, vPSV1VirtualMachineRootPasswordUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will setup newly purchased virtual machine with `initial` state. 
         * @summary Setup new virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupNewVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1VirtualMachineVirtualMachineResource> {
            return localVarFp.setupNewVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineSetupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint starts a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.
         * @summary Start virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.startVirtualMachineV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint stops a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.
         * @summary Stop virtual machine
         * @param {number} virtualMachineId Virtual Machine ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig): AxiosPromise<VPSV1ActionActionResource> {
            return localVarFp.stopVirtualMachineV1(virtualMachineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VPSVirtualMachineApi - object-oriented interface
 * @export
 * @class VPSVirtualMachineApi
 * @extends {BaseAPI}
 */
export class VPSVirtualMachineApi extends BaseAPI {
    /**
     * This endpoint retrieves a list of public keys attached to a specified virtual machine.
     * @summary Get attached public keys
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getAttachedPublicKeysV1(virtualMachineId: number, page?: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getAttachedPublicKeysV1(virtualMachineId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves the historical metrics for a specified virtual machine. It includes the following metrics:  - CPU usage - Memory usage - Disk usage - Network usage - Uptime
     * @summary Get metrics
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {string} dateFrom 
     * @param {string} dateTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getMetricsV1(virtualMachineId: number, dateFrom: string, dateTo: string, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getMetricsV1(virtualMachineId, dateFrom, dateTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of all available virtual machines.
     * @summary Get virtual machine list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getVirtualMachineListV1(options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getVirtualMachineListV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves detailed information about a specified virtual machine.
     * @summary Get virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public getVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).getVirtualMachineV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to buy (purchase) and setup a new virtual machine.  If virtual machine setup fails for any reason, login to [hPanel](https://hpanel.hostinger.com/) and complete the setup manually.  If no payment method is provided, your default payment method will be used automatically.                        
     * @summary Purchase new virtual machine
     * @param {VPSV1VirtualMachinePurchaseRequest} vPSV1VirtualMachinePurchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest: VPSV1VirtualMachinePurchaseRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).purchaseNewVirtualMachineV1(vPSV1VirtualMachinePurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will recreate a virtual machine from scratch.  The recreation process involves reinstalling the operating system and resetting the virtual machine to its initial state. Snapshots, if there are any, will be deleted.  ## Password Requirements Password will be checked against leaked password databases.  Requirements for the password are: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one number - Is not leaked publicly  **This operation is irreversible and will result in the loss of all data stored on the virtual machine!**
     * @summary Recreate virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineRecreateRequest} vPSV1VirtualMachineRecreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public recreateVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineRecreateRequest: VPSV1VirtualMachineRecreateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).recreateVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineRecreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint resets the hostname and PTR record of a specified virtual machine to the default value.
     * @summary Reset hostname
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public resetHostnameV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).resetHostnameV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint restarts a specified virtual machine. This is equivalent to fully stopping and starting the virtual machine. If the virtual machine was stopped, it will be started.
     * @summary Restart virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public restartVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).restartVirtualMachineV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets the hostname for a specified virtual machine.  Changing hostname does not update PTR record automatically. If you want your virtual machine to be reachable by a hostname,  you need to point your domain A/AAAA records to virtual machine IP as well.
     * @summary Set hostname
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineHostnameUpdateRequest} vPSV1VirtualMachineHostnameUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setHostnameV1(virtualMachineId: number, vPSV1VirtualMachineHostnameUpdateRequest: VPSV1VirtualMachineHostnameUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setHostnameV1(virtualMachineId, vPSV1VirtualMachineHostnameUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets the nameservers for a specified virtual machine. Be aware, that improper nameserver configuration can lead to the virtual machine being unable to resolve domain names.
     * @summary Set nameservers
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineNameserversUpdateRequest} vPSV1VirtualMachineNameserversUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setNameserversV1(virtualMachineId: number, vPSV1VirtualMachineNameserversUpdateRequest: VPSV1VirtualMachineNameserversUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setNameserversV1(virtualMachineId, vPSV1VirtualMachineNameserversUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets the panel password for a specified virtual machine.  If virtual machine does not use panel OS, the request will still be processed without any effect. Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
     * @summary Set panel password
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachinePanelPasswordUpdateRequest} vPSV1VirtualMachinePanelPasswordUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setPanelPasswordV1(virtualMachineId: number, vPSV1VirtualMachinePanelPasswordUpdateRequest: VPSV1VirtualMachinePanelPasswordUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setPanelPasswordV1(virtualMachineId, vPSV1VirtualMachinePanelPasswordUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sets the root password for a specified virtual machine.  Requirements for the password is the same as in the [recreate virtual machine endpoint](/#tag/vps-virtual-machine/POST/api/vps/v1/virtual-machines/{virtualMachineId}/recreate).
     * @summary Set root password
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineRootPasswordUpdateRequest} vPSV1VirtualMachineRootPasswordUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setRootPasswordV1(virtualMachineId: number, vPSV1VirtualMachineRootPasswordUpdateRequest: VPSV1VirtualMachineRootPasswordUpdateRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setRootPasswordV1(virtualMachineId, vPSV1VirtualMachineRootPasswordUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will setup newly purchased virtual machine with `initial` state. 
     * @summary Setup new virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {VPSV1VirtualMachineSetupRequest} vPSV1VirtualMachineSetupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public setupNewVirtualMachineV1(virtualMachineId: number, vPSV1VirtualMachineSetupRequest: VPSV1VirtualMachineSetupRequest, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).setupNewVirtualMachineV1(virtualMachineId, vPSV1VirtualMachineSetupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint starts a specified virtual machine.  If the virtual machine is already running, the request will still be processed without any effect.
     * @summary Start virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public startVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).startVirtualMachineV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint stops a specified virtual machine.  If the virtual machine is already stopped, the request will still be processed without any effect.
     * @summary Stop virtual machine
     * @param {number} virtualMachineId Virtual Machine ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VPSVirtualMachineApi
     */
    public stopVirtualMachineV1(virtualMachineId: number, options?: RawAxiosRequestConfig) {
        return VPSVirtualMachineApiFp(this.configuration).stopVirtualMachineV1(virtualMachineId, options).then((request) => request(this.axios, this.basePath));
    }
}



