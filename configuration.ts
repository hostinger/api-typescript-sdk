/* tslint:disable */
/* eslint-disable */
/**
 * Hostinger API
 * > [!caution] > Currently, this API is in beta stage, meaning that breaking changes, while unlikely, might be introduced. > If you encounter any issues or have any feedback, please create an issue on the [Github Repository](https://github.com/hostinger/api/issues). # Overview The Hostinger API provides a comprehensive set of endpoints that allow developers to interact with Hostinger\'s services programmatically.  This API enables you to manage various aspects of your Hostinger account.  The Hostinger API is a (mostly) RESTful API that uses standard HTTP methods and status codes. # Authentication The Hostinger API uses tokens for authentication. To authenticate your requests, you need to include a valid bearer token in the Authorization header of your HTTP requests: ```yaml Authorization: Bearer YOUR_API_TOKEN ``` API tokens for individual users can be created and managed from the [VPS page](https://hpanel.hostinger.com/vps) of the Hostinger Panel. Tokens will have same permissions as the owning user. Optionally, tokens can be set to expire after a certain period of time. # Rate Limiting To ensure fair usage and prevent abuse, the API enforces rate limits on the number of requests that can be made within a certain time period.  If you exceed the rate limit, you will receive a 429 Too Many Requests response. Rate limit headers are included in the response to help you manage your requests. Your IP address might get temporarily blocked if you exceed the rate limit multiple times. # Parameters All requests sent to API must have the content type `application/json`. `POST`, `PUT`, `PATCH` methods may include a JSON object in the request body. Documentation provides required structure and examples of the object. Some endpoints require path parameters. These parameters are included in the URL path and are marked with curly braces. # Pagination Some endpoints return a large number of items. To make these responses more manageable, the API uses pagination. By default, the API returns 50 items per page.     The page number can be specified using the `page` query parameter, for example: `/api/vps/v1/public-keys?page=2` # Errors The Hostinger API uses standard HTTP status codes to indicate the success or failure of a request. In case of an error, the API will return a JSON response with an `error` field, containing a human-readable error message. Error responses also contain a `correlation_id` field which can be used to identify the request in case you need to contact support. # Change log For information on the latest changes to the API, please refer to the [change log](https://github.com/hostinger/api/blob/main/CHANGELOG.md). # Support             If you have any questions, feedback or feature requests, please create an [issue](https://github.com/hostinger/api/issues) or [discussion](https://github.com/hostinger/api/discussions) on the repository.  For any support take a look at our [Github Repository](https://github.com/hostinger/api/), dedicated to the Hostinger API.
 *
 * The version of the OpenAPI document: 0.0.1-beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    serverIndex?: number;
    baseOptions?: any;
    formDataCtor?: new () => any;
}

export class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * override server index
     *
     * @type {number}
     * @memberof Configuration
     */
    serverIndex?: number;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;

    constructor(param: ConfigurationParameters = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.serverIndex = param.serverIndex;
        this.baseOptions = {
            ...param.baseOptions,
            headers: {
                ...param.baseOptions?.headers,
            },
        };
        this.formDataCtor = param.formDataCtor;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
